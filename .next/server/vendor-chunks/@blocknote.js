"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@blocknote";
exports.ids = ["vendor-chunks/@blocknote"];
exports.modules = {

/***/ "(ssr)/./node_modules/@blocknote/core/src/fonts/inter.css":
/*!**********************************************************!*\
  !*** ./node_modules/@blocknote/core/src/fonts/inter.css ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"66a5d4cc5d8e\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9jb3JlL3NyYy9mb250cy9pbnRlci5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbGl2ZWJsb2Nrcy1leGFtcGxlcy9uZXh0anMteWpzLWJsb2Nrbm90ZS1hZHZhbmNlZC8uL25vZGVfbW9kdWxlcy9AYmxvY2tub3RlL2NvcmUvc3JjL2ZvbnRzL2ludGVyLmNzcz8yNWZhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNjZhNWQ0Y2M1ZDhlXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocknote/core/src/fonts/inter.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@blocknote/react/dist/style.css":
/*!******************************************************!*\
  !*** ./node_modules/@blocknote/react/dist/style.css ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"22f58c72b7ed\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BsaXZlYmxvY2tzLWV4YW1wbGVzL25leHRqcy15anMtYmxvY2tub3RlLWFkdmFuY2VkLy4vbm9kZV9tb2R1bGVzL0BibG9ja25vdGUvcmVhY3QvZGlzdC9zdHlsZS5jc3M/NTU0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjIyZjU4YzcyYjdlZFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocknote/react/dist/style.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@blocknote/core/dist/blocknote.js":
/*!********************************************************!*\
  !*** ./node_modules/@blocknote/core/dist/blocknote.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockNoteEditor: () => (/* binding */ de),\n/* harmony export */   BlockNoteSchema: () => (/* binding */ Tt),\n/* harmony export */   FormattingToolbarProsemirrorPlugin: () => (/* binding */ co),\n/* harmony export */   FormattingToolbarView: () => (/* binding */ ao),\n/* harmony export */   HyperlinkToolbarProsemirrorPlugin: () => (/* binding */ ho),\n/* harmony export */   ImageToolbarProsemirrorPlugin: () => (/* binding */ fo),\n/* harmony export */   ImageToolbarView: () => (/* binding */ mo),\n/* harmony export */   SideMenuProsemirrorPlugin: () => (/* binding */ Co),\n/* harmony export */   SideMenuView: () => (/* binding */ Eo),\n/* harmony export */   SuggestionMenuProseMirrorPlugin: () => (/* binding */ yo),\n/* harmony export */   TableHandlesProsemirrorPlugin: () => (/* binding */ Io),\n/* harmony export */   TableHandlesView: () => (/* binding */ Bo),\n/* harmony export */   UniqueID: () => (/* binding */ Q),\n/* harmony export */   UnreachableCaseError: () => (/* binding */ N),\n/* harmony export */   addIdsToBlock: () => (/* binding */ Zo),\n/* harmony export */   addIdsToBlocks: () => (/* binding */ tr),\n/* harmony export */   addInlineContentAttributes: () => (/* binding */ pn),\n/* harmony export */   addInlineContentKeyboardShortcuts: () => (/* binding */ un),\n/* harmony export */   addStyleAttributes: () => (/* binding */ bn),\n/* harmony export */   blockToNode: () => (/* binding */ P),\n/* harmony export */   camelToDataKebab: () => (/* binding */ it),\n/* harmony export */   checkBlockHasDefaultProp: () => (/* binding */ zr),\n/* harmony export */   checkBlockIsDefaultType: () => (/* binding */ Rr),\n/* harmony export */   checkBlockTypeHasDefaultProp: () => (/* binding */ Wn),\n/* harmony export */   checkDefaultBlockTypeInSchema: () => (/* binding */ L),\n/* harmony export */   contentNodeToInlineContent: () => (/* binding */ wt),\n/* harmony export */   createBlockSpec: () => (/* binding */ dn),\n/* harmony export */   createBlockSpecFromStronglyTypedTiptapNode: () => (/* binding */ tt),\n/* harmony export */   createExternalHTMLExporter: () => (/* binding */ at),\n/* harmony export */   createInlineContentSpec: () => (/* binding */ Dr),\n/* harmony export */   createInlineContentSpecFromTipTapNode: () => (/* binding */ mn),\n/* harmony export */   createInternalBlockSpec: () => (/* binding */ Qt),\n/* harmony export */   createInternalHTMLSerializer: () => (/* binding */ Jt),\n/* harmony export */   createInternalInlineContentSpec: () => (/* binding */ hn),\n/* harmony export */   createInternalStyleSpec: () => (/* binding */ ee),\n/* harmony export */   createStronglyTypedTiptapNode: () => (/* binding */ W),\n/* harmony export */   createStyleSpec: () => (/* binding */ Or),\n/* harmony export */   createStyleSpecFromTipTapMark: () => (/* binding */ O),\n/* harmony export */   createSuggestionMenu: () => (/* binding */ Vr),\n/* harmony export */   defaultBlockSchema: () => (/* binding */ jn),\n/* harmony export */   defaultBlockSpecs: () => (/* binding */ oe),\n/* harmony export */   defaultInlineContentSchema: () => (/* binding */ Ur),\n/* harmony export */   defaultInlineContentSpecs: () => (/* binding */ ie),\n/* harmony export */   defaultProps: () => (/* binding */ w),\n/* harmony export */   defaultStyleSchema: () => (/* binding */ _r),\n/* harmony export */   defaultStyleSpecs: () => (/* binding */ re),\n/* harmony export */   filterSuggestionItems: () => (/* binding */ $r),\n/* harmony export */   formatKeyboardShortcut: () => (/* binding */ V),\n/* harmony export */   formattingToolbarPluginKey: () => (/* binding */ lo),\n/* harmony export */   getBlockFromPos: () => (/* binding */ ln),\n/* harmony export */   getBlockNoteExtensions: () => (/* binding */ qo),\n/* harmony export */   getBlockSchemaFromSpecs: () => (/* binding */ Zt),\n/* harmony export */   getDefaultSlashMenuItems: () => (/* binding */ Fr),\n/* harmony export */   getDraggableBlockFromCoords: () => (/* binding */ Ct),\n/* harmony export */   getInlineContentParseRules: () => (/* binding */ fn),\n/* harmony export */   getInlineContentSchemaFromSpecs: () => (/* binding */ te),\n/* harmony export */   getParseRules: () => (/* binding */ cn),\n/* harmony export */   getStyleParseRules: () => (/* binding */ yn),\n/* harmony export */   getStyleSchemaFromSpecs: () => (/* binding */ ne),\n/* harmony export */   hyperlinkToolbarPluginKey: () => (/* binding */ uo),\n/* harmony export */   inheritedProps: () => (/* binding */ Xt),\n/* harmony export */   inlineContentToNodes: () => (/* binding */ st),\n/* harmony export */   insertOrUpdateBlock: () => (/* binding */ A),\n/* harmony export */   isAppleOS: () => (/* binding */ an),\n/* harmony export */   isLinkInlineContent: () => (/* binding */ It),\n/* harmony export */   isPartialLinkInlineContent: () => (/* binding */ $t),\n/* harmony export */   isSafari: () => (/* binding */ Pr),\n/* harmony export */   isStyledTextInlineContent: () => (/* binding */ Y),\n/* harmony export */   mergeCSSClasses: () => (/* binding */ R),\n/* harmony export */   nodeToBlock: () => (/* binding */ k),\n/* harmony export */   nodeToCustomInlineContent: () => (/* binding */ Wt),\n/* harmony export */   partialBlockToBlockForTesting: () => (/* binding */ ue),\n/* harmony export */   partialBlocksToBlocksForTesting: () => (/* binding */ Gr),\n/* harmony export */   propsToAttributes: () => (/* binding */ Yt),\n/* harmony export */   sideMenuPluginKey: () => (/* binding */ So),\n/* harmony export */   stylePropsToAttributes: () => (/* binding */ gn),\n/* harmony export */   suggestionMenuPluginKey: () => (/* binding */ U),\n/* harmony export */   tableContentToNodes: () => (/* binding */ Gt),\n/* harmony export */   tableHandlesPluginKey: () => (/* binding */ X),\n/* harmony export */   uploadToTmpFilesDotOrg_DEV_ONLY: () => (/* binding */ Hr),\n/* harmony export */   wrapInBlockStructure: () => (/* binding */ pt)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var rehype_parse__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! rehype-parse */ \"(ssr)/./node_modules/rehype-parse/lib/index.js\");\n/* harmony import */ var rehype_stringify__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! rehype-stringify */ \"(ssr)/./node_modules/rehype-stringify/lib/index.js\");\n/* harmony import */ var unified__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! unified */ \"(ssr)/./node_modules/unified/lib/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var hast_util_from_dom__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! hast-util-from-dom */ \"(ssr)/./node_modules/hast-util-from-dom/lib/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-underline */ \"(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_cell__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-table-cell */ \"(ssr)/./node_modules/@tiptap/extension-table-cell/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_header__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-table-header */ \"(ssr)/./node_modules/@tiptap/extension-table-header/dist/index.js\");\n/* harmony import */ var _tiptap_extension_table_row__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-table-row */ \"(ssr)/./node_modules/@tiptap/extension-table-row/dist/index.js\");\n/* harmony import */ var prosemirror_tables__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prosemirror-tables */ \"(ssr)/./node_modules/prosemirror-tables/dist/index.js\");\n/* harmony import */ var rehype_remark__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! rehype-remark */ \"(ssr)/./node_modules/rehype-remark/lib/index.js\");\n/* harmony import */ var remark_gfm__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! remark-gfm */ \"(ssr)/./node_modules/remark-gfm/index.js\");\n/* harmony import */ var remark_stringify__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! remark-stringify */ \"(ssr)/./node_modules/remark-stringify/lib/index.js\");\n/* harmony import */ var remark_parse__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! remark-parse */ \"(ssr)/./node_modules/remark-parse/lib/index.js\");\n/* harmony import */ var remark_rehype__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! remark-rehype */ \"(ssr)/./node_modules/remark-rehype/lib/index.js\");\n/* harmony import */ var remark_rehype__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! remark-rehype */ \"(ssr)/./node_modules/mdast-util-to-hast/lib/handlers/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-collaboration */ \"(ssr)/./node_modules/@tiptap/extension-collaboration/dist/index.js\");\n/* harmony import */ var _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-collaboration-cursor */ \"(ssr)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-history */ \"(ssr)/./node_modules/@tiptap/extension-history/dist/index.js\");\n/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-link */ \"(ssr)/./node_modules/@tiptap/extension-link/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\nvar he = Object.defineProperty;\nvar me = (n, t, e) => t in n ? he(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;\nvar d = (n, t, e) => (me(n, typeof t != \"symbol\" ? t + \"\" : t, e), e);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction tn(n, t = JSON.stringify) {\n  const e = {};\n  return n.filter((o) => {\n    const r = t(o);\n    return Object.prototype.hasOwnProperty.call(e, r) ? !1 : e[r] = !0;\n  });\n}\nfunction en(n) {\n  const t = n.filter(\n    (o, r) => n.indexOf(o) !== r\n  );\n  return tn(t);\n}\nconst Q = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"uniqueID\",\n  // we’ll set a very high priority to make sure this runs first\n  // and is compatible with `appendTransaction` hooks of other extensions\n  priority: 1e4,\n  addOptions() {\n    return {\n      attributeName: \"id\",\n      types: [],\n      generateID: () => {\n        if (typeof window < \"u\" && window.__TEST_OPTIONS) {\n          const n = window.__TEST_OPTIONS;\n          return n.mockID === void 0 ? n.mockID = 0 : n.mockID++, n.mockID.toString();\n        }\n        return (0,uuid__WEBPACK_IMPORTED_MODULE_18__[\"default\"])();\n      },\n      filterTransaction: null\n    };\n  },\n  addGlobalAttributes() {\n    return [\n      {\n        types: this.options.types,\n        attributes: {\n          [this.options.attributeName]: {\n            default: null,\n            parseHTML: (n) => n.getAttribute(`data-${this.options.attributeName}`),\n            renderHTML: (n) => ({\n              [`data-${this.options.attributeName}`]: n[this.options.attributeName]\n            })\n          }\n        }\n      }\n    ];\n  },\n  // check initial content for missing ids\n  // onCreate() {\n  //   // Don’t do this when the collaboration extension is active\n  //   // because this may update the content, so Y.js tries to merge these changes.\n  //   // This leads to empty block nodes.\n  //   // See: https://github.com/ueberdosis/tiptap/issues/2400\n  //   if (\n  //     this.editor.extensionManager.extensions.find(\n  //       (extension) => extension.name === \"collaboration\"\n  //     )\n  //   ) {\n  //     return;\n  //   }\n  //   const { view, state } = this.editor;\n  //   const { tr, doc } = state;\n  //   const { types, attributeName, generateID } = this.options;\n  //   const nodesWithoutId = findChildren(doc, (node) => {\n  //     return (\n  //       types.includes(node.type.name) && node.attrs[attributeName] === null\n  //     );\n  //   });\n  //   nodesWithoutId.forEach(({ node, pos }) => {\n  //     tr.setNodeMarkup(pos, undefined, {\n  //       ...node.attrs,\n  //       [attributeName]: generateID(),\n  //     });\n  //   });\n  //   tr.setMeta(\"addToHistory\", false);\n  //   view.dispatch(tr);\n  // },\n  addProseMirrorPlugins() {\n    let n = null, t = !1;\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"uniqueID\"),\n        appendTransaction: (e, o, r) => {\n          const i = e.some((f) => f.docChanged) && !o.doc.eq(r.doc), s = this.options.filterTransaction && e.some((f) => {\n            let y, S;\n            return !(!((S = (y = this.options).filterTransaction) === null || S === void 0) && S.call(y, f));\n          });\n          if (!i || s)\n            return;\n          const { tr: a } = r, { types: l, attributeName: c, generateID: p } = this.options, u = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.combineTransactionSteps)(\n            o.doc,\n            e\n          ), { mapping: m } = u;\n          if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.getChangedRanges)(u).forEach(({ newRange: f }) => {\n            const y = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.findChildrenInRange)(\n              r.doc,\n              f,\n              (E) => l.includes(E.type.name)\n            ), S = y.map(({ node: E }) => E.attrs[c]).filter((E) => E !== null), B = en(S);\n            y.forEach(({ node: E, pos: D }) => {\n              let z;\n              const K = (z = a.doc.nodeAt(D)) === null || z === void 0 ? void 0 : z.attrs[c];\n              if (K === null) {\n                const lt = o.doc.type.createAndFill().content;\n                if (o.doc.content.findDiffStart(lt) === null) {\n                  const et = JSON.parse(\n                    JSON.stringify(r.doc.toJSON())\n                  );\n                  if (et.content[0].content[0].attrs.id = \"initialBlockId\", JSON.stringify(et.content) === JSON.stringify(lt.toJSON())) {\n                    a.setNodeMarkup(D, void 0, {\n                      ...E.attrs,\n                      [c]: \"initialBlockId\"\n                    });\n                    return;\n                  }\n                }\n                a.setNodeMarkup(D, void 0, {\n                  ...E.attrs,\n                  [c]: p()\n                });\n                return;\n              }\n              const { deleted: g } = m.invert().mapResult(D);\n              g && B.includes(K) && a.setNodeMarkup(D, void 0, {\n                ...E.attrs,\n                [c]: p()\n              });\n            });\n          }), !!a.steps.length)\n            return a;\n        },\n        // we register a global drag handler to track the current drag source element\n        view(e) {\n          const o = (r) => {\n            let i;\n            n = !((i = e.dom.parentElement) === null || i === void 0) && i.contains(r.target) ? e.dom.parentElement : null;\n          };\n          return window.addEventListener(\"dragstart\", o), {\n            destroy() {\n              window.removeEventListener(\"dragstart\", o);\n            }\n          };\n        },\n        props: {\n          // `handleDOMEvents` is called before `transformPasted`\n          // so we can do some checks before\n          handleDOMEvents: {\n            // only create new ids for dropped content while holding `alt`\n            // or content is dragged from another editor\n            drop: (e, o) => {\n              let r;\n              return (n !== e.dom.parentElement || ((r = o.dataTransfer) === null || r === void 0 ? void 0 : r.effectAllowed) === \"copy\") && (n = null, t = !0), !1;\n            },\n            // always create new ids on pasted content\n            paste: () => (t = !0, !1)\n          },\n          // we’ll remove ids for every pasted node\n          // so we can create a new one within `appendTransaction`\n          transformPasted: (e) => {\n            if (!t)\n              return e;\n            const { types: o, attributeName: r } = this.options, i = (s) => {\n              const a = [];\n              return s.forEach((l) => {\n                if (l.isText) {\n                  a.push(l);\n                  return;\n                }\n                if (!o.includes(l.type.name)) {\n                  a.push(l.copy(i(l.content)));\n                  return;\n                }\n                const c = l.type.create(\n                  {\n                    ...l.attrs,\n                    [r]: null\n                  },\n                  i(l.content),\n                  l.marks\n                );\n                a.push(c);\n              }), prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(a);\n            };\n            return t = !1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Slice(\n              i(e.content),\n              e.openStart,\n              e.openEnd\n            );\n          }\n        }\n      })\n    ];\n  }\n});\nfunction Ft(n) {\n  const t = n.attrs.id, e = n.firstChild, o = e.type, r = n.childCount === 2 ? n.lastChild.childCount : 0;\n  return {\n    id: t,\n    node: n,\n    contentNode: e,\n    contentType: o,\n    numChildBlocks: r\n  };\n}\nfunction b(n, t) {\n  const o = n.nodeSize - 2;\n  if (t <= 1)\n    for (t = 1 + 1; n.resolve(t).parent.type.name !== \"blockContainer\" && t < o; )\n      t++;\n  else if (t >= o)\n    for (t = o - 1; n.resolve(t).parent.type.name !== \"blockContainer\" && t > 1; )\n      t--;\n  n.resolve(t).parent.type.name === \"blockGroup\" && t++;\n  const r = n.resolve(t), i = r.depth;\n  let s = r.node(i), a = i;\n  for (; ; ) {\n    if (a < 0)\n      throw new Error(\n        \"Could not find blockContainer node. This can only happen if the underlying BlockNote schema has been edited.\"\n      );\n    if (s.type.name === \"blockContainer\")\n      break;\n    a -= 1, s = r.node(a);\n  }\n  const { id: l, contentNode: c, contentType: p, numChildBlocks: u } = Ft(s), m = r.start(a), h = r.end(a);\n  return {\n    id: l,\n    node: s,\n    contentNode: c,\n    contentType: p,\n    numChildBlocks: u,\n    startPos: m,\n    endPos: h,\n    depth: a\n  };\n}\nfunction It(n) {\n  return n.type === \"link\";\n}\nfunction $t(n) {\n  return typeof n != \"string\" && n.type === \"link\";\n}\nfunction Y(n) {\n  return typeof n != \"string\" && n.type === \"text\";\n}\nclass N extends Error {\n  constructor(t) {\n    super(`Unreachable case: ${t}`);\n  }\n}\nfunction Lt(n, t, e) {\n  const o = [];\n  for (const [r, i] of Object.entries(n.styles)) {\n    const s = e[r];\n    if (!s)\n      throw new Error(`style ${r} not found in styleSchema`);\n    if (s.propSchema === \"boolean\")\n      o.push(t.mark(r));\n    else if (s.propSchema === \"string\")\n      o.push(t.mark(r, { stringValue: i }));\n    else\n      throw new N(s.propSchema);\n  }\n  return n.text.split(/(\\n)/g).filter((r) => r.length > 0).map((r) => r === `\n` ? t.nodes.hardBreak.create() : t.text(r, o));\n}\nfunction nn(n, t, e) {\n  const o = t.marks.link.create({\n    href: n.href\n  });\n  return ft(n.content, t, e).map(\n    (r) => {\n      if (r.type.name === \"text\")\n        return r.mark([...r.marks, o]);\n      if (r.type.name === \"hardBreak\")\n        return r;\n      throw new Error(\"unexpected node type\");\n    }\n  );\n}\nfunction ft(n, t, e) {\n  const o = [];\n  if (typeof n == \"string\")\n    return o.push(\n      ...Lt(\n        { type: \"text\", text: n, styles: {} },\n        t,\n        e\n      )\n    ), o;\n  for (const r of n)\n    o.push(...Lt(r, t, e));\n  return o;\n}\nfunction st(n, t, e) {\n  const o = [];\n  for (const r of n)\n    typeof r == \"string\" ? o.push(...ft(r, t, e)) : $t(r) ? o.push(...nn(r, t, e)) : Y(r) ? o.push(...ft([r], t, e)) : o.push(\n      jt(r, t, e)\n    );\n  return o;\n}\nfunction Gt(n, t, e) {\n  const o = [];\n  for (const r of n.rows) {\n    const i = [];\n    for (const a of r.cells) {\n      let l;\n      if (!a)\n        l = t.nodes.tableParagraph.create({});\n      else if (typeof a == \"string\")\n        l = t.nodes.tableParagraph.create({}, t.text(a));\n      else {\n        const p = st(a, t, e);\n        l = t.nodes.tableParagraph.create({}, p);\n      }\n      const c = t.nodes.tableCell.create({}, l);\n      i.push(c);\n    }\n    const s = t.nodes.tableRow.create({}, i);\n    o.push(s);\n  }\n  return o;\n}\nfunction jt(n, t, e) {\n  let o, r = n.type;\n  if (r === void 0 && (r = \"paragraph\"), !t.nodes[r])\n    throw new Error(`node type ${r} not found in schema`);\n  if (!n.content)\n    o = t.nodes[r].create(n.props);\n  else if (typeof n.content == \"string\")\n    o = t.nodes[r].create(\n      n.props,\n      t.text(n.content)\n    );\n  else if (Array.isArray(n.content)) {\n    const i = st(n.content, t, e);\n    o = t.nodes[r].create(n.props, i);\n  } else if (n.content.type === \"tableContent\") {\n    const i = Gt(n.content, t, e);\n    o = t.nodes[r].create(n.props, i);\n  } else\n    throw new N(n.content.type);\n  return o;\n}\nfunction P(n, t, e) {\n  let o = n.id;\n  o === void 0 && (o = Q.options.generateID());\n  const r = jt(\n    n,\n    t,\n    e\n  ), i = [];\n  if (n.children)\n    for (const a of n.children)\n      i.push(P(a, t, e));\n  const s = t.nodes.blockGroup.create({}, i);\n  return t.nodes.blockContainer.create(\n    {\n      id: o,\n      ...n.props\n    },\n    i.length > 0 ? [r, s] : r\n  );\n}\nfunction on(n, t, e) {\n  const o = {\n    type: \"tableContent\",\n    rows: []\n  };\n  return n.content.forEach((r) => {\n    const i = {\n      cells: []\n    };\n    r.content.forEach((s) => {\n      i.cells.push(\n        wt(\n          s.firstChild,\n          t,\n          e\n        )\n      );\n    }), o.rows.push(i);\n  }), o;\n}\nfunction wt(n, t, e) {\n  const o = [];\n  let r;\n  return n.content.forEach((i) => {\n    if (i.type.name === \"hardBreak\") {\n      if (r)\n        if (Y(r))\n          r.text += `\n`;\n        else if (It(r))\n          r.content[r.content.length - 1].text += `\n`;\n        else\n          throw new Error(\"unexpected\");\n      else\n        r = {\n          type: \"text\",\n          text: `\n`,\n          styles: {}\n        };\n      return;\n    }\n    if (i.type.name !== \"link\" && i.type.name !== \"text\" && t[i.type.name]) {\n      r && (o.push(r), r = void 0), o.push(\n        Wt(i, t, e)\n      );\n      return;\n    }\n    const s = {};\n    let a;\n    for (const l of i.marks)\n      if (l.type.name === \"link\")\n        a = l;\n      else {\n        const c = e[l.type.name];\n        if (!c)\n          throw new Error(`style ${l.type.name} not found in styleSchema`);\n        if (c.propSchema === \"boolean\")\n          s[c.type] = !0;\n        else if (c.propSchema === \"string\")\n          s[c.type] = l.attrs.stringValue;\n        else\n          throw new N(c.propSchema);\n      }\n    r ? Y(r) ? a ? (o.push(r), r = {\n      type: \"link\",\n      href: a.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: i.textContent,\n          styles: s\n        }\n      ]\n    }) : JSON.stringify(r.styles) === JSON.stringify(s) ? r.text += i.textContent : (o.push(r), r = {\n      type: \"text\",\n      text: i.textContent,\n      styles: s\n    }) : It(r) && (a ? r.href === a.attrs.href ? JSON.stringify(\n      r.content[r.content.length - 1].styles\n    ) === JSON.stringify(s) ? r.content[r.content.length - 1].text += i.textContent : r.content.push({\n      type: \"text\",\n      text: i.textContent,\n      styles: s\n    }) : (o.push(r), r = {\n      type: \"link\",\n      href: a.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: i.textContent,\n          styles: s\n        }\n      ]\n    }) : (o.push(r), r = {\n      type: \"text\",\n      text: i.textContent,\n      styles: s\n    })) : a ? r = {\n      type: \"link\",\n      href: a.attrs.href,\n      content: [\n        {\n          type: \"text\",\n          text: i.textContent,\n          styles: s\n        }\n      ]\n    } : r = {\n      type: \"text\",\n      text: i.textContent,\n      styles: s\n    };\n  }), r && o.push(r), o;\n}\nfunction Wt(n, t, e) {\n  if (n.type.name === \"text\" || n.type.name === \"link\")\n    throw new Error(\"unexpected\");\n  const o = {}, r = t[n.type.name];\n  for (const [a, l] of Object.entries(n.attrs)) {\n    if (!r)\n      throw Error(\"ic node is of an unrecognized type: \" + n.type.name);\n    const c = r.propSchema;\n    a in c && (o[a] = l);\n  }\n  let i;\n  return r.content === \"styled\" ? i = wt(\n    n,\n    t,\n    e\n  ) : i = void 0, {\n    type: n.type.name,\n    props: o,\n    content: i\n  };\n}\nfunction k(n, t, e, o, r) {\n  if (n.type.name !== \"blockContainer\")\n    throw Error(\n      \"Node must be of type blockContainer, but is of type\" + n.type.name + \".\"\n    );\n  const i = r == null ? void 0 : r.get(n);\n  if (i)\n    return i;\n  const s = Ft(n);\n  let a = s.id;\n  a === null && (a = Q.options.generateID());\n  const l = {};\n  for (const [h, f] of Object.entries({\n    ...n.attrs,\n    ...s.contentNode.attrs\n  })) {\n    const y = t[s.contentType.name];\n    if (!y)\n      throw Error(\n        \"Block is of an unrecognized type: \" + s.contentType.name\n      );\n    const S = y.propSchema;\n    h in S && (l[h] = f);\n  }\n  const c = t[s.contentType.name], p = [];\n  for (let h = 0; h < s.numChildBlocks; h++)\n    p.push(\n      k(\n        n.lastChild.child(h),\n        t,\n        e,\n        o,\n        r\n      )\n    );\n  let u;\n  if (c.content === \"inline\")\n    u = wt(\n      s.contentNode,\n      e,\n      o\n    );\n  else if (c.content === \"table\")\n    u = on(\n      s.contentNode,\n      e,\n      o\n    );\n  else if (c.content === \"none\")\n    u = void 0;\n  else\n    throw new N(c.content);\n  const m = {\n    id: a,\n    type: c.type,\n    props: l,\n    content: u,\n    children: p\n  };\n  return r == null || r.set(n, m), m;\n}\nfunction rn(n) {\n  return n.document || window.document;\n}\nconst qt = (n, t, e, o, r) => {\n  if (!e.nodes[n.type.name])\n    throw new Error(\"Serializer is missing a node type: \" + n.type.name);\n  const { dom: i, contentDOM: s } = prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.DOMSerializer.renderSpec(\n    rn(t),\n    e.nodes[n.type.name](n)\n  );\n  if (s) {\n    if (n.isLeaf)\n      throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n    if (n.type.name === \"blockContainer\") {\n      const a = n.childCount > 0 && n.firstChild.type.spec.group === \"blockContent\" ? n.firstChild : void 0, l = n.childCount > 0 && n.lastChild.type.spec.group === \"blockGroup\" ? n.lastChild : void 0;\n      if (a !== void 0) {\n        const c = o.blockImplementations[a.type.name].implementation, u = (r ? c.toExternalHTML : c.toInternalHTML)(\n          k(\n            n,\n            o.schema.blockSchema,\n            o.schema.inlineContentSchema,\n            o.schema.styleSchema,\n            o.blockCache\n          ),\n          o\n        );\n        if (u.contentDOM !== void 0) {\n          if (n.isLeaf)\n            throw new RangeError(\n              \"Content hole not allowed in a leaf node spec\"\n            );\n          u.contentDOM.appendChild(\n            e.serializeFragment(a.content, t)\n          );\n        }\n        s.appendChild(u.dom);\n      }\n      l !== void 0 && e.serializeFragment(\n        prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(l),\n        t,\n        s\n      );\n    } else\n      e.serializeFragment(n.content, t, s);\n  }\n  return i;\n}, Kt = (n, t) => {\n  const e = t.serializeFragment(n), o = document.createElement(\"div\");\n  return o.appendChild(e), o.innerHTML;\n};\nfunction sn(n) {\n  const t = /* @__PURE__ */ new Set([\n    ...n.orderedListItemBlockTypes,\n    ...n.unorderedListItemBlockTypes\n  ]), e = (o) => {\n    var s;\n    if (o.children.length === 1 && ((s = o.children[0].properties) == null ? void 0 : s.dataNodeType) === \"blockGroup\") {\n      const a = o.children[0];\n      o.children.pop(), o.children.push(...a.children);\n    }\n    let r = o.children.length, i;\n    for (let a = 0; a < r; a++) {\n      const c = o.children[a].children[0], p = c.children[0], u = c.children.length === 2 ? c.children[1] : null, m = t.has(\n        p.properties.dataContentType\n      ), h = m ? n.orderedListItemBlockTypes.has(\n        p.properties.dataContentType\n      ) ? \"ol\" : \"ul\" : null;\n      if (u !== null && e(u), i && i.tagName !== h) {\n        o.children.splice(\n          a - i.children.length,\n          i.children.length,\n          i\n        );\n        const f = i.children.length - 1;\n        a -= f, r -= f, i = void 0;\n      }\n      if (m) {\n        i || (i = (0,hast_util_from_dom__WEBPACK_IMPORTED_MODULE_21__.fromDom)(\n          document.createElement(h)\n        ));\n        const f = (0,hast_util_from_dom__WEBPACK_IMPORTED_MODULE_21__.fromDom)(\n          document.createElement(\"li\")\n        );\n        f.children.push(p.children[0]), u !== null && f.children.push(...u.children), i.children.push(f);\n      } else if (u !== null) {\n        o.children.splice(a + 1, 0, ...u.children), o.children[a] = p.children[0];\n        const f = u.children.length;\n        a += f, r += f;\n      } else\n        o.children[a] = p.children[0];\n    }\n    i && o.children.splice(\n      r - i.children.length,\n      i.children.length,\n      i\n    );\n  };\n  return e;\n}\nconst at = (n, t) => {\n  const e = prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.DOMSerializer.fromSchema(n);\n  return e.serializeNodeInner = (o, r) => qt(o, r, e, t, !0), e.exportProseMirrorFragment = (o) => (0,unified__WEBPACK_IMPORTED_MODULE_22__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_23__[\"default\"], { fragment: !0 }).use(sn, {\n    orderedListItemBlockTypes: /* @__PURE__ */ new Set([\"numberedListItem\"]),\n    unorderedListItemBlockTypes: /* @__PURE__ */ new Set([\"bulletListItem\"])\n  }).use(rehype_stringify__WEBPACK_IMPORTED_MODULE_24__[\"default\"]).processSync(Kt(o, e)).value, e.exportBlocks = (o) => {\n    const r = o.map(\n      (s) => P(s, n, t.schema.styleSchema)\n    ), i = n.nodes.blockGroup.create(null, r);\n    return e.exportProseMirrorFragment(prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(i));\n  }, e;\n}, Jt = (n, t) => {\n  const e = prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.DOMSerializer.fromSchema(n);\n  return e.serializeNodeInner = (o, r) => qt(o, r, e, t, !1), e.serializeProseMirrorFragment = (o) => Kt(o, e), e.serializeBlocks = (o) => {\n    const r = o.map(\n      (s) => P(s, n, t.schema.styleSchema)\n    ), i = n.nodes.blockGroup.create(null, r);\n    return e.serializeProseMirrorFragment(prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(i));\n  }, e;\n}, Hr = async (n) => {\n  const t = new FormData();\n  return t.append(\"file\", n), (await (await fetch(\"https://tmpfiles.org/api/v1/upload\", {\n    method: \"POST\",\n    body: t\n  })).json()).data.url.replace(\n    \"tmpfiles.org/\",\n    \"tmpfiles.org/dl/\"\n  );\n}, an = () => typeof navigator < \"u\" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent));\nfunction V(n) {\n  return an() ? n.replace(\"Mod\", \"⌘\") : n.replace(\"Mod\", \"Ctrl\");\n}\nfunction R(...n) {\n  return n.filter((t) => t).join(\" \");\n}\nconst Pr = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nfunction Z(n, t, e, o) {\n  const r = document.createElement(\"div\");\n  r.className = R(\n    \"bn-block-content\",\n    e.class\n  ), r.setAttribute(\"data-content-type\", n);\n  for (const [s, a] of Object.entries(e))\n    s !== \"class\" && r.setAttribute(s, a);\n  const i = document.createElement(t);\n  i.className = R(\n    \"bn-inline-content\",\n    o.class\n  );\n  for (const [s, a] of Object.entries(\n    o\n  ))\n    s !== \"class\" && i.setAttribute(s, a);\n  return r.appendChild(i), {\n    dom: r,\n    contentDOM: i\n  };\n}\nconst Nt = (n, t) => {\n  const e = P(\n    n,\n    t._tiptapEditor.schema,\n    t.schema.styleSchema\n  ).firstChild, o = t._tiptapEditor.schema.nodes[e.type.name].spec.toDOM;\n  if (o === void 0)\n    throw new Error(\n      \"This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`.\"\n    );\n  const r = o(e);\n  if (typeof r != \"object\" || !(\"dom\" in r))\n    throw new Error(\n      \"Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property.\"\n    );\n  return r;\n}, w = {\n  backgroundColor: {\n    default: \"default\"\n  },\n  textColor: {\n    default: \"default\"\n  },\n  textAlignment: {\n    default: \"left\",\n    values: [\"left\", \"center\", \"right\", \"justify\"]\n  }\n}, Xt = [\"backgroundColor\", \"textColor\"];\nfunction it(n) {\n  return \"data-\" + n.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction Yt(n) {\n  const t = {};\n  return Object.entries(n).filter(([e, o]) => !Xt.includes(e)).forEach(([e, o]) => {\n    t[e] = {\n      default: o.default,\n      keepOnSplit: !0,\n      // Props are displayed in kebab-case as HTML attributes. If a prop's\n      // value is the same as its default, we don't display an HTML\n      // attribute for it.\n      parseHTML: (r) => {\n        const i = r.getAttribute(it(e));\n        if (i === null)\n          return null;\n        if (typeof o.default == \"boolean\")\n          return i === \"true\" ? !0 : i === \"false\" ? !1 : null;\n        if (typeof o.default == \"number\") {\n          const s = parseFloat(i);\n          return !Number.isNaN(s) && Number.isFinite(s) ? s : null;\n        }\n        return i;\n      },\n      renderHTML: (r) => r[e] !== o.default ? {\n        [it(e)]: r[e]\n      } : {}\n    };\n  }), t;\n}\nfunction ln(n, t, e, o) {\n  if (typeof n == \"boolean\")\n    throw new Error(\n      \"Cannot find node position as getPos is a boolean, not a function.\"\n    );\n  const r = n(), s = e.state.doc.resolve(r).node().attrs.id, a = t.getBlock(s);\n  if (a.type !== o)\n    throw new Error(\"Block type does not match\");\n  return a;\n}\nfunction pt(n, t, e, o, r) {\n  const i = document.createElement(\"div\");\n  if (r !== void 0)\n    for (const [s, a] of Object.entries(r))\n      s !== \"class\" && i.setAttribute(s, a);\n  i.className = R(\n    \"bn-block-content\",\n    (r == null ? void 0 : r.class) || \"\"\n  ), i.setAttribute(\"data-content-type\", t);\n  for (const [s, a] of Object.entries(e))\n    !Xt.includes(s) && a !== o[s].default && i.setAttribute(it(s), a);\n  return i.appendChild(n.dom), n.contentDOM !== void 0 && (n.contentDOM.className = R(\n    \"bn-inline-content\",\n    n.contentDOM.className\n  ), n.contentDOM.setAttribute(\"data-editable\", \"\")), {\n    ...n,\n    dom: i\n  };\n}\nfunction W(n) {\n  return _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Node.create(n);\n}\nfunction Qt(n, t) {\n  return {\n    config: n,\n    implementation: t\n  };\n}\nfunction tt(n, t, e) {\n  return Qt(\n    {\n      type: n.name,\n      content: n.config.content === \"inline*\" ? \"inline\" : n.config.content === \"tableRow+\" ? \"table\" : \"none\",\n      propSchema: t\n    },\n    {\n      node: n,\n      requiredExtensions: e,\n      toInternalHTML: Nt,\n      toExternalHTML: Nt\n      // parse: () => undefined, // parse rules are in node already\n    }\n  );\n}\nfunction Zt(n) {\n  return Object.fromEntries(\n    Object.entries(n).map(([t, e]) => [t, e.config])\n  );\n}\nfunction cn(n, t) {\n  const e = [\n    {\n      tag: \"[data-content-type=\" + n.type + \"]\",\n      contentElement: \"[data-editable]\"\n    }\n  ];\n  return t && e.push({\n    tag: \"*\",\n    getAttrs(o) {\n      if (typeof o == \"string\")\n        return !1;\n      const r = t == null ? void 0 : t(o);\n      return r === void 0 ? !1 : r;\n    }\n  }), e;\n}\nfunction dn(n, t) {\n  const e = W({\n    name: n.type,\n    content: n.content === \"inline\" ? \"inline*\" : \"\",\n    group: \"blockContent\",\n    selectable: !0,\n    addAttributes() {\n      return Yt(n.propSchema);\n    },\n    parseHTML() {\n      return cn(n, t.parse);\n    },\n    renderHTML() {\n      const o = document.createElement(\"div\");\n      return o.setAttribute(\"data-tmp-placeholder\", \"true\"), {\n        dom: o\n      };\n    },\n    addNodeView() {\n      return ({ getPos: o }) => {\n        var l;\n        const r = this.options.editor, i = ln(\n          o,\n          r,\n          this.editor,\n          n.type\n        ), s = ((l = this.options.domAttributes) == null ? void 0 : l.blockContent) || {}, a = t.render(i, r);\n        return pt(\n          a,\n          i.type,\n          i.props,\n          n.propSchema,\n          s\n        );\n      };\n    }\n  });\n  if (e.name !== n.type)\n    throw new Error(\n      \"Node name does not match block type. This is a bug in BlockNote.\"\n    );\n  return Qt(n, {\n    node: e,\n    toInternalHTML: (o, r) => {\n      var a;\n      const i = ((a = e.options.domAttributes) == null ? void 0 : a.blockContent) || {}, s = t.render(o, r);\n      return pt(\n        s,\n        o.type,\n        o.props,\n        n.propSchema,\n        i\n      );\n    },\n    toExternalHTML: (o, r) => {\n      var a, l;\n      const i = ((a = e.options.domAttributes) == null ? void 0 : a.blockContent) || {};\n      let s = (l = t.toExternalHTML) == null ? void 0 : l.call(\n        t,\n        o,\n        r\n      );\n      return s === void 0 && (s = t.render(o, r)), pt(\n        s,\n        o.type,\n        o.props,\n        n.propSchema,\n        i\n      );\n    }\n  });\n}\nfunction pn(n, t, e, o) {\n  return n.dom.setAttribute(\"data-inline-content-type\", t), Object.entries(e).filter(([r, i]) => i !== o[r].default).map(([r, i]) => [it(r), i]).forEach(([r, i]) => n.dom.setAttribute(r, i)), n.contentDOM !== void 0 && n.contentDOM.setAttribute(\"data-editable\", \"\"), n;\n}\nfunction un(n) {\n  return {\n    Backspace: ({ editor: t }) => {\n      const e = t.state.selection.$from;\n      return t.state.selection.empty && e.node().type.name === n.type && e.parentOffset === 0;\n    }\n  };\n}\nfunction hn(n, t) {\n  return {\n    config: n,\n    implementation: t\n  };\n}\nfunction mn(n, t) {\n  return hn(\n    {\n      type: n.name,\n      propSchema: t,\n      content: n.config.content === \"inline*\" ? \"styled\" : \"none\"\n    },\n    {\n      node: n\n    }\n  );\n}\nfunction te(n) {\n  return Object.fromEntries(\n    Object.entries(n).map(([t, e]) => [t, e.config])\n  );\n}\nfunction fn(n) {\n  return [\n    {\n      tag: `[data-inline-content-type=\"${n.type}\"]`,\n      contentElement: (t) => {\n        const e = t;\n        return e.matches(\"[data-editable]\") ? e : e.querySelector(\"[data-editable]\") || e;\n      }\n    }\n  ];\n}\nfunction Dr(n, t) {\n  const e = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Node.create({\n    name: n.type,\n    inline: !0,\n    group: \"inline\",\n    selectable: n.content === \"styled\",\n    atom: n.content === \"none\",\n    content: n.content === \"styled\" ? \"inline*\" : \"\",\n    addAttributes() {\n      return Yt(n.propSchema);\n    },\n    addKeyboardShortcuts() {\n      return un(n);\n    },\n    parseHTML() {\n      return fn(n);\n    },\n    renderHTML({ node: o }) {\n      const r = this.options.editor, i = t.render(\n        Wt(\n          o,\n          r.schema.inlineContentSchema,\n          r.schema.styleSchema\n        )\n        // TODO: fix cast\n      );\n      return pn(\n        i,\n        n.type,\n        o.attrs,\n        n.propSchema\n      );\n    }\n  });\n  return mn(\n    e,\n    n.propSchema\n  );\n}\nfunction gn(n) {\n  return n === \"boolean\" ? {} : {\n    stringValue: {\n      default: void 0,\n      keepOnSplit: !0,\n      parseHTML: (t) => t.getAttribute(\"data-value\"),\n      renderHTML: (t) => t.stringValue !== void 0 ? {\n        \"data-value\": t.stringValue\n      } : {}\n    }\n  };\n}\nfunction bn(n, t, e, o) {\n  return n.dom.setAttribute(\"data-style-type\", t), o === \"string\" && n.dom.setAttribute(\"data-value\", e), n.contentDOM !== void 0 && n.contentDOM.setAttribute(\"data-editable\", \"\"), n;\n}\nfunction ee(n, t) {\n  return {\n    config: n,\n    implementation: t\n  };\n}\nfunction O(n, t) {\n  return ee(\n    {\n      type: n.name,\n      propSchema: t\n    },\n    {\n      mark: n\n    }\n  );\n}\nfunction ne(n) {\n  return Object.fromEntries(\n    Object.entries(n).map(([t, e]) => [t, e.config])\n  );\n}\nfunction yn(n) {\n  return [\n    {\n      tag: `[data-style-type=\"${n.type}\"]`,\n      contentElement: (t) => {\n        const e = t;\n        return e.matches(\"[data-editable]\") ? e : e.querySelector(\"[data-editable]\") || e;\n      }\n    }\n  ];\n}\nfunction Or(n, t) {\n  const e = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Mark.create({\n    name: n.type,\n    addAttributes() {\n      return gn(n.propSchema);\n    },\n    parseHTML() {\n      return yn(n);\n    },\n    renderHTML({ mark: o }) {\n      let r;\n      if (n.propSchema === \"boolean\")\n        r = t.render();\n      else if (n.propSchema === \"string\")\n        r = t.render(o.attrs.stringValue);\n      else\n        throw new N(n.propSchema);\n      return bn(\n        r,\n        n.type,\n        o.attrs.stringValue,\n        n.propSchema\n      );\n    }\n  });\n  return ee(n, {\n    mark: e\n  });\n}\nconst kn = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Mark.create({\n  name: \"backgroundColor\",\n  addAttributes() {\n    return {\n      stringValue: {\n        default: void 0,\n        parseHTML: (n) => n.getAttribute(\"data-background-color\"),\n        renderHTML: (n) => ({\n          \"data-background-color\": n.stringValue\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (n) => typeof n == \"string\" ? !1 : n.hasAttribute(\"data-background-color\") ? {\n          stringValue: n.getAttribute(\"data-background-color\")\n        } : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    return [\"span\", n, 0];\n  }\n}), wn = O(\n  kn,\n  \"string\"\n), vn = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Mark.create({\n  name: \"textColor\",\n  addAttributes() {\n    return {\n      stringValue: {\n        default: void 0,\n        parseHTML: (n) => n.getAttribute(\"data-text-color\"),\n        renderHTML: (n) => ({\n          \"data-text-color\": n.stringValue\n        })\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"span\",\n        getAttrs: (n) => typeof n == \"string\" ? !1 : n.hasAttribute(\"data-text-color\") ? { stringValue: n.getAttribute(\"data-text-color\") } : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    return [\"span\", n, 0];\n  }\n}), En = O(vn, \"string\"), Sn = {\n  ...w,\n  level: { default: 1, values: [1, 2, 3] }\n}, Cn = W({\n  name: \"heading\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        // instead of \"level\" attributes, use \"data-level\"\n        parseHTML: (n) => {\n          const t = n.getAttribute(\"data-level\"), e = parseInt(t);\n          if (isFinite(e))\n            return e;\n        },\n        renderHTML: (n) => ({\n          \"data-level\": n.level.toString()\n        })\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      ...[1, 2, 3].map((n) => new _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.InputRule({\n        find: new RegExp(`^(#{${n}})\\\\s$`),\n        handler: ({ state: t, chain: e, range: o }) => {\n          e().BNUpdateBlock(t.selection.from, {\n            type: \"heading\",\n            props: {\n              level: n\n            }\n          }).deleteRange({ from: o.from, to: o.to });\n        }\n      }))\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-1\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"heading\",\n        props: {\n          level: 1\n        }\n      }),\n      \"Mod-Alt-2\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"heading\",\n        props: {\n          level: 2\n        }\n      }),\n      \"Mod-Alt-3\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"heading\",\n        props: {\n          level: 3\n        }\n      })\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\",\n        getAttrs: (n) => typeof n == \"string\" ? !1 : {\n          level: n.getAttribute(\"data-level\")\n        }\n      },\n      {\n        tag: \"h1\",\n        attrs: { level: 1 },\n        node: \"heading\"\n      },\n      {\n        tag: \"h2\",\n        attrs: { level: 2 },\n        node: \"heading\"\n      },\n      {\n        tag: \"h3\",\n        attrs: { level: 3 },\n        node: \"heading\"\n      }\n    ];\n  },\n  renderHTML({ node: n, HTMLAttributes: t }) {\n    var e, o;\n    return Z(\n      this.name,\n      `h${n.attrs.level}`,\n      {\n        ...((e = this.options.domAttributes) == null ? void 0 : e.blockContent) || {},\n        ...t\n      },\n      ((o = this.options.domAttributes) == null ? void 0 : o.inlineContent) || {}\n    );\n  }\n}), Tn = tt(\n  Cn,\n  Sn\n), xn = {\n  textAlignment: w.textAlignment,\n  backgroundColor: w.backgroundColor,\n  // Image url.\n  url: {\n    default: \"\"\n  },\n  // Image caption.\n  caption: {\n    default: \"\"\n  },\n  // Image width in px.\n  width: {\n    default: 512\n  }\n}, At = (n) => {\n  switch (n) {\n    case \"left\":\n      return \"flex-start\";\n    case \"center\":\n      return \"center\";\n    case \"right\":\n      return \"flex-end\";\n    default:\n      return \"flex-start\";\n  }\n}, Ht = 64, Mn = (n, t) => {\n  const e = document.createElement(\"div\");\n  e.className = \"bn-image-block-content-wrapper\", e.style.alignItems = At(\n    n.props.textAlignment\n  );\n  const o = document.createElement(\"div\");\n  o.className = \"bn-add-image-button\";\n  const r = document.createElement(\"div\");\n  r.className = \"bn-add-image-button-icon\";\n  const i = document.createElement(\"p\");\n  i.className = \"bn-add-image-button-text\", i.innerText = \"Add Image\";\n  const s = document.createElement(\"div\");\n  s.className = \"bn-image-and-caption-wrapper\";\n  const a = document.createElement(\"div\");\n  a.className = \"bn-image-wrapper\";\n  const l = document.createElement(\"img\");\n  l.className = \"bn-image\", l.src = n.props.url, l.alt = \"placeholder\", l.contentEditable = \"false\", l.draggable = !1, l.style.width = `${Math.min(\n    n.props.width,\n    t.domElement.firstElementChild.clientWidth\n  )}px`;\n  const c = document.createElement(\"div\");\n  c.className = \"bn-image-resize-handle\", c.style.left = \"4px\";\n  const p = document.createElement(\"div\");\n  p.className = \"bn-image-resize-handle\", p.style.right = \"4px\";\n  const u = document.createElement(\"p\");\n  u.className = \"bn-image-caption\", u.innerText = n.props.caption, u.style.padding = n.props.caption ? \"4px\" : \"\";\n  const m = () => {\n    var ct;\n    const g = ((ct = t.getSelection()) == null ? void 0 : ct.blocks) || [];\n    [t.getTextCursorPosition().block, ...g].find(\n      (et) => et.id === n.id\n    ) !== void 0 ? (o.style.outline = \"4px solid rgb(100, 160, 255)\", s.style.outline = \"4px solid rgb(100, 160, 255)\") : (o.style.outline = \"\", s.style.outline = \"\");\n  };\n  t.onEditorContentChange(m), t.onEditorSelectionChange(m);\n  let h;\n  const f = (g) => {\n    if (!h) {\n      !t.isEditable && a.contains(c) && a.contains(p) && (a.removeChild(c), a.removeChild(p));\n      return;\n    }\n    let I;\n    At(n.props.textAlignment) === \"center\" ? h.handleUsed === \"left\" ? I = h.initialWidth + (h.initialClientX - g.clientX) * 2 : I = h.initialWidth + (g.clientX - h.initialClientX) * 2 : h.handleUsed === \"left\" ? I = h.initialWidth + h.initialClientX - g.clientX : I = h.initialWidth + g.clientX - h.initialClientX, I < Ht ? l.style.width = `${Ht}px` : I > t.domElement.firstElementChild.clientWidth ? l.style.width = `${t.domElement.firstElementChild.clientWidth}px` : l.style.width = `${I}px`;\n  }, y = (g) => {\n    (!g.target || !a.contains(g.target) || !t.isEditable) && a.contains(c) && a.contains(p) && (a.removeChild(c), a.removeChild(p)), h && (h = void 0, t.updateBlock(n, {\n      type: \"image\",\n      props: {\n        // Removes \"px\" from the end of the width string and converts to float.\n        width: parseFloat(l.style.width.slice(0, -2))\n      }\n    }));\n  }, S = (g) => {\n    g.preventDefault();\n  }, B = () => {\n    t._tiptapEditor.view.dispatch(\n      t._tiptapEditor.state.tr.setMeta(t.imageToolbar.plugin, {\n        block: n\n      })\n    );\n  }, E = () => {\n    t.isEditable && (a.appendChild(c), a.appendChild(p));\n  }, D = (g) => {\n    g.relatedTarget === c || g.relatedTarget === p || h || t.isEditable && a.contains(c) && a.contains(p) && (a.removeChild(c), a.removeChild(p));\n  }, z = (g) => {\n    g.preventDefault(), a.appendChild(c), a.appendChild(p), h = {\n      handleUsed: \"left\",\n      initialWidth: n.props.width,\n      initialClientX: g.clientX\n    };\n  }, K = (g) => {\n    g.preventDefault(), a.appendChild(c), a.appendChild(p), h = {\n      handleUsed: \"right\",\n      initialWidth: n.props.width,\n      initialClientX: g.clientX\n    };\n  };\n  return o.appendChild(r), o.appendChild(i), s.appendChild(a), a.appendChild(l), s.appendChild(u), n.props.url === \"\" ? e.appendChild(o) : e.appendChild(s), window.addEventListener(\"mousemove\", f), window.addEventListener(\"mouseup\", y), o.addEventListener(\"mousedown\", S), o.addEventListener(\"click\", B), l.addEventListener(\"mouseenter\", E), l.addEventListener(\"mouseleave\", D), c.addEventListener(\n    \"mousedown\",\n    z\n  ), p.addEventListener(\n    \"mousedown\",\n    K\n  ), {\n    dom: e,\n    destroy: () => {\n      window.removeEventListener(\"mousemove\", f), window.removeEventListener(\"mouseup\", y), o.removeEventListener(\n        \"mousedown\",\n        S\n      ), o.removeEventListener(\"click\", B), c.removeEventListener(\n        \"mousedown\",\n        z\n      ), p.removeEventListener(\n        \"mousedown\",\n        K\n      );\n    }\n  };\n}, Bn = dn(\n  {\n    type: \"image\",\n    propSchema: xn,\n    content: \"none\"\n  },\n  {\n    render: Mn,\n    toExternalHTML: (n) => {\n      if (n.props.url === \"\") {\n        const o = document.createElement(\"p\");\n        return o.innerHTML = \"Add Image\", {\n          dom: o\n        };\n      }\n      const t = document.createElement(\"figure\"), e = document.createElement(\"img\");\n      if (e.src = n.props.url, t.appendChild(e), n.props.caption !== \"\") {\n        const o = document.createElement(\"figcaption\");\n        o.innerHTML = n.props.caption, t.appendChild(o);\n      }\n      return {\n        dom: t\n      };\n    },\n    parse: (n) => {\n      if (n.tagName === \"FIGURE\") {\n        const t = n.querySelector(\"img\"), e = n.querySelector(\"figcaption\");\n        return {\n          url: (t == null ? void 0 : t.getAttribute(\"src\")) || \"\",\n          caption: (e == null ? void 0 : e.textContent) || (t == null ? void 0 : t.getAttribute(\"alt\")) || void 0\n        };\n      } else if (n.tagName === \"IMG\")\n        return {\n          url: n.getAttribute(\"src\") || \"\",\n          caption: n.getAttribute(\"alt\") || void 0\n        };\n    }\n  }\n), vt = (n) => {\n  const { node: t, contentType: e } = b(\n    n.state.doc,\n    n.state.selection.from\n  ), o = n.state.selection.anchor === n.state.selection.head;\n  return !e.name.endsWith(\"ListItem\") || !o ? !1 : n.commands.first(({ state: r, chain: i, commands: s }) => [\n    () => (\n      // Changes list item block to a text block if the content is empty.\n      s.command(() => t.textContent.length === 0 ? s.BNUpdateBlock(r.selection.from, {\n        type: \"paragraph\",\n        props: {}\n      }) : !1)\n    ),\n    () => (\n      // Splits the current block, moving content inside that's after the cursor to a new block of the same type\n      // below.\n      s.command(() => t.textContent.length > 0 ? (i().deleteSelection().BNSplitBlock(r.selection.from, !0).run(), !0) : !1)\n    )\n  ]);\n}, In = {\n  ...w\n}, Ln = W({\n  name: \"bulletListItem\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addInputRules() {\n    return [\n      // Creates an unordered list when starting with \"-\", \"+\", or \"*\".\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.InputRule({\n        find: new RegExp(\"^[-+*]\\\\s$\"),\n        handler: ({ state: n, chain: t, range: e }) => {\n          t().BNUpdateBlock(n.selection.from, {\n            type: \"bulletListItem\",\n            props: {}\n          }).deleteRange({ from: e.from, to: e.to });\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => vt(this.editor),\n      \"Mod-Shift-8\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"bulletListItem\",\n        props: {}\n      })\n    };\n  },\n  parseHTML() {\n    return [\n      // Case for regular HTML list structure.\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\"\n        // TODO: remove if we can't come up with test case that needs this\n      },\n      {\n        tag: \"li\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = n.parentElement;\n          return t === null ? !1 : t.tagName === \"UL\" || t.tagName === \"DIV\" && t.parentElement.tagName === \"UL\" ? {} : !1;\n        },\n        node: \"bulletListItem\"\n      },\n      // Case for BlockNote list structure.\n      {\n        tag: \"p\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = n.parentElement;\n          return t === null ? !1 : t.getAttribute(\"data-content-type\") === \"bulletListItem\" ? {} : !1;\n        },\n        priority: 300,\n        node: \"bulletListItem\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var t, e;\n    return Z(\n      this.name,\n      // We use a <p> tag, because for <li> tags we'd need a <ul> element to put\n      // them in to be semantically correct, which we can't have due to the\n      // schema.\n      \"p\",\n      {\n        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},\n        ...n\n      },\n      ((e = this.options.domAttributes) == null ? void 0 : e.inlineContent) || {}\n    );\n  }\n}), Nn = tt(\n  Ln,\n  In\n), An = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"numbered-list-indexing\"), Hn = () => new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n  key: An,\n  appendTransaction: (n, t, e) => {\n    const o = e.tr;\n    o.setMeta(\"numberedListIndexing\", !0);\n    let r = !1;\n    return e.doc.descendants((i, s) => {\n      if (i.type.name === \"blockContainer\" && i.firstChild.type.name === \"numberedListItem\") {\n        let a = \"1\";\n        const l = s === 1, c = b(o.doc, s + 1);\n        if (c === void 0)\n          return;\n        if (!l) {\n          const m = b(o.doc, s - 2);\n          if (m === void 0)\n            return;\n          if (!(c.depth !== m.depth)) {\n            const f = m.contentNode;\n            if (m.contentType.name === \"numberedListItem\") {\n              const B = f.attrs.index;\n              a = (parseInt(B) + 1).toString();\n            }\n          }\n        }\n        c.contentNode.attrs.index !== a && (r = !0, o.setNodeMarkup(s + 1, void 0, {\n          index: a\n        }));\n      }\n    }), r ? o : null;\n  }\n}), Pn = {\n  ...w\n}, Dn = W({\n  name: \"numberedListItem\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addAttributes() {\n    return {\n      index: {\n        default: null,\n        parseHTML: (n) => n.getAttribute(\"data-index\"),\n        renderHTML: (n) => ({\n          \"data-index\": n.index\n        })\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      // Creates an ordered list when starting with \"1.\".\n      new _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.InputRule({\n        find: new RegExp(\"^1\\\\.\\\\s$\"),\n        handler: ({ state: n, chain: t, range: e }) => {\n          t().BNUpdateBlock(n.selection.from, {\n            type: \"numberedListItem\",\n            props: {}\n          }).deleteRange({ from: e.from, to: e.to });\n        }\n      })\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => vt(this.editor),\n      \"Mod-Shift-7\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"numberedListItem\",\n        props: {}\n      })\n    };\n  },\n  addProseMirrorPlugins() {\n    return [Hn()];\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"div[data-content-type=\" + this.name + \"]\"\n        // TODO: remove if we can't come up with test case that needs this\n      },\n      // Case for regular HTML list structure.\n      // (e.g.: when pasting from other apps)\n      {\n        tag: \"li\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = n.parentElement;\n          return t === null ? !1 : t.tagName === \"OL\" || t.tagName === \"DIV\" && t.parentElement.tagName === \"OL\" ? {} : !1;\n        },\n        node: \"numberedListItem\"\n      },\n      // Case for BlockNote list structure.\n      // (e.g.: when pasting from blocknote)\n      {\n        tag: \"p\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = n.parentElement;\n          return t === null ? !1 : t.getAttribute(\"data-content-type\") === \"numberedListItem\" ? {} : !1;\n        },\n        priority: 300,\n        node: \"numberedListItem\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var t, e;\n    return Z(\n      this.name,\n      // We use a <p> tag, because for <li> tags we'd need an <ol> element to\n      // put them in to be semantically correct, which we can't have due to the\n      // schema.\n      \"p\",\n      {\n        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},\n        ...n\n      },\n      ((e = this.options.domAttributes) == null ? void 0 : e.inlineContent) || {}\n    );\n  }\n}), On = tt(\n  Dn,\n  Pn\n), _n = {\n  ...w\n}, Un = W({\n  name: \"paragraph\",\n  content: \"inline*\",\n  group: \"blockContent\",\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => vt(this.editor),\n      \"Mod-Alt-0\": () => this.editor.commands.BNUpdateBlock(this.editor.state.selection.anchor, {\n        type: \"paragraph\",\n        props: {}\n      })\n    };\n  },\n  parseHTML() {\n    return [\n      { tag: \"div[data-content-type=\" + this.name + \"]\" },\n      {\n        tag: \"p\",\n        priority: 200,\n        node: \"paragraph\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var t, e;\n    return Z(\n      this.name,\n      \"p\",\n      {\n        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},\n        ...n\n      },\n      ((e = this.options.domAttributes) == null ? void 0 : e.inlineContent) || {}\n    );\n  }\n}), Rn = tt(\n  Un,\n  _n\n), zn = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"BlockNoteTableExtension\",\n  addProseMirrorPlugins: () => [\n    (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_8__.columnResizing)({\n      cellMinWidth: 100\n    }),\n    (0,prosemirror_tables__WEBPACK_IMPORTED_MODULE_8__.tableEditing)()\n  ],\n  addKeyboardShortcuts() {\n    return {\n      // Makes enter create a new line within the cell.\n      Enter: () => this.editor.state.selection.empty && this.editor.state.selection.$head.parent.type.name === \"tableParagraph\" ? (this.editor.commands.setHardBreak(), !0) : !1,\n      // Ensures that backspace won't delete the table if the text cursor is at\n      // the start of a cell and the selection is empty.\n      Backspace: () => {\n        const n = this.editor.state.selection, t = n.empty, e = n.$head.parentOffset === 0, o = n.$head.node().type.name === \"tableParagraph\";\n        return t && e && o;\n      }\n    };\n  },\n  extendNodeSchema(n) {\n    const t = {\n      name: n.name,\n      options: n.options,\n      storage: n.storage\n    };\n    return {\n      tableRole: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.callOrReturn)(\n        (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.getExtensionField)(n, \"tableRole\", t)\n      )\n    };\n  }\n}), Vn = {\n  ...w\n}, Fn = W({\n  name: \"table\",\n  content: \"tableRow+\",\n  group: \"blockContent\",\n  tableRole: \"table\",\n  isolating: !0,\n  parseHTML() {\n    return [{ tag: \"table\" }];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var t, e;\n    return Z(\n      this.name,\n      \"table\",\n      {\n        ...((t = this.options.domAttributes) == null ? void 0 : t.blockContent) || {},\n        ...n\n      },\n      ((e = this.options.domAttributes) == null ? void 0 : e.inlineContent) || {}\n    );\n  }\n}), $n = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Node.create({\n  name: \"tableParagraph\",\n  group: \"tableContent\",\n  content: \"inline*\",\n  parseHTML() {\n    return [{ tag: \"p\" }];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    return [\n      \"p\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.mergeAttributes)(this.options.HTMLAttributes, n),\n      0\n    ];\n  }\n}), Gn = tt(\n  Fn,\n  Vn,\n  [\n    zn,\n    $n,\n    _tiptap_extension_table_header__WEBPACK_IMPORTED_MODULE_6__.TableHeader.extend({\n      content: \"tableContent\"\n    }),\n    _tiptap_extension_table_cell__WEBPACK_IMPORTED_MODULE_5__.TableCell.extend({\n      content: \"tableContent\"\n    }),\n    _tiptap_extension_table_row__WEBPACK_IMPORTED_MODULE_7__.TableRow\n  ]\n), oe = {\n  paragraph: Rn,\n  heading: Tn,\n  bulletListItem: Nn,\n  numberedListItem: On,\n  image: Bn,\n  table: Gn\n}, jn = Zt(oe), re = {\n  bold: O(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_0__[\"default\"], \"boolean\"),\n  italic: O(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_2__[\"default\"], \"boolean\"),\n  underline: O(_tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_4__[\"default\"], \"boolean\"),\n  strike: O(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_3__[\"default\"], \"boolean\"),\n  code: O(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_1__[\"default\"], \"boolean\"),\n  textColor: En,\n  backgroundColor: wn\n}, _r = ne(re), ie = {\n  text: { config: \"text\", implementation: {} },\n  link: { config: \"link\", implementation: {} }\n}, Ur = te(\n  ie\n);\nfunction L(n, t) {\n  return n in t.schema.blockSchema && t.schema.blockSchema[n] === jn[n];\n}\nfunction Rr(n, t, e) {\n  return t.type === n && t.type in e.schema.blockSchema && L(t.type, e);\n}\nfunction Wn(n, t, e) {\n  return t in e.schema.blockSchema && n in e.schema.blockSchema[t].propSchema && e.schema.blockSchema[t].propSchema[n] === w[n];\n}\nfunction zr(n, t, e) {\n  return Wn(n, t.type, e);\n}\nfunction Et(n, t) {\n  let e, o;\n  if (t.firstChild.descendants((r, i) => e ? !1 : r.type.name !== \"blockContainer\" || r.attrs.id !== n ? !0 : (e = r, o = i + 1, !1)), e === void 0 || o === void 0)\n    throw Error(\"Could not find block in the editor with matching ID.\");\n  return {\n    node: e,\n    posBeforeNode: o\n  };\n}\nfunction qn(n, t, e = \"before\", o) {\n  const r = o._tiptapEditor, i = typeof t == \"string\" ? t : t.id, s = [];\n  for (const p of n)\n    s.push(\n      P(p, r.schema, o.schema.styleSchema)\n    );\n  const { node: a, posBeforeNode: l } = Et(i, r.state.doc);\n  if (e === \"before\" && r.view.dispatch(\n    r.state.tr.insert(l, s)\n  ), e === \"after\" && r.view.dispatch(\n    r.state.tr.insert(l + a.nodeSize, s)\n  ), e === \"nested\" && a.childCount < 2) {\n    const p = r.state.schema.nodes.blockGroup.create(\n      {},\n      s\n    );\n    r.view.dispatch(\n      r.state.tr.insert(\n        l + a.firstChild.nodeSize + 1,\n        p\n      )\n    );\n  }\n  const c = [];\n  for (const p of s)\n    c.push(\n      k(\n        p,\n        o.schema.blockSchema,\n        o.schema.inlineContentSchema,\n        o.schema.styleSchema,\n        o.blockCache\n      )\n    );\n  return c;\n}\nfunction Kn(n, t, e) {\n  const o = e._tiptapEditor, r = typeof n == \"string\" ? n : n.id, { posBeforeNode: i } = Et(r, o.state.doc);\n  o.commands.BNUpdateBlock(i + 1, t);\n  const s = o.state.doc.resolve(i + 1).node();\n  return k(\n    s,\n    e.schema.blockSchema,\n    e.schema.inlineContentSchema,\n    e.schema.styleSchema,\n    e.blockCache\n  );\n}\nfunction se(n, t, e) {\n  const o = t._tiptapEditor, r = o.state.tr, i = new Set(\n    n.map(\n      (l) => typeof l == \"string\" ? l : l.id\n    )\n  ), s = [];\n  let a = 0;\n  if (o.state.doc.descendants((l, c) => {\n    if (i.size === 0)\n      return !1;\n    if (l.type.name !== \"blockContainer\" || !i.has(l.attrs.id))\n      return !0;\n    s.push(\n      k(\n        l,\n        t.schema.blockSchema,\n        t.schema.inlineContentSchema,\n        t.schema.styleSchema,\n        t.blockCache\n      )\n    ), i.delete(l.attrs.id), a = (e == null ? void 0 : e(l, c, r, a)) || a;\n    const p = r.doc.nodeSize;\n    r.delete(c - a - 1, c - a + l.nodeSize + 1);\n    const u = r.doc.nodeSize;\n    return a += p - u, !1;\n  }), i.size > 0) {\n    const l = [...i].join(`\n`);\n    throw Error(\n      \"Blocks with the following IDs could not be found in the editor: \" + l\n    );\n  }\n  return o.view.dispatch(r), s;\n}\nfunction Jn(n, t) {\n  return se(n, t);\n}\nfunction Xn(n, t, e) {\n  const o = e._tiptapEditor, r = [];\n  for (const l of t)\n    r.push(\n      P(l, o.schema, e.schema.styleSchema)\n    );\n  const i = typeof n[0] == \"string\" ? n[0] : n[0].id, s = se(\n    n,\n    e,\n    (l, c, p, u) => {\n      if (l.attrs.id === i) {\n        const m = p.doc.nodeSize;\n        p.insert(c, r);\n        const h = p.doc.nodeSize;\n        return u + m - h;\n      }\n      return u;\n    }\n  ), a = [];\n  for (const l of r)\n    a.push(\n      k(\n        l,\n        e.schema.blockSchema,\n        e.schema.inlineContentSchema,\n        e.schema.styleSchema,\n        e.blockCache\n      )\n    );\n  return { insertedBlocks: a, removedBlocks: s };\n}\nfunction Yn(n, t, e, o = { updateSelection: !0 }) {\n  const r = e._tiptapEditor, i = r.state.tr;\n  let { from: s, to: a } = typeof n == \"number\" ? { from: n, to: n } : { from: n.from, to: n.to }, l = !0, c = !0, p = \"\";\n  if (t.forEach((u) => {\n    u.check(), l && u.isText && u.marks.length === 0 ? p += u.text : l = !1, c = c ? u.isBlock : !1;\n  }), s === a && c) {\n    const { parent: u } = i.doc.resolve(s);\n    u.isTextblock && !u.type.spec.code && !u.childCount && (s -= 1, a += 1);\n  }\n  return l ? i.insertText(p, s, a) : i.replaceWith(s, a, t), o.updateSelection && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.selectionToInsertionEnd)(i, i.steps.length - 1, -1), r.view.dispatch(i), !0;\n}\nfunction Qn() {\n  const n = (t) => {\n    let e = t.children.length;\n    for (let o = 0; o < e; o++) {\n      const r = t.children[o];\n      if (r.type === \"element\" && (n(r), r.tagName === \"u\"))\n        if (r.children.length > 0) {\n          t.children.splice(o, 1, ...r.children);\n          const i = r.children.length - 1;\n          e += i, o += i;\n        } else\n          t.children.splice(o, 1), e--, o--;\n    }\n  };\n  return n;\n}\nfunction St(n) {\n  return (0,unified__WEBPACK_IMPORTED_MODULE_22__.unified)().use(rehype_parse__WEBPACK_IMPORTED_MODULE_23__[\"default\"], { fragment: !0 }).use(Qn).use(rehype_remark__WEBPACK_IMPORTED_MODULE_25__[\"default\"]).use(remark_gfm__WEBPACK_IMPORTED_MODULE_26__[\"default\"]).use(remark_stringify__WEBPACK_IMPORTED_MODULE_27__[\"default\"]).processSync(n).value;\n}\nfunction Zn(n, t, e) {\n  const r = at(t, e).exportBlocks(n);\n  return St(r);\n}\nfunction to(n) {\n  return Array.prototype.indexOf.call(n.parentElement.childNodes, n);\n}\nfunction eo(n) {\n  return n.nodeType === 3 && !/\\S/.test(n.nodeValue || \"\");\n}\nfunction no(n) {\n  n.querySelectorAll(\"li > ul, li > ol\").forEach((t) => {\n    const e = to(t), o = t.parentElement, r = Array.from(o.childNodes).slice(\n      e + 1\n    );\n    t.remove(), r.forEach((i) => {\n      i.remove();\n    }), o.insertAdjacentElement(\"afterend\", t), r.reverse().forEach((i) => {\n      if (eo(i))\n        return;\n      const s = document.createElement(\"li\");\n      s.append(i), t.insertAdjacentElement(\"afterend\", s);\n    }), o.childNodes.length === 0 && o.remove();\n  });\n}\nfunction oo(n) {\n  n.querySelectorAll(\"li + ul, li + ol\").forEach((t) => {\n    var i, s;\n    const e = t.previousElementSibling, o = document.createElement(\"div\");\n    e.insertAdjacentElement(\"afterend\", o), o.append(e);\n    const r = document.createElement(\"div\");\n    for (r.setAttribute(\"data-node-type\", \"blockGroup\"), o.append(r); ((i = o.nextElementSibling) == null ? void 0 : i.nodeName) === \"UL\" || ((s = o.nextElementSibling) == null ? void 0 : s.nodeName) === \"OL\"; )\n      r.append(o.nextElementSibling);\n  });\n}\nlet Pt = null;\nfunction ro() {\n  return Pt || (Pt = document.implementation.createHTMLDocument(\"title\"));\n}\nfunction ae(n) {\n  if (typeof n == \"string\") {\n    const t = ro().createElement(\"div\");\n    t.innerHTML = n, n = t;\n  }\n  return no(n), oo(n), n;\n}\nasync function le(n, t, e, o, r) {\n  const i = ae(n), a = prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.DOMParser.fromSchema(r).parse(i, {\n    topNode: r.nodes.blockGroup.create()\n  }), l = [];\n  for (let c = 0; c < a.childCount; c++)\n    l.push(\n      k(a.child(c), t, e, o)\n    );\n  return l;\n}\nfunction io(n, t) {\n  const e = t.value ? t.value + `\n` : \"\", o = {};\n  t.lang && (o[\"data-language\"] = t.lang);\n  let r = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: o,\n    children: [{ type: \"text\", value: e }]\n  };\n  return t.meta && (r.data = { meta: t.meta }), n.patch(t, r), r = n.applyData(t, r), r = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {},\n    children: [r]\n  }, n.patch(t, r), r;\n}\nfunction so(n, t, e, o, r) {\n  const i = (0,unified__WEBPACK_IMPORTED_MODULE_22__.unified)().use(remark_parse__WEBPACK_IMPORTED_MODULE_28__[\"default\"]).use(remark_gfm__WEBPACK_IMPORTED_MODULE_26__[\"default\"]).use(remark_rehype__WEBPACK_IMPORTED_MODULE_29__[\"default\"], {\n    handlers: {\n      ...remark_rehype__WEBPACK_IMPORTED_MODULE_30__.handlers,\n      code: io\n    }\n  }).use(rehype_stringify__WEBPACK_IMPORTED_MODULE_24__[\"default\"]).processSync(n);\n  return le(\n    i.value,\n    t,\n    e,\n    o,\n    r\n  );\n}\nclass q {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    d(this, \"callbacks\", {});\n  }\n  on(t, e) {\n    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(e), () => this.off(t, e);\n  }\n  emit(t, ...e) {\n    const o = this.callbacks[t];\n    o && o.forEach((r) => r.apply(this, e));\n  }\n  off(t, e) {\n    const o = this.callbacks[t];\n    o && (e ? this.callbacks[t] = o.filter((r) => r !== e) : delete this.callbacks[t]);\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nclass ao {\n  constructor(t, e, o) {\n    d(this, \"state\");\n    d(this, \"emitUpdate\");\n    d(this, \"preventHide\", !1);\n    d(this, \"preventShow\", !1);\n    d(this, \"prevWasEditable\", null);\n    d(this, \"shouldShow\", ({ state: t }) => !t.selection.empty);\n    d(this, \"viewMousedownHandler\", () => {\n      this.preventShow = !0;\n    });\n    d(this, \"viewMouseupHandler\", () => {\n      this.preventShow = !1, setTimeout(() => this.update(this.pmView));\n    });\n    // For dragging the whole editor.\n    d(this, \"dragHandler\", () => {\n      var t;\n      (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate());\n    });\n    d(this, \"focusHandler\", () => {\n      setTimeout(() => this.update(this.pmView));\n    });\n    d(this, \"blurHandler\", (t) => {\n      var o;\n      if (this.preventHide) {\n        this.preventHide = !1;\n        return;\n      }\n      const e = this.pmView.dom.parentElement;\n      // An element is clicked.\n      t && t.relatedTarget && // Element is inside the editor.\n      (e === t.relatedTarget || e.contains(t.relatedTarget)) || (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    d(this, \"scrollHandler\", () => {\n      var t;\n      (t = this.state) != null && t.show && (this.state.referencePos = this.getSelectionBoundingBox(), this.emitUpdate());\n    });\n    this.editor = t, this.pmView = e, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\n          \"Attempting to update uninitialized formatting toolbar\"\n        );\n      o(this.state);\n    }, e.dom.addEventListener(\"mousedown\", this.viewMousedownHandler), e.dom.addEventListener(\"mouseup\", this.viewMouseupHandler), e.dom.addEventListener(\"dragstart\", this.dragHandler), e.dom.addEventListener(\"dragover\", this.dragHandler), e.dom.addEventListener(\"focus\", this.focusHandler), e.dom.addEventListener(\"blur\", this.blurHandler), document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n  update(t, e) {\n    var m, h;\n    const { state: o, composing: r } = t, { doc: i, selection: s } = o, a = e && e.doc.eq(i) && e.selection.eq(s);\n    if ((this.prevWasEditable === null || this.prevWasEditable === this.editor.isEditable) && (r || a))\n      return;\n    this.prevWasEditable = this.editor.isEditable;\n    const { ranges: l } = s, c = Math.min(...l.map((f) => f.$from.pos)), p = Math.max(...l.map((f) => f.$to.pos)), u = (m = this.shouldShow) == null ? void 0 : m.call(this, {\n      view: t,\n      state: o,\n      from: c,\n      to: p\n    });\n    if (this.editor.isEditable && !this.preventShow && (u || this.preventHide)) {\n      this.state = {\n        show: !0,\n        referencePos: this.getSelectionBoundingBox()\n      }, this.emitUpdate();\n      return;\n    }\n    if ((h = this.state) != null && h.show && !this.preventHide && (!u || this.preventShow || !this.editor.isEditable)) {\n      this.state.show = !1, this.emitUpdate();\n      return;\n    }\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.viewMousedownHandler), this.pmView.dom.removeEventListener(\"mouseup\", this.viewMouseupHandler), this.pmView.dom.removeEventListener(\"dragstart\", this.dragHandler), this.pmView.dom.removeEventListener(\"dragover\", this.dragHandler), this.pmView.dom.removeEventListener(\"focus\", this.focusHandler), this.pmView.dom.removeEventListener(\"blur\", this.blurHandler), document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n  getSelectionBoundingBox() {\n    const { state: t } = this.pmView, { selection: e } = t, { ranges: o } = e, r = Math.min(...o.map((s) => s.$from.pos)), i = Math.max(...o.map((s) => s.$to.pos));\n    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.isNodeSelection)(e)) {\n      const s = this.pmView.nodeDOM(r);\n      if (s)\n        return s.getBoundingClientRect();\n    }\n    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.posToDOMRect)(this.pmView, r, i);\n  }\n}\nconst lo = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\n  \"FormattingToolbarPlugin\"\n);\nclass co extends q {\n  constructor(e) {\n    super();\n    d(this, \"view\");\n    d(this, \"plugin\");\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n      key: lo,\n      view: (o) => (this.view = new ao(e, o, (r) => {\n        this.emit(\"update\", r);\n      }), this.view)\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nclass po {\n  constructor(t, e, o) {\n    d(this, \"state\");\n    d(this, \"emitUpdate\");\n    d(this, \"menuUpdateTimer\");\n    d(this, \"startMenuUpdateTimer\");\n    d(this, \"stopMenuUpdateTimer\");\n    d(this, \"mouseHoveredHyperlinkMark\");\n    d(this, \"mouseHoveredHyperlinkMarkRange\");\n    d(this, \"keyboardHoveredHyperlinkMark\");\n    d(this, \"keyboardHoveredHyperlinkMarkRange\");\n    d(this, \"hyperlinkMark\");\n    d(this, \"hyperlinkMarkRange\");\n    d(this, \"mouseOverHandler\", (t) => {\n      if (this.mouseHoveredHyperlinkMark = void 0, this.mouseHoveredHyperlinkMarkRange = void 0, this.stopMenuUpdateTimer(), t.target instanceof HTMLAnchorElement && t.target.nodeName === \"A\") {\n        const e = t.target, o = this.pmView.posAtDOM(e, 0) + 1, r = this.pmView.state.doc.resolve(\n          o\n        ), i = r.marks();\n        for (const s of i)\n          if (s.type.name === this.pmView.state.schema.mark(\"link\").type.name) {\n            this.mouseHoveredHyperlinkMark = s, this.mouseHoveredHyperlinkMarkRange = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.getMarkRange)(\n              r,\n              s.type,\n              s.attrs\n            ) || void 0;\n            break;\n          }\n      }\n      return this.startMenuUpdateTimer(), !1;\n    });\n    d(this, \"clickHandler\", (t) => {\n      var o;\n      const e = this.pmView.dom.parentElement;\n      // Toolbar is open.\n      this.hyperlinkMark && // An element is clicked.\n      t && t.target && // The clicked element is not the editor.\n      !(e === t.target || e.contains(t.target)) && (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    d(this, \"scrollHandler\", () => {\n      var t;\n      this.hyperlinkMark !== void 0 && (t = this.state) != null && t.show && (this.state.referencePos = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.posToDOMRect)(\n        this.pmView,\n        this.hyperlinkMarkRange.from,\n        this.hyperlinkMarkRange.to\n      ), this.emitUpdate());\n    });\n    this.editor = t, this.pmView = e, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized hyperlink toolbar\");\n      o(this.state);\n    }, this.startMenuUpdateTimer = () => {\n      this.menuUpdateTimer = setTimeout(() => {\n        this.update();\n      }, 250);\n    }, this.stopMenuUpdateTimer = () => (this.menuUpdateTimer && (clearTimeout(this.menuUpdateTimer), this.menuUpdateTimer = void 0), !1), this.pmView.dom.addEventListener(\"mouseover\", this.mouseOverHandler), document.addEventListener(\"click\", this.clickHandler, !0), document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n  editHyperlink(t, e) {\n    var r;\n    const o = this.pmView.state.tr.insertText(\n      e,\n      this.hyperlinkMarkRange.from,\n      this.hyperlinkMarkRange.to\n    );\n    o.addMark(\n      this.hyperlinkMarkRange.from,\n      this.hyperlinkMarkRange.from + e.length,\n      this.pmView.state.schema.mark(\"link\", { href: t })\n    ), this.pmView.dispatch(o), this.pmView.focus(), (r = this.state) != null && r.show && (this.state.show = !1, this.emitUpdate());\n  }\n  deleteHyperlink() {\n    var t;\n    this.pmView.dispatch(\n      this.pmView.state.tr.removeMark(\n        this.hyperlinkMarkRange.from,\n        this.hyperlinkMarkRange.to,\n        this.hyperlinkMark.type\n      ).setMeta(\"preventAutolink\", !0)\n    ), this.pmView.focus(), (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate());\n  }\n  update() {\n    var e;\n    if (!this.pmView.hasFocus())\n      return;\n    const t = this.hyperlinkMark;\n    if (this.hyperlinkMark = void 0, this.hyperlinkMarkRange = void 0, this.keyboardHoveredHyperlinkMark = void 0, this.keyboardHoveredHyperlinkMarkRange = void 0, this.pmView.state.selection.empty) {\n      const o = this.pmView.state.selection.$from.marks();\n      for (const r of o)\n        if (r.type.name === this.pmView.state.schema.mark(\"link\").type.name) {\n          this.keyboardHoveredHyperlinkMark = r, this.keyboardHoveredHyperlinkMarkRange = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.getMarkRange)(\n            this.pmView.state.selection.$from,\n            r.type,\n            r.attrs\n          ) || void 0;\n          break;\n        }\n    }\n    if (this.mouseHoveredHyperlinkMark && (this.hyperlinkMark = this.mouseHoveredHyperlinkMark, this.hyperlinkMarkRange = this.mouseHoveredHyperlinkMarkRange), this.keyboardHoveredHyperlinkMark && (this.hyperlinkMark = this.keyboardHoveredHyperlinkMark, this.hyperlinkMarkRange = this.keyboardHoveredHyperlinkMarkRange), this.hyperlinkMark && this.editor.isEditable) {\n      this.state = {\n        show: !0,\n        referencePos: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.posToDOMRect)(\n          this.pmView,\n          this.hyperlinkMarkRange.from,\n          this.hyperlinkMarkRange.to\n        ),\n        url: this.hyperlinkMark.attrs.href,\n        text: this.pmView.state.doc.textBetween(\n          this.hyperlinkMarkRange.from,\n          this.hyperlinkMarkRange.to\n        )\n      }, this.emitUpdate();\n      return;\n    }\n    if ((e = this.state) != null && e.show && t && (!this.hyperlinkMark || !this.editor.isEditable)) {\n      this.state.show = !1, this.emitUpdate();\n      return;\n    }\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mouseover\", this.mouseOverHandler), document.removeEventListener(\"scroll\", this.scrollHandler), document.removeEventListener(\"click\", this.clickHandler, !0);\n  }\n}\nconst uo = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\n  \"HyperlinkToolbarPlugin\"\n);\nclass ho extends q {\n  constructor(e) {\n    super();\n    d(this, \"view\");\n    d(this, \"plugin\");\n    /**\n     * Edit the currently hovered hyperlink.\n     */\n    d(this, \"editHyperlink\", (e, o) => {\n      this.view.editHyperlink(e, o);\n    });\n    /**\n     * Delete the currently hovered hyperlink.\n     */\n    d(this, \"deleteHyperlink\", () => {\n      this.view.deleteHyperlink();\n    });\n    /**\n     * When hovering on/off hyperlinks using the mouse cursor, the hyperlink\n     * toolbar will open & close with a delay.\n     *\n     * This function starts the delay timer, and should be used for when the mouse cursor enters the hyperlink toolbar.\n     */\n    d(this, \"startHideTimer\", () => {\n      this.view.startMenuUpdateTimer();\n    });\n    /**\n     * When hovering on/off hyperlinks using the mouse cursor, the hyperlink\n     * toolbar will open & close with a delay.\n     *\n     * This function stops the delay timer, and should be used for when the mouse cursor exits the hyperlink toolbar.\n     */\n    d(this, \"stopHideTimer\", () => {\n      this.view.stopMenuUpdateTimer();\n    });\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n      key: uo,\n      view: (o) => (this.view = new po(e, o, (r) => {\n        this.emit(\"update\", r);\n      }), this.view)\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nclass mo {\n  constructor(t, e, o) {\n    d(this, \"state\");\n    d(this, \"emitUpdate\");\n    d(this, \"prevWasEditable\", null);\n    d(this, \"mouseDownHandler\", () => {\n      var t;\n      (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate());\n    });\n    // For dragging the whole editor.\n    d(this, \"dragstartHandler\", () => {\n      var t;\n      (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate());\n    });\n    d(this, \"blurHandler\", (t) => {\n      var o;\n      const e = this.pmView.dom.parentElement;\n      // An element is clicked.\n      t && t.relatedTarget && // Element is inside the editor.\n      (e === t.relatedTarget || e.contains(t.relatedTarget)) || (o = this.state) != null && o.show && (this.state.show = !1, this.emitUpdate());\n    });\n    d(this, \"scrollHandler\", () => {\n      var t;\n      if ((t = this.state) != null && t.show) {\n        const e = document.querySelector(\n          `[data-node-type=\"blockContainer\"][data-id=\"${this.state.block.id}\"]`\n        );\n        this.state.referencePos = e.getBoundingClientRect(), this.emitUpdate();\n      }\n    });\n    this.pluginKey = t, this.pmView = e, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized image toolbar\");\n      o(this.state);\n    }, e.dom.addEventListener(\"mousedown\", this.mouseDownHandler), e.dom.addEventListener(\"dragstart\", this.dragstartHandler), e.dom.addEventListener(\"blur\", this.blurHandler), document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n  update(t, e) {\n    var r, i;\n    const o = this.pluginKey.getState(t.state);\n    if (!((r = this.state) != null && r.show) && o.block) {\n      const s = document.querySelector(\n        `[data-node-type=\"blockContainer\"][data-id=\"${o.block.id}\"]`\n      );\n      this.state = {\n        show: !0,\n        referencePos: s.getBoundingClientRect(),\n        block: o.block\n      }, this.emitUpdate();\n      return;\n    }\n    (!t.state.selection.eq(e.selection) || !t.state.doc.eq(e.doc)) && (i = this.state) != null && i.show && (this.state.show = !1, this.emitUpdate());\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.mouseDownHandler), this.pmView.dom.removeEventListener(\"dragstart\", this.dragstartHandler), this.pmView.dom.removeEventListener(\"blur\", this.blurHandler), document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n}\nconst ut = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"ImageToolbarPlugin\");\nclass fo extends q {\n  constructor(e) {\n    super();\n    d(this, \"view\");\n    d(this, \"plugin\");\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n      key: ut,\n      view: (o) => (this.view = new mo(\n        // editor,\n        ut,\n        o,\n        (r) => {\n          this.emit(\"update\", r);\n        }\n      ), this.view),\n      state: {\n        init: () => ({\n          block: void 0\n        }),\n        apply: (o) => {\n          var i;\n          return {\n            block: (i = o.getMeta(ut)) == null ? void 0 : i.block\n          };\n        }\n      }\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nconst go = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.findParentNode)((n) => n.type.name === \"blockContainer\");\nclass bo {\n  constructor(t, e) {\n    d(this, \"state\");\n    d(this, \"emitUpdate\");\n    d(this, \"pluginState\");\n    d(this, \"handleScroll\", () => {\n      var t;\n      if ((t = this.state) != null && t.show) {\n        const e = document.querySelector(\n          `[data-decoration-id=\"${this.pluginState.decorationId}\"]`\n        );\n        this.state.referencePos = e.getBoundingClientRect(), this.emitUpdate(this.pluginState.triggerCharacter);\n      }\n    });\n    d(this, \"closeMenu\", () => {\n      this.editor._tiptapEditor.view.dispatch(\n        this.editor._tiptapEditor.view.state.tr.setMeta(\n          U,\n          null\n        )\n      );\n    });\n    d(this, \"clearQuery\", () => {\n      this.pluginState !== void 0 && this.editor._tiptapEditor.chain().focus().deleteRange({\n        from: this.pluginState.queryStartPos - (this.pluginState.fromUserInput ? this.pluginState.triggerCharacter.length : 0),\n        to: this.editor._tiptapEditor.state.selection.from\n      }).run();\n    });\n    this.editor = t, this.pluginState = void 0, this.emitUpdate = (o) => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized suggestions menu\");\n      e(o, this.state);\n    }, document.addEventListener(\"scroll\", this.handleScroll);\n  }\n  update(t, e) {\n    const o = U.getState(e), r = U.getState(\n      t.state\n    ), i = o === void 0 && r !== void 0, s = o !== void 0 && r === void 0;\n    if (!i && !(o !== void 0 && r !== void 0) && !s)\n      return;\n    if (this.pluginState = s ? o : r, s || !this.editor.isEditable) {\n      this.state.show = !1, this.emitUpdate(this.pluginState.triggerCharacter);\n      return;\n    }\n    const l = document.querySelector(\n      `[data-decoration-id=\"${this.pluginState.decorationId}\"]`\n    );\n    this.editor.isEditable && (this.state = {\n      show: !0,\n      referencePos: l.getBoundingClientRect(),\n      query: this.pluginState.query\n    }, this.emitUpdate(this.pluginState.triggerCharacter));\n  }\n  destroy() {\n    document.removeEventListener(\"scroll\", this.handleScroll);\n  }\n}\nconst U = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"SuggestionMenuPlugin\");\nclass yo extends q {\n  constructor(e) {\n    super();\n    d(this, \"view\");\n    d(this, \"plugin\");\n    d(this, \"triggerCharacters\", []);\n    d(this, \"addTriggerCharacter\", (e) => {\n      this.triggerCharacters.push(e);\n    });\n    // TODO: Should this be called automatically when listeners are removed?\n    d(this, \"removeTriggerCharacter\", (e) => {\n      this.triggerCharacters = this.triggerCharacters.filter(\n        (o) => o !== e\n      );\n    });\n    d(this, \"closeMenu\", () => this.view.closeMenu());\n    d(this, \"clearQuery\", () => this.view.clearQuery());\n    const o = this.triggerCharacters;\n    this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n      key: U,\n      view: () => (this.view = new bo(\n        e,\n        (r, i) => {\n          this.emit(`update ${r}`, i);\n        }\n      ), this.view),\n      state: {\n        // Initialize the plugin's internal state.\n        init() {\n        },\n        // Apply changes to the plugin state from an editor transaction.\n        apply(r, i, s, a) {\n          if (r.getMeta(\"orderedListIndexing\") !== void 0)\n            return i;\n          const l = r.getMeta(U);\n          if (typeof l == \"object\" && l !== null && i === void 0)\n            return {\n              triggerCharacter: l.triggerCharacter,\n              fromUserInput: l.fromUserInput !== !1,\n              queryStartPos: a.selection.from,\n              query: \"\",\n              decorationId: `id_${Math.floor(Math.random() * 4294967295)}`\n            };\n          if (i === void 0)\n            return i;\n          if (\n            // Highlighting text should hide the menu.\n            a.selection.from !== a.selection.to || // Transactions with plugin metadata should hide the menu.\n            l === null || // Certain mouse events should hide the menu.\n            // TODO: Change to global mousedown listener.\n            r.getMeta(\"focus\") || r.getMeta(\"blur\") || r.getMeta(\"pointer\") || // Moving the caret before the character which triggered the menu should hide it.\n            i.triggerCharacter !== void 0 && a.selection.from < i.queryStartPos\n          )\n            return;\n          const c = { ...i };\n          return c.query = a.doc.textBetween(\n            i.queryStartPos,\n            a.selection.from\n          ), c;\n        }\n      },\n      props: {\n        handleKeyDown(r, i) {\n          const s = this.getState(r.state);\n          return o.includes(i.key) && s === void 0 ? (i.preventDefault(), r.dispatch(\n            r.state.tr.insertText(i.key).scrollIntoView().setMeta(U, {\n              triggerCharacter: i.key\n            })\n          ), !0) : !1;\n        },\n        // Setup decorator on the currently active suggestion.\n        decorations(r) {\n          const i = this.getState(r);\n          if (i === void 0)\n            return null;\n          if (!i.fromUserInput) {\n            const s = go(r.selection);\n            if (s)\n              return prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.DecorationSet.create(r.doc, [\n                prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.Decoration.node(\n                  s.pos,\n                  s.pos + s.node.nodeSize,\n                  {\n                    nodeName: \"span\",\n                    class: \"bn-suggestion-decorator\",\n                    \"data-decoration-id\": i.decorationId\n                  }\n                )\n              ]);\n          }\n          return prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.DecorationSet.create(r.doc, [\n            prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.Decoration.inline(\n              i.queryStartPos - i.triggerCharacter.length,\n              i.queryStartPos,\n              {\n                nodeName: \"span\",\n                class: \"bn-suggestion-decorator\",\n                \"data-decoration-id\": i.decorationId\n              }\n            )\n          ]);\n        }\n      }\n    });\n  }\n  onUpdate(e, o) {\n    return this.triggerCharacters.includes(e) || this.addTriggerCharacter(e), this.on(`update ${e}`, o);\n  }\n}\nfunction Vr(n, t) {\n  n.suggestionMenus.addTriggerCharacter(t);\n}\nclass F extends prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Selection {\n  constructor(e, o) {\n    super(e, o);\n    d(this, \"nodes\");\n    const r = e.node();\n    this.nodes = [], e.doc.nodesBetween(e.pos, o.pos, (i, s, a) => {\n      if (a !== null && a.eq(r))\n        return this.nodes.push(i), !1;\n    });\n  }\n  static create(e, o, r = o) {\n    return new F(e.resolve(o), e.resolve(r));\n  }\n  content() {\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(this.nodes), 0, 0);\n  }\n  eq(e) {\n    if (!(e instanceof F) || this.nodes.length !== e.nodes.length || this.from !== e.from || this.to !== e.to)\n      return !1;\n    for (let o = 0; o < this.nodes.length; o++)\n      if (!this.nodes[o].eq(e.nodes[o]))\n        return !1;\n    return !0;\n  }\n  map(e, o) {\n    const r = o.mapResult(this.from), i = o.mapResult(this.to);\n    return i.deleted ? prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Selection.near(e.resolve(r.pos)) : r.deleted ? prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Selection.near(e.resolve(i.pos)) : new F(\n      e.resolve(r.pos),\n      e.resolve(i.pos)\n    );\n  }\n  toJSON() {\n    return { type: \"node\", anchor: this.anchor, head: this.head };\n  }\n}\nlet H;\nfunction Ct(n, t) {\n  var r;\n  if (!t.dom.isConnected)\n    return;\n  const e = t.posAtCoords(n);\n  if (!e)\n    return;\n  let o = t.domAtPos(e.pos).node;\n  if (o !== t.dom) {\n    for (; o && o.parentNode && o.parentNode !== t.dom && !((r = o.hasAttribute) != null && r.call(o, \"data-id\")); )\n      o = o.parentNode;\n    if (o)\n      return { node: o, id: o.getAttribute(\"data-id\") };\n  }\n}\nfunction ko(n, t) {\n  const e = Ct(n, t);\n  if (e && e.node.nodeType === 1) {\n    const o = t.docView, r = o.nearestDesc(e.node, !0);\n    return !r || r === o ? null : r.posBefore;\n  }\n  return null;\n}\nfunction wo(n, t) {\n  let e, o;\n  const r = t.resolve(n.from).node().type.spec.group === \"blockContent\", i = t.resolve(n.to).node().type.spec.group === \"blockContent\", s = Math.min(n.$anchor.depth, n.$head.depth);\n  if (r && i) {\n    const a = n.$from.start(s - 1), l = n.$to.end(s - 1);\n    e = t.resolve(a - 1).pos, o = t.resolve(l + 1).pos;\n  } else\n    e = n.from, o = n.to;\n  return { from: e, to: o };\n}\nfunction Dt(n, t, e = t) {\n  t === e && (e += n.state.doc.resolve(t + 1).node().nodeSize);\n  const o = n.domAtPos(t).node.cloneNode(!0), r = n.domAtPos(t).node, i = (p, u) => Array.prototype.indexOf.call(p.children, u), s = i(\n    r,\n    // Expects from position to be just before the first selected block.\n    n.domAtPos(t + 1).node.parentElement\n  ), a = i(\n    r,\n    // Expects to position to be just after the last selected block.\n    n.domAtPos(e - 1).node.parentElement\n  );\n  for (let p = r.childElementCount - 1; p >= 0; p--)\n    (p > a || p < s) && o.removeChild(o.children[p]);\n  ce(), H = o;\n  const c = n.dom.className.split(\" \").filter(\n    (p) => p !== \"ProseMirror\" && p !== \"bn-root\" && p !== \"bn-editor\"\n  ).join(\" \");\n  H.className = H.className + \" bn-drag-preview \" + c, document.body.appendChild(H);\n}\nfunction ce() {\n  H !== void 0 && (document.body.removeChild(H), H = void 0);\n}\nfunction vo(n, t) {\n  if (!n.dataTransfer)\n    return;\n  const e = t.prosemirrorView, o = e.dom.getBoundingClientRect(), r = {\n    left: o.left + o.width / 2,\n    // take middle of editor\n    top: n.clientY\n  }, i = ko(r, e);\n  if (i != null) {\n    const s = e.state.selection, a = e.state.doc, { from: l, to: c } = wo(s, a), p = l <= i && i < c, u = s.$anchor.node() !== s.$head.node() || s instanceof F;\n    p && u ? (e.dispatch(\n      e.state.tr.setSelection(F.create(a, l, c))\n    ), Dt(e, l, c)) : (e.dispatch(\n      e.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.NodeSelection.create(e.state.doc, i))\n    ), Dt(e, i));\n    const m = e.state.selection.content(), h = t._tiptapEditor.schema, y = Jt(h, t).serializeProseMirrorFragment(\n      m.content\n    ), B = at(h, t).exportProseMirrorFragment(\n      m.content\n    ), E = St(B);\n    n.dataTransfer.clearData(), n.dataTransfer.setData(\"blocknote/html\", y), n.dataTransfer.setData(\"text/html\", B), n.dataTransfer.setData(\"text/plain\", E), n.dataTransfer.effectAllowed = \"move\", n.dataTransfer.setDragImage(H, 0, 0), e.dragging = { slice: m, move: !0 };\n  }\n}\nclass Eo {\n  constructor(t, e, o) {\n    d(this, \"state\");\n    d(this, \"emitUpdate\");\n    // When true, the drag handle with be anchored at the same level as root elements\n    // When false, the drag handle with be just to the left of the element\n    // TODO: Is there any case where we want this to be false?\n    d(this, \"horizontalPosAnchoredAtRoot\");\n    d(this, \"horizontalPosAnchor\");\n    d(this, \"hoveredBlock\");\n    // Used to check if currently dragged content comes from this editor instance.\n    d(this, \"isDragging\", !1);\n    d(this, \"menuFrozen\", !1);\n    /**\n     * Sets isDragging when dragging text.\n     */\n    d(this, \"onDragStart\", () => {\n      this.isDragging = !0;\n    });\n    /**\n     * If the event is outside the editor contents,\n     * we dispatch a fake event, so that we can still drop the content\n     * when dragging / dropping to the side of the editor\n     */\n    d(this, \"onDrop\", (t) => {\n      if (this.editor._tiptapEditor.commands.blur(), t.synthetic || !this.isDragging)\n        return;\n      const e = this.pmView.posAtCoords({\n        left: t.clientX,\n        top: t.clientY\n      });\n      if (this.isDragging = !1, !e || e.inside === -1) {\n        const o = new Event(\"drop\", t), r = this.pmView.dom.firstChild.getBoundingClientRect();\n        o.clientX = r.left + r.width / 2, o.clientY = t.clientY, o.dataTransfer = t.dataTransfer, o.preventDefault = () => t.preventDefault(), o.synthetic = !0, this.pmView.dom.dispatchEvent(o);\n      }\n    });\n    /**\n     * If the event is outside the editor contents,\n     * we dispatch a fake event, so that we can still drop the content\n     * when dragging / dropping to the side of the editor\n     */\n    d(this, \"onDragOver\", (t) => {\n      if (t.synthetic || !this.isDragging)\n        return;\n      const e = this.pmView.posAtCoords({\n        left: t.clientX,\n        top: t.clientY\n      });\n      if (!e || e.inside === -1) {\n        const o = new Event(\"dragover\", t), r = this.pmView.dom.firstChild.getBoundingClientRect();\n        o.clientX = r.left + r.width / 2, o.clientY = t.clientY, o.dataTransfer = t.dataTransfer, o.preventDefault = () => t.preventDefault(), o.synthetic = !0, this.pmView.dom.dispatchEvent(o);\n      }\n    });\n    d(this, \"onKeyDown\", (t) => {\n      var e;\n      (e = this.state) != null && e.show && (this.state.show = !1, this.emitUpdate(this.state)), this.menuFrozen = !1;\n    });\n    d(this, \"onMouseDown\", (t) => {\n      this.state && !this.state.show && (this.state.show = !0, this.emitUpdate(this.state)), this.menuFrozen = !1;\n    });\n    d(this, \"onMouseMove\", (t) => {\n      var c, p, u, m, h;\n      if (this.menuFrozen)\n        return;\n      const e = this.pmView.dom.firstChild.getBoundingClientRect(), o = this.pmView.dom.getBoundingClientRect(), r = t.clientX >= o.left && t.clientX <= o.right && t.clientY >= o.top && t.clientY <= o.bottom, i = this.pmView.dom.parentElement;\n      if (\n        // Cursor is within the editor area\n        r && // An element is hovered\n        t && t.target && // Element is outside the editor\n        !(i === t.target || i.contains(t.target))\n      ) {\n        (c = this.state) != null && c.show && (this.state.show = !1, this.emitUpdate(this.state));\n        return;\n      }\n      this.horizontalPosAnchor = e.x;\n      const s = {\n        left: e.left + e.width / 2,\n        // take middle of editor\n        top: t.clientY\n      }, a = Ct(s, this.pmView);\n      if (!a || !this.editor.isEditable) {\n        (p = this.state) != null && p.show && (this.state.show = !1, this.emitUpdate(this.state));\n        return;\n      }\n      if ((u = this.state) != null && u.show && ((m = this.hoveredBlock) != null && m.hasAttribute(\"data-id\")) && ((h = this.hoveredBlock) == null ? void 0 : h.getAttribute(\"data-id\")) === a.id)\n        return;\n      this.hoveredBlock = a.node;\n      const l = a.node.firstChild;\n      if (l && this.editor.isEditable) {\n        const f = l.getBoundingClientRect();\n        this.state = {\n          show: !0,\n          referencePos: new DOMRect(\n            this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : f.x,\n            f.y,\n            f.width,\n            f.height\n          ),\n          block: this.editor.getBlock(\n            this.hoveredBlock.getAttribute(\"data-id\")\n          )\n        }, this.emitUpdate(this.state);\n      }\n    });\n    d(this, \"onScroll\", () => {\n      var t;\n      if ((t = this.state) != null && t.show) {\n        const o = this.hoveredBlock.firstChild.getBoundingClientRect();\n        this.state.referencePos = new DOMRect(\n          this.horizontalPosAnchoredAtRoot ? this.horizontalPosAnchor : o.x,\n          o.y,\n          o.width,\n          o.height\n        ), this.emitUpdate(this.state);\n      }\n    });\n    this.editor = t, this.pmView = e, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized side menu\");\n      o(this.state);\n    }, this.horizontalPosAnchoredAtRoot = !0, this.horizontalPosAnchor = this.pmView.dom.firstChild.getBoundingClientRect().x, document.body.addEventListener(\"drop\", this.onDrop, !0), document.body.addEventListener(\"dragover\", this.onDragOver), this.pmView.dom.addEventListener(\"dragstart\", this.onDragStart), document.body.addEventListener(\"mousemove\", this.onMouseMove, !0), document.addEventListener(\"scroll\", this.onScroll), document.body.addEventListener(\"mousedown\", this.onMouseDown, !0), document.body.addEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  destroy() {\n    var t;\n    (t = this.state) != null && t.show && (this.state.show = !1, this.emitUpdate(this.state)), document.body.removeEventListener(\"mousemove\", this.onMouseMove, !0), document.body.removeEventListener(\"dragover\", this.onDragOver), this.pmView.dom.removeEventListener(\"dragstart\", this.onDragStart), document.body.removeEventListener(\"drop\", this.onDrop, !0), document.removeEventListener(\"scroll\", this.onScroll), document.body.removeEventListener(\"mousedown\", this.onMouseDown, !0), document.body.removeEventListener(\"keydown\", this.onKeyDown, !0);\n  }\n  addBlock() {\n    var l;\n    (l = this.state) != null && l.show && (this.state.show = !1, this.emitUpdate(this.state)), this.menuFrozen = !0;\n    const e = this.hoveredBlock.firstChild.getBoundingClientRect(), o = this.pmView.posAtCoords({\n      left: e.left + e.width / 2,\n      top: e.top + e.height / 2\n    });\n    if (!o)\n      return;\n    const r = b(\n      this.editor._tiptapEditor.state.doc,\n      o.pos\n    );\n    if (r === void 0)\n      return;\n    const { contentNode: i, startPos: s, endPos: a } = r;\n    if (i.type.spec.content !== \"inline*\" || i.textContent.length !== 0) {\n      const c = a + 1, p = c + 2;\n      this.editor._tiptapEditor.chain().BNCreateBlock(c).setTextSelection(p).run();\n    } else\n      this.editor._tiptapEditor.commands.setTextSelection(s + 1);\n    this.pmView.focus(), this.pmView.dispatch(\n      this.pmView.state.tr.scrollIntoView().setMeta(U, {\n        triggerCharacter: \"/\",\n        fromUserInput: !1\n      })\n    );\n  }\n}\nconst So = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"SideMenuPlugin\");\nclass Co extends q {\n  constructor(e) {\n    super();\n    d(this, \"view\");\n    d(this, \"plugin\");\n    /**\n     * If the block is empty, opens the slash menu. If the block has content,\n     * creates a new block below and opens the slash menu in it.\n     */\n    d(this, \"addBlock\", () => this.view.addBlock());\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    d(this, \"blockDragStart\", (e) => {\n      this.view.isDragging = !0, vo(e, this.editor);\n    });\n    /**\n     * Handles drag & drop events for blocks.\n     */\n    d(this, \"blockDragEnd\", () => ce());\n    /**\n     * Freezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    d(this, \"freezeMenu\", () => this.view.menuFrozen = !0);\n    /**\n     * Unfreezes the side menu. When frozen, the side menu will stay\n     * attached to the same block regardless of which block is hovered by the\n     * mouse cursor.\n     */\n    d(this, \"unfreezeMenu\", () => this.view.menuFrozen = !1);\n    this.editor = e, this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n      key: So,\n      view: (o) => (this.view = new Eo(e, o, (r) => {\n        this.emit(\"update\", r);\n      }), this.view)\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nlet C;\nfunction Ot() {\n  C || (C = document.createElement(\"div\"), C.innerHTML = \"_\", C.style.opacity = \"0\", C.style.height = \"1px\", C.style.width = \"1px\", document.body.appendChild(C));\n}\nfunction To() {\n  C && (document.body.removeChild(C), C = void 0);\n}\nfunction ot(n) {\n  return Array.prototype.indexOf.call(n.parentElement.childNodes, n);\n}\nfunction xo(n) {\n  for (; n && n.nodeName !== \"TD\" && n.nodeName !== \"TH\"; )\n    n = n.classList && n.classList.contains(\"ProseMirror\") ? null : n.parentNode;\n  return n;\n}\nfunction Mo(n) {\n  n.forEach((t) => {\n    const e = document.getElementsByClassName(t);\n    for (let o = 0; o < e.length; o++)\n      e[o].style.visibility = \"hidden\";\n  });\n}\nclass Bo {\n  constructor(t, e, o) {\n    d(this, \"state\");\n    d(this, \"emitUpdate\");\n    d(this, \"tableId\");\n    d(this, \"tablePos\");\n    d(this, \"menuFrozen\", !1);\n    d(this, \"prevWasEditable\", null);\n    d(this, \"mouseMoveHandler\", (t) => {\n      var c;\n      if (this.menuFrozen)\n        return;\n      const e = xo(t.target);\n      if (!e || !this.editor.isEditable) {\n        (c = this.state) != null && c.show && (this.state.show = !1, this.emitUpdate());\n        return;\n      }\n      const o = ot(e), r = ot(e.parentElement), i = e.getBoundingClientRect(), s = e.parentElement.parentElement.getBoundingClientRect(), a = Ct(i, this.pmView);\n      if (!a)\n        throw new Error(\n          \"Found table cell element, but could not find surrounding blockContent element.\"\n        );\n      if (this.tableId = a.id, this.state !== void 0 && this.state.show && this.tableId === a.id && this.state.rowIndex === r && this.state.colIndex === o)\n        return;\n      let l;\n      return this.editor._tiptapEditor.state.doc.descendants((p, u) => typeof l < \"u\" ? !1 : p.type.name !== \"blockContainer\" || p.attrs.id !== a.id ? !0 : (l = k(\n        p,\n        this.editor.schema.blockSchema,\n        this.editor.schema.inlineContentSchema,\n        this.editor.schema.styleSchema,\n        this.editor.blockCache\n      ), this.tablePos = u + 1, !1)), this.state = {\n        show: !0,\n        referencePosCell: i,\n        referencePosTable: s,\n        block: l,\n        colIndex: o,\n        rowIndex: r,\n        draggingState: void 0\n      }, this.emitUpdate(), !1;\n    });\n    d(this, \"dragOverHandler\", (t) => {\n      var m;\n      if (((m = this.state) == null ? void 0 : m.draggingState) === void 0)\n        return;\n      t.preventDefault(), t.dataTransfer.dropEffect = \"move\", Mo([\n        \"column-resize-handle\",\n        \"prosemirror-dropcursor-block\",\n        \"prosemirror-dropcursor-inline\"\n      ]);\n      const e = {\n        left: Math.min(\n          Math.max(t.clientX, this.state.referencePosTable.left + 1),\n          this.state.referencePosTable.right - 1\n        ),\n        top: Math.min(\n          Math.max(t.clientY, this.state.referencePosTable.top + 1),\n          this.state.referencePosTable.bottom - 1\n        )\n      }, o = document.elementsFromPoint(e.left, e.top).filter(\n        (h) => h.tagName === \"TD\" || h.tagName === \"TH\"\n      );\n      if (o.length === 0)\n        throw new Error(\n          \"Could not find table cell element that the mouse cursor is hovering over.\"\n        );\n      const r = o[0];\n      let i = !1;\n      const s = ot(r.parentElement), a = ot(r), l = this.state.draggingState.draggedCellOrientation === \"row\" ? this.state.rowIndex : this.state.colIndex, p = (this.state.draggingState.draggedCellOrientation === \"row\" ? s : a) !== l;\n      (this.state.rowIndex !== s || this.state.colIndex !== a) && (this.state.rowIndex = s, this.state.colIndex = a, this.state.referencePosCell = r.getBoundingClientRect(), i = !0);\n      const u = this.state.draggingState.draggedCellOrientation === \"row\" ? e.top : e.left;\n      this.state.draggingState.mousePos !== u && (this.state.draggingState.mousePos = u, i = !0), i && this.emitUpdate(), p && this.pmView.dispatch(\n        this.pmView.state.tr.setMeta(X, !0)\n      );\n    });\n    d(this, \"dropHandler\", (t) => {\n      if (this.state === void 0 || this.state.draggingState === void 0)\n        return;\n      t.preventDefault();\n      const e = this.state.block.content.rows;\n      if (this.state.draggingState.draggedCellOrientation === \"row\") {\n        const o = e[this.state.draggingState.originalIndex];\n        e.splice(this.state.draggingState.originalIndex, 1), e.splice(this.state.rowIndex, 0, o);\n      } else {\n        const o = e.map(\n          (r) => r.cells[this.state.draggingState.originalIndex]\n        );\n        e.forEach((r, i) => {\n          r.cells.splice(this.state.draggingState.originalIndex, 1), r.cells.splice(this.state.colIndex, 0, o[i]);\n        });\n      }\n      this.editor.updateBlock(this.state.block, {\n        type: \"table\",\n        content: {\n          type: \"tableContent\",\n          rows: e\n        }\n      });\n    });\n    d(this, \"scrollHandler\", () => {\n      var t;\n      if ((t = this.state) != null && t.show) {\n        const e = document.querySelector(\n          `[data-node-type=\"blockContainer\"][data-id=\"${this.tableId}\"] table`\n        ), o = e.querySelector(\n          `tr:nth-child(${this.state.rowIndex + 1}) > td:nth-child(${this.state.colIndex + 1})`\n        );\n        this.state.referencePosTable = e.getBoundingClientRect(), this.state.referencePosCell = o.getBoundingClientRect(), this.emitUpdate();\n      }\n    });\n    this.editor = t, this.pmView = e, this.emitUpdate = () => {\n      if (!this.state)\n        throw new Error(\"Attempting to update uninitialized image toolbar\");\n      o(this.state);\n    }, e.dom.addEventListener(\"mousemove\", this.mouseMoveHandler), document.addEventListener(\"dragover\", this.dragOverHandler), document.addEventListener(\"drop\", this.dropHandler), document.addEventListener(\"scroll\", this.scrollHandler);\n  }\n  destroy() {\n    this.pmView.dom.removeEventListener(\"mousedown\", this.mouseMoveHandler), document.removeEventListener(\"dragover\", this.dragOverHandler), document.removeEventListener(\"drop\", this.dropHandler), document.removeEventListener(\"scroll\", this.scrollHandler);\n  }\n}\nconst X = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"TableHandlesPlugin\");\nclass Io extends q {\n  constructor(e) {\n    super();\n    d(this, \"view\");\n    d(this, \"plugin\");\n    /**\n     * Callback that should be set on the `dragStart` event for whichever element\n     * is used as the column drag handle.\n     */\n    d(this, \"colDragStart\", (e) => {\n      if (this.view.state === void 0)\n        throw new Error(\n          \"Attempted to drag table column, but no table block was hovered prior.\"\n        );\n      this.view.state.draggingState = {\n        draggedCellOrientation: \"col\",\n        originalIndex: this.view.state.colIndex,\n        mousePos: e.clientX\n      }, this.view.emitUpdate(), this.editor._tiptapEditor.view.dispatch(\n        this.editor._tiptapEditor.state.tr.setMeta(X, {\n          draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,\n          originalIndex: this.view.state.colIndex,\n          newIndex: this.view.state.colIndex,\n          tablePos: this.view.tablePos\n        })\n      ), Ot(), e.dataTransfer.setDragImage(C, 0, 0), e.dataTransfer.effectAllowed = \"move\";\n    });\n    /**\n     * Callback that should be set on the `dragStart` event for whichever element\n     * is used as the row drag handle.\n     */\n    d(this, \"rowDragStart\", (e) => {\n      if (this.view.state === void 0)\n        throw new Error(\n          \"Attempted to drag table row, but no table block was hovered prior.\"\n        );\n      this.view.state.draggingState = {\n        draggedCellOrientation: \"row\",\n        originalIndex: this.view.state.rowIndex,\n        mousePos: e.clientY\n      }, this.view.emitUpdate(), this.editor._tiptapEditor.view.dispatch(\n        this.editor._tiptapEditor.state.tr.setMeta(X, {\n          draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,\n          originalIndex: this.view.state.rowIndex,\n          newIndex: this.view.state.rowIndex,\n          tablePos: this.view.tablePos\n        })\n      ), Ot(), e.dataTransfer.setDragImage(C, 0, 0), e.dataTransfer.effectAllowed = \"copyMove\";\n    });\n    /**\n     * Callback that should be set on the `dragEnd` event for both the element\n     * used as the row drag handle, and the one used as the column drag handle.\n     */\n    d(this, \"dragEnd\", () => {\n      if (this.view.state === void 0)\n        throw new Error(\n          \"Attempted to drag table row, but no table block was hovered prior.\"\n        );\n      this.view.state.draggingState = void 0, this.view.emitUpdate(), this.editor._tiptapEditor.view.dispatch(\n        this.editor._tiptapEditor.state.tr.setMeta(X, null)\n      ), To();\n    });\n    /**\n     * Freezes the drag handles. When frozen, they will stay attached to the same\n     * cell regardless of which cell is hovered by the mouse cursor.\n     */\n    d(this, \"freezeHandles\", () => {\n      this.view.menuFrozen = !0;\n    });\n    /**\n     * Unfreezes the drag handles. When frozen, they will stay attached to the\n     * same cell regardless of which cell is hovered by the mouse cursor.\n     */\n    d(this, \"unfreezeHandles\", () => {\n      this.view.menuFrozen = !1;\n    });\n    this.editor = e, this.plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n      key: X,\n      view: (o) => (this.view = new Bo(e, o, (r) => {\n        this.emit(\"update\", r);\n      }), this.view),\n      // We use decorations to render the drop cursor when dragging a table row\n      // or column. The decorations are updated in the `dragOverHandler` method.\n      props: {\n        decorations: (o) => {\n          if (this.view === void 0 || this.view.state === void 0 || this.view.state.draggingState === void 0 || this.view.tablePos === void 0)\n            return;\n          const r = this.view.state.draggingState.draggedCellOrientation === \"row\" ? this.view.state.rowIndex : this.view.state.colIndex, i = [];\n          if (r === this.view.state.draggingState.originalIndex)\n            return prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.DecorationSet.create(o.doc, i);\n          const s = o.doc.resolve(this.view.tablePos + 1), a = s.node();\n          if (this.view.state.draggingState.draggedCellOrientation === \"row\") {\n            const l = o.doc.resolve(\n              s.posAtIndex(r) + 1\n            ), c = l.node();\n            for (let p = 0; p < c.childCount; p++) {\n              const u = o.doc.resolve(\n                l.posAtIndex(p) + 1\n              ), m = u.node(), h = u.pos + (r > this.view.state.draggingState.originalIndex ? m.nodeSize - 2 : 0);\n              i.push(\n                // The widget is a small bar which spans the width of the cell.\n                prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.Decoration.widget(h, () => {\n                  const f = document.createElement(\"div\");\n                  return f.className = \"bn-table-drop-cursor\", f.style.left = \"0\", f.style.right = \"0\", r > this.view.state.draggingState.originalIndex ? f.style.bottom = \"-2px\" : f.style.top = \"-3px\", f.style.height = \"4px\", f;\n                })\n              );\n            }\n          } else\n            for (let l = 0; l < a.childCount; l++) {\n              const c = o.doc.resolve(\n                s.posAtIndex(l) + 1\n              ), p = o.doc.resolve(\n                c.posAtIndex(r) + 1\n              ), u = p.node(), m = p.pos + (r > this.view.state.draggingState.originalIndex ? u.nodeSize - 2 : 0);\n              i.push(\n                // The widget is a small bar which spans the height of the cell.\n                prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.Decoration.widget(m, () => {\n                  const h = document.createElement(\"div\");\n                  return h.className = \"bn-table-drop-cursor\", h.style.top = \"0\", h.style.bottom = \"0\", r > this.view.state.draggingState.originalIndex ? h.style.right = \"-2px\" : h.style.left = \"-3px\", h.style.width = \"4px\", h;\n                })\n              );\n            }\n          return prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.DecorationSet.create(o.doc, i);\n        }\n      }\n    });\n  }\n  onUpdate(e) {\n    return this.on(\"update\", e);\n  }\n}\nfunction _t(n, t) {\n  const e = n.state.selection.content().content, r = Jt(\n    n.state.schema,\n    t\n  ).serializeProseMirrorFragment(e), s = at(\n    n.state.schema,\n    t\n  ).exportProseMirrorFragment(e), a = St(s);\n  return { internalHTML: r, externalHTML: s, plainText: a };\n}\nconst Lo = (n) => _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"copyToClipboard\",\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n        props: {\n          handleDOMEvents: {\n            copy(t, e) {\n              e.preventDefault(), e.clipboardData.clearData(), \"node\" in t.state.selection && t.state.selection.node.type.spec.group === \"blockContent\" && t.dispatch(\n                t.state.tr.setSelection(\n                  new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.NodeSelection(\n                    t.state.doc.resolve(t.state.selection.from - 1)\n                  )\n                )\n              );\n              const { internalHTML: o, externalHTML: r, plainText: i } = _t(t, n);\n              return e.clipboardData.setData(\"blocknote/html\", o), e.clipboardData.setData(\"text/html\", r), e.clipboardData.setData(\"text/plain\", i), !0;\n            },\n            // This is for the use-case in which only a block without content\n            // is selected, e.g. an image block, and dragged (not using the\n            // drag handle).\n            dragstart(t, e) {\n              if (!(\"node\" in t.state.selection) || t.state.selection.node.type.spec.group !== \"blockContent\")\n                return;\n              t.dispatch(\n                t.state.tr.setSelection(\n                  new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.NodeSelection(\n                    t.state.doc.resolve(t.state.selection.from - 1)\n                  )\n                )\n              ), e.preventDefault(), e.dataTransfer.clearData();\n              const { internalHTML: o, externalHTML: r, plainText: i } = _t(t, n);\n              return e.dataTransfer.setData(\"blocknote/html\", o), e.dataTransfer.setData(\"text/html\", r), e.dataTransfer.setData(\"text/plain\", i), !0;\n            }\n          }\n        }\n      })\n    ];\n  }\n}), No = [\n  \"blocknote/html\",\n  \"text/html\",\n  \"text/plain\"\n], Ao = (n) => _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"pasteFromClipboard\",\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n        props: {\n          handleDOMEvents: {\n            paste(t, e) {\n              e.preventDefault();\n              let o = null;\n              for (const r of No)\n                if (e.clipboardData.types.includes(r)) {\n                  o = r;\n                  break;\n                }\n              if (o !== null) {\n                let r = e.clipboardData.getData(o);\n                o === \"text/html\" && (r = ae(\n                  r.trim()\n                ).innerHTML), n._tiptapEditor.view.pasteHTML(r);\n              }\n              return !0;\n            }\n          }\n        }\n      })\n    ];\n  }\n}), Ho = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"blockBackgroundColor\",\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          backgroundColor: {\n            default: w.backgroundColor.default,\n            parseHTML: (n) => n.hasAttribute(\"data-background-color\") ? n.getAttribute(\"data-background-color\") : w.backgroundColor.default,\n            renderHTML: (n) => n.backgroundColor !== w.backgroundColor.default && {\n              \"data-background-color\": n.backgroundColor\n            }\n          }\n        }\n      }\n    ];\n  }\n}), Po = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"blocknote-placeholder\"), Do = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"placeholder\",\n  addOptions() {\n    return {\n      placeholders: {\n        default: \"Enter text or type '/' for commands\",\n        heading: \"Heading\",\n        bulletListItem: \"List\",\n        numberedListItem: \"List\"\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    const n = this.options.placeholders;\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n        key: Po,\n        view: () => {\n          const t = document.createElement(\"style\");\n          document.head.appendChild(t);\n          const e = t.sheet, o = (i = \"\") => `.bn-block-content${i} .bn-inline-content:has(> .ProseMirror-trailingBreak):before`, r = (i, s = !0) => {\n            const a = s ? \"[data-is-empty-and-focused]\" : \"\";\n            if (i === \"default\")\n              return o(a);\n            const l = `[data-content-type=\"${i}\"]`;\n            return o(a + l);\n          };\n          for (const [i, s] of Object.entries(n)) {\n            const a = i === \"default\";\n            e.insertRule(\n              `${r(\n                i,\n                a\n              )}{ content: ${JSON.stringify(s)}; }`\n            ), a || e.insertRule(\n              `${r(i, !0)}{ content: ${JSON.stringify(\n                s\n              )}; }`\n            );\n          }\n          return {\n            destroy: () => {\n              document.head.removeChild(t);\n            }\n          };\n        },\n        props: {\n          // TODO: maybe also add placeholder for empty document (\"e.g.: start writing..\")\n          decorations: (t) => {\n            const { doc: e, selection: o } = t;\n            if (!this.editor.isEditable || !o.empty)\n              return;\n            const i = o.$anchor, s = i.parent;\n            if (s.content.size > 0)\n              return null;\n            const a = i.before(), l = prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.Decoration.node(a, a + s.nodeSize, {\n              \"data-is-empty-and-focused\": \"true\"\n            });\n            return prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.DecorationSet.create(e, [l]);\n          }\n        }\n      })\n    ];\n  }\n}), Oo = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"textAlignment\",\n  addGlobalAttributes() {\n    return [\n      {\n        // Attribute is applied to block content instead of container so that child blocks don't inherit the text\n        // alignment styling.\n        types: [\"paragraph\", \"heading\", \"bulletListItem\", \"numberedListItem\"],\n        attributes: {\n          textAlignment: {\n            default: \"left\",\n            parseHTML: (n) => n.getAttribute(\"data-text-alignment\"),\n            renderHTML: (n) => n.textAlignment !== \"left\" && {\n              \"data-text-alignment\": n.textAlignment\n            }\n          }\n        }\n      }\n    ];\n  }\n}), _o = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"blockTextColor\",\n  addGlobalAttributes() {\n    return [\n      {\n        types: [\"blockContainer\"],\n        attributes: {\n          textColor: {\n            default: w.textColor.default,\n            parseHTML: (n) => n.hasAttribute(\"data-text-color\") ? n.getAttribute(\"data-text-color\") : w.textColor.default,\n            renderHTML: (n) => n.textColor !== w.textColor.default && {\n              \"data-text-color\": n.textColor\n            }\n          }\n        }\n      }\n    ];\n  }\n}), Uo = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n  name: \"trailingNode\",\n  addProseMirrorPlugins() {\n    const n = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(this.name);\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n        key: n,\n        appendTransaction: (t, e, o) => {\n          const { doc: r, tr: i, schema: s } = o, a = n.getState(o), l = r.content.size - 2, c = s.nodes.blockContainer, p = s.nodes.paragraph;\n          if (a)\n            return i.insert(\n              l,\n              c.create(void 0, p.create())\n            );\n        },\n        state: {\n          init: (t, e) => {\n          },\n          apply: (t, e) => {\n            if (!t.docChanged)\n              return e;\n            let o = t.doc.lastChild;\n            if (!o || o.type.name !== \"blockGroup\")\n              throw new Error(\"Expected blockGroup\");\n            if (o = o.lastChild, !o || o.type.name !== \"blockContainer\")\n              throw new Error(\"Expected blockContainer\");\n            const r = o.firstChild;\n            if (!r)\n              throw new Error(\"Expected blockContent\");\n            return o.nodeSize > 4 || r.type.spec.content !== \"inline*\";\n          }\n        }\n      })\n    ];\n  }\n}), Ro = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"non-editable-block\"), zo = () => new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n  key: Ro,\n  props: {\n    handleKeyDown: (n, t) => {\n      \"node\" in n.state.selection && t.key.length === 1 && !t.ctrlKey && !t.altKey && !t.metaKey && !t.shiftKey && t.preventDefault();\n    }\n  }\n}), Ut = new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.PluginKey(\"previous-blocks\"), Vo = {\n  // Numbered List Items\n  index: \"index\",\n  // Headings\n  level: \"level\",\n  // All Blocks\n  type: \"type\",\n  depth: \"depth\",\n  \"depth-change\": \"depth-change\"\n}, Fo = () => {\n  let n;\n  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.Plugin({\n    key: Ut,\n    view(t) {\n      return {\n        update: async (e, o) => {\n          var r;\n          ((r = this.key) == null ? void 0 : r.getState(e.state).updatedBlocks.size) > 0 && (n = setTimeout(() => {\n            e.dispatch(\n              e.state.tr.setMeta(Ut, { clearUpdate: !0 })\n            );\n          }, 0));\n        },\n        destroy: () => {\n          n && clearTimeout(n);\n        }\n      };\n    },\n    state: {\n      init() {\n        return {\n          // Block attributes, by block ID, from just before the previous transaction.\n          prevTransactionOldBlockAttrs: {},\n          // Block attributes, by block ID, from just before the current transaction.\n          currentTransactionOldBlockAttrs: {},\n          // Set of IDs of blocks whose attributes changed from the current transaction.\n          updatedBlocks: /* @__PURE__ */ new Set()\n        };\n      },\n      apply(t, e, o, r) {\n        if (e.currentTransactionOldBlockAttrs = {}, e.updatedBlocks.clear(), !t.docChanged || o.doc.eq(r.doc))\n          return e;\n        const i = {}, s = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.findChildren)(o.doc, (c) => c.attrs.id), a = new Map(\n          s.map((c) => [c.node.attrs.id, c])\n        ), l = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.findChildren)(r.doc, (c) => c.attrs.id);\n        for (const c of l) {\n          const p = a.get(c.node.attrs.id), u = p == null ? void 0 : p.node.firstChild, m = c.node.firstChild;\n          if (p && u && m) {\n            const h = {\n              index: m.attrs.index,\n              level: m.attrs.level,\n              type: m.type.name,\n              depth: r.doc.resolve(c.pos).depth\n            };\n            let f = {\n              index: u.attrs.index,\n              level: u.attrs.level,\n              type: u.type.name,\n              depth: o.doc.resolve(p.pos).depth\n            };\n            i[c.node.attrs.id] = f, t.getMeta(\"numberedListIndexing\") && (c.node.attrs.id in e.prevTransactionOldBlockAttrs && (f = e.prevTransactionOldBlockAttrs[c.node.attrs.id]), h.type === \"numberedListItem\" && (f.index = h.index)), e.currentTransactionOldBlockAttrs[c.node.attrs.id] = f, JSON.stringify(f) !== JSON.stringify(h) && (f[\"depth-change\"] = f.depth - h.depth, e.updatedBlocks.add(c.node.attrs.id));\n          }\n        }\n        return e.prevTransactionOldBlockAttrs = i, e;\n      }\n    },\n    props: {\n      decorations(t) {\n        const e = this.getState(t);\n        if (e.updatedBlocks.size === 0)\n          return;\n        const o = [];\n        return t.doc.descendants((r, i) => {\n          if (!r.attrs.id || !e.updatedBlocks.has(r.attrs.id))\n            return;\n          const s = e.currentTransactionOldBlockAttrs[r.attrs.id], a = {};\n          for (const [c, p] of Object.entries(s))\n            a[\"data-prev-\" + Vo[c]] = p || \"none\";\n          const l = prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.Decoration.node(i, i + r.nodeSize, {\n            ...a\n          });\n          o.push(l);\n        }), prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.DecorationSet.create(t.doc, o);\n      }\n    }\n  });\n}, $o = {\n  blockColor: \"data-block-color\",\n  blockStyle: \"data-block-style\",\n  id: \"data-id\",\n  depth: \"data-depth\",\n  depthChange: \"data-depth-change\"\n}, Go = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Node.create({\n  name: \"blockContainer\",\n  group: \"blockContainer\",\n  // A block always contains content, and optionally a blockGroup which contains nested blocks\n  content: \"blockContent blockGroup?\",\n  // Ensures content-specific keyboard handlers trigger first.\n  priority: 50,\n  defining: !0,\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (n) => {\n          if (typeof n == \"string\")\n            return !1;\n          const t = {};\n          for (const [e, o] of Object.entries($o))\n            n.getAttribute(o) && (t[e] = n.getAttribute(o));\n          return n.getAttribute(\"data-node-type\") === \"blockContainer\" ? t : !1;\n        }\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var r;\n    const t = document.createElement(\"div\");\n    t.className = \"bn-block-outer\", t.setAttribute(\"data-node-type\", \"blockOuter\");\n    for (const [i, s] of Object.entries(n))\n      i !== \"class\" && t.setAttribute(i, s);\n    const e = {\n      ...((r = this.options.domAttributes) == null ? void 0 : r.block) || {},\n      ...n\n    }, o = document.createElement(\"div\");\n    o.className = R(\"bn-block\", e.class), o.setAttribute(\"data-node-type\", this.name);\n    for (const [i, s] of Object.entries(e))\n      i !== \"class\" && o.setAttribute(i, s);\n    return t.appendChild(o), {\n      dom: t,\n      contentDOM: o\n    };\n  },\n  addCommands() {\n    return {\n      // Creates a new text block at a given position.\n      BNCreateBlock: (n) => ({ state: t, dispatch: e }) => {\n        const o = t.schema.nodes.blockContainer.createAndFill();\n        return e && t.tr.insert(n, o), !0;\n      },\n      // Deletes a block at a given position.\n      BNDeleteBlock: (n) => ({ state: t, dispatch: e }) => {\n        const o = b(t.doc, n);\n        if (o === void 0)\n          return !1;\n        const { startPos: r, endPos: i } = o;\n        return e && t.tr.deleteRange(r, i), !0;\n      },\n      // Updates a block at a given position.\n      BNUpdateBlock: (n, t) => ({ state: e, dispatch: o }) => {\n        const r = b(e.doc, n);\n        if (r === void 0)\n          return !1;\n        const { startPos: i, endPos: s, node: a, contentNode: l } = r;\n        if (o) {\n          if (t.children !== void 0) {\n            const m = [];\n            for (const h of t.children)\n              m.push(\n                P(\n                  h,\n                  e.schema,\n                  this.options.editor.schema.styleSchema\n                )\n              );\n            a.childCount === 2 ? e.tr.replace(\n              i + l.nodeSize + 1,\n              s - 1,\n              new prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(m), 0, 0)\n            ) : e.tr.insert(\n              i + l.nodeSize,\n              e.schema.nodes.blockGroup.create({}, m)\n            );\n          }\n          const c = l.type.name, p = t.type || c;\n          let u = \"keep\";\n          if (t.content)\n            if (typeof t.content == \"string\")\n              u = [e.schema.text(t.content)];\n            else if (Array.isArray(t.content))\n              u = st(\n                t.content,\n                e.schema,\n                this.options.editor.schema.styleSchema\n              );\n            else if (t.content.type === \"tableContent\")\n              u = Gt(\n                t.content,\n                e.schema,\n                this.options.editor.schema.styleSchema\n              );\n            else\n              throw new N(t.content.type);\n          else {\n            const m = e.schema.nodes[c].spec.content, h = e.schema.nodes[p].spec.content;\n            m === \"\" || h !== m && (u = []);\n          }\n          u === \"keep\" ? e.tr.setNodeMarkup(\n            i,\n            t.type === void 0 ? void 0 : e.schema.nodes[t.type],\n            {\n              ...l.attrs,\n              ...t.props\n            }\n          ) : e.tr.replaceWith(\n            i,\n            s,\n            e.schema.nodes[p].create(\n              {\n                ...l.attrs,\n                ...t.props\n              },\n              u\n            )\n          ).setSelection(\n            e.schema.nodes[p].spec.content === \"\" ? new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.NodeSelection(e.tr.doc.resolve(i)) : e.schema.nodes[p].spec.content === \"inline*\" ? new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.TextSelection(e.tr.doc.resolve(i)) : (\n              // Need to offset the position as we have to get through the\n              // `tableRow` and `tableCell` nodes to get to the\n              // `tableParagraph` node we want to set the selection in.\n              new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.TextSelection(e.tr.doc.resolve(i + 4))\n            )\n          ), e.tr.setNodeMarkup(i - 1, void 0, {\n            ...a.attrs,\n            ...t.props\n          });\n        }\n        return !0;\n      },\n      // Appends the text contents of a block to the nearest previous block, given a position between them. Children of\n      // the merged block are moved out of it first, rather than also being merged.\n      //\n      // In the example below, the position passed into the function is between Block1 and Block2.\n      //\n      // Block1\n      //    Block2\n      // Block3\n      //    Block4\n      //        Block5\n      //\n      // Becomes:\n      //\n      // Block1\n      //    Block2Block3\n      // Block4\n      //     Block5\n      BNMergeBlocks: (n) => ({ state: t, dispatch: e }) => {\n        const o = t.doc.resolve(n + 1).node().type.name === \"blockContainer\", r = t.doc.resolve(n - 1).node().type.name === \"blockContainer\";\n        if (!o || !r)\n          return !1;\n        const i = b(\n          t.doc,\n          n + 1\n        ), { node: s, contentNode: a, startPos: l, endPos: c, depth: p } = i;\n        if (s.childCount === 2) {\n          const h = t.doc.resolve(\n            l + a.nodeSize + 1\n          ), f = t.doc.resolve(c - 1), y = h.blockRange(f);\n          e && t.tr.lift(y, p - 1);\n        }\n        let u = n - 1, m = b(t.doc, u);\n        for (; m.numChildBlocks > 0; )\n          if (u--, m = b(t.doc, u), m === void 0)\n            return !1;\n        return e && (e(\n          t.tr.deleteRange(l, l + a.nodeSize).replace(\n            u - 1,\n            l,\n            new prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Slice(a.content, 0, 0)\n          ).scrollIntoView()\n        ), t.tr.setSelection(\n          new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.TextSelection(t.doc.resolve(u - 1))\n        )), !0;\n      },\n      // Splits a block at a given position. Content after the position is moved to a new block below, at the same\n      // nesting level.\n      BNSplitBlock: (n, t) => ({ state: e, dispatch: o }) => {\n        const r = b(e.doc, n);\n        if (r === void 0)\n          return !1;\n        const { contentNode: i, contentType: s, startPos: a, endPos: l, depth: c } = r, p = e.doc.cut(a + 1, n), u = e.doc.cut(n, l - 1), m = e.schema.nodes.blockContainer.createAndFill(), h = l + 1, f = h + 2;\n        return o && (e.tr.insert(h, m), e.tr.replace(\n          f,\n          f + 1,\n          u.content.size > 0 ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Slice(\n            prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(u),\n            c + 2,\n            c + 2\n          ) : void 0\n        ), t && e.tr.setBlockType(\n          f,\n          f,\n          e.schema.node(s).type,\n          i.attrs\n        ), e.tr.setSelection(\n          new prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.TextSelection(e.doc.resolve(f))\n        ), e.tr.replace(\n          a + 1,\n          l - 1,\n          p.content.size > 0 ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Slice(\n            prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(p),\n            c + 2,\n            c + 2\n          ) : void 0\n        )), !0;\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [Fo(), zo()];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Backspace: () => this.editor.commands.first(({ commands: o }) => [\n        // Deletes the selection if it's not empty.\n        () => o.deleteSelection(),\n        // Undoes an input rule if one was triggered in the last editor state change.\n        () => o.undoInputRule(),\n        // Reverts block content type to a paragraph if the selection is at the start of the block.\n        () => o.command(({ state: r }) => {\n          const { contentType: i, startPos: s } = b(\n            r.doc,\n            r.selection.from\n          ), a = r.selection.from === s + 1, l = i.name === \"paragraph\";\n          return a && !l ? o.BNUpdateBlock(r.selection.from, {\n            type: \"paragraph\",\n            props: {}\n          }) : !1;\n        }),\n        // Removes a level of nesting if the block is indented if the selection is at the start of the block.\n        () => o.command(({ state: r }) => {\n          const { startPos: i } = b(\n            r.doc,\n            r.selection.from\n          );\n          return r.selection.from === i + 1 ? o.liftListItem(\"blockContainer\") : !1;\n        }),\n        // Merges block with the previous one if it isn't indented, isn't the first block in the doc, and the selection\n        // is at the start of the block.\n        () => o.command(({ state: r }) => {\n          const { depth: i, startPos: s } = b(\n            r.doc,\n            r.selection.from\n          ), a = r.selection.from === s + 1, l = r.selection.empty, c = s === 2, p = s - 1;\n          return !c && a && l && i === 2 ? o.BNMergeBlocks(p) : !1;\n        })\n      ]),\n      Delete: () => this.editor.commands.first(({ commands: o }) => [\n        // Deletes the selection if it's not empty.\n        () => o.deleteSelection(),\n        // Merges block with the next one (at the same nesting level or lower),\n        // if one exists, the block has no children, and the selection is at the\n        // end of the block.\n        () => o.command(({ state: r }) => {\n          const { node: i, depth: s, endPos: a } = b(\n            r.doc,\n            r.selection.from\n          ), l = a === r.doc.nodeSize - 4, c = r.selection.from === a - 1, p = r.selection.empty, u = i.childCount === 2;\n          if (!l && c && p && !u) {\n            let m = s, h = a + 2, f = r.doc.resolve(h).depth;\n            for (; f < m; )\n              m = f, h += 2, f = r.doc.resolve(h).depth;\n            return o.BNMergeBlocks(h - 1);\n          }\n          return !1;\n        })\n      ]),\n      Enter: () => this.editor.commands.first(({ commands: o }) => [\n        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start\n        // of the block.\n        () => o.command(({ state: r }) => {\n          const { node: i, depth: s } = b(\n            r.doc,\n            r.selection.from\n          ), a = r.selection.$anchor.parentOffset === 0, l = r.selection.anchor === r.selection.head, c = i.textContent.length === 0, p = s > 2;\n          return a && l && c && p ? o.liftListItem(\"blockContainer\") : !1;\n        }),\n        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also\n        // empty & at the start of the block.\n        () => o.command(({ state: r, chain: i }) => {\n          const { node: s, endPos: a } = b(\n            r.doc,\n            r.selection.from\n          ), l = r.selection.$anchor.parentOffset === 0, c = r.selection.anchor === r.selection.head, p = s.textContent.length === 0;\n          if (l && c && p) {\n            const u = a + 1, m = u + 2;\n            return i().BNCreateBlock(u).setTextSelection(m).run(), !0;\n          }\n          return !1;\n        }),\n        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also\n        // deletes the selection beforehand, if it's not empty.\n        () => o.command(({ state: r, chain: i }) => {\n          const { node: s } = b(\n            r.doc,\n            r.selection.from\n          ), a = r.selection.$anchor.parentOffset === 0;\n          return s.textContent.length === 0 ? !1 : (i().deleteSelection().BNSplitBlock(r.selection.from, a).run(), !0);\n        })\n      ]),\n      // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the\n      // editor since the browser will try to use tab for keyboard navigation.\n      Tab: () => (this.editor.commands.sinkListItem(\"blockContainer\"), !0),\n      \"Shift-Tab\": () => (this.editor.commands.liftListItem(\"blockContainer\"), !0)\n    };\n  }\n}), jo = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Node.create({\n  name: \"blockGroup\",\n  group: \"blockGroup\",\n  content: \"blockContainer+\",\n  parseHTML() {\n    return [\n      {\n        tag: \"div\",\n        getAttrs: (n) => typeof n == \"string\" ? !1 : n.getAttribute(\"data-node-type\") === \"blockGroup\" ? null : !1\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes: n }) {\n    var o;\n    const t = {\n      ...((o = this.options.domAttributes) == null ? void 0 : o.blockGroup) || {},\n      ...n\n    }, e = document.createElement(\"div\");\n    e.className = R(\n      \"bn-block-group\",\n      t.class\n    ), e.setAttribute(\"data-node-type\", \"blockGroup\");\n    for (const [r, i] of Object.entries(t))\n      r !== \"class\" && e.setAttribute(r, i);\n    return {\n      dom: e,\n      contentDOM: e\n    };\n  }\n}), Wo = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Node.create({\n  name: \"doc\",\n  topNode: !0,\n  content: \"blockGroup\"\n}), qo = (n) => {\n  var e;\n  const t = [\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.extensions.ClipboardTextSerializer,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.extensions.Commands,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.extensions.Editable,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.extensions.FocusEvents,\n    _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.extensions.Tabindex,\n    // DevTools,\n    _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_12__.Gapcursor,\n    // DropCursor,\n    Do.configure({\n      // TODO: This shorthand is kind of ugly\n      ...n.placeholders !== void 0 ? { placeholders: n.placeholders } : {}\n    }),\n    Q.configure({\n      types: [\"blockContainer\"]\n    }),\n    _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_13__.HardBreak,\n    // Comments,\n    // basics:\n    _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_16__.Text,\n    // marks:\n    _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_15__.Link,\n    ...Object.values(n.styleSpecs).map((o) => o.implementation.mark),\n    _o,\n    Ho,\n    Oo,\n    // nodes\n    Wo,\n    Go.configure({\n      editor: n.editor,\n      domAttributes: n.domAttributes\n    }),\n    jo.configure({\n      domAttributes: n.domAttributes\n    }),\n    ...Object.values(n.inlineContentSpecs).filter((o) => o.config !== \"link\" && o.config !== \"text\").map((o) => o.implementation.node.configure({\n      editor: n.editor\n    })),\n    ...Object.values(n.blockSpecs).flatMap((o) => [\n      // dependent nodes (e.g.: tablecell / row)\n      ...(o.implementation.requiredExtensions || []).map(\n        (r) => r.configure({\n          editor: n.editor,\n          domAttributes: n.domAttributes\n        })\n      ),\n      // the actual node itself\n      o.implementation.node.configure({\n        editor: n.editor,\n        domAttributes: n.domAttributes\n      })\n    ]),\n    Lo(n.editor),\n    Ao(n.editor),\n    _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_11__.Dropcursor.configure({ width: 5, color: \"#ddeeff\" }),\n    // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),\n    // should be handled before Enter handlers in other components like splitListItem\n    Uo\n  ];\n  if (n.collaboration) {\n    if (t.push(\n      _tiptap_extension_collaboration__WEBPACK_IMPORTED_MODULE_9__[\"default\"].configure({\n        fragment: n.collaboration.fragment\n      })\n    ), (e = n.collaboration.provider) != null && e.awareness) {\n      const o = (r) => {\n        const i = document.createElement(\"span\");\n        i.classList.add(\"collaboration-cursor__caret\"), i.setAttribute(\"style\", `border-color: ${r.color}`);\n        const s = document.createElement(\"span\");\n        s.classList.add(\"collaboration-cursor__label\"), s.setAttribute(\"style\", `background-color: ${r.color}`), s.insertBefore(document.createTextNode(r.name), null);\n        const a = document.createTextNode(\"⁠\"), l = document.createTextNode(\"⁠\");\n        return i.insertBefore(a, null), i.insertBefore(s, null), i.insertBefore(l, null), i;\n      };\n      t.push(\n        _tiptap_extension_collaboration_cursor__WEBPACK_IMPORTED_MODULE_10__[\"default\"].configure({\n          user: n.collaboration.user,\n          render: n.collaboration.renderCursor || o,\n          provider: n.collaboration.provider\n        })\n      );\n    }\n  } else\n    t.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_14__.History);\n  return t;\n};\nfunction Ko(n, t) {\n  const e = [];\n  return n.forEach((o, r, i) => {\n    i !== t && e.push(o);\n  }), prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(e);\n}\nfunction Jo(n, t) {\n  let e = prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Fragment.from(n.content);\n  for (let o = 0; o < e.childCount; o++)\n    if (e.child(o).type.spec.group === \"blockContent\") {\n      const r = [e.child(o)];\n      if (o + 1 < e.childCount && e.child(o + 1).type.spec.group === \"blockGroup\") {\n        const s = e.child(o + 1).child(0).child(0);\n        (s.type.name === \"bulletListItem\" || s.type.name === \"numberedListItem\") && (r.push(e.child(o + 1)), e = Ko(e, o + 1));\n      }\n      const i = t.state.schema.nodes.blockContainer.create(\n        void 0,\n        r\n      );\n      e = e.replaceChild(o, i);\n    }\n  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Slice(e, n.openStart, n.openEnd);\n}\nclass Tt {\n  constructor(t) {\n    d(this, \"blockSpecs\");\n    d(this, \"inlineContentSpecs\");\n    d(this, \"styleSpecs\");\n    d(this, \"blockSchema\");\n    d(this, \"inlineContentSchema\");\n    d(this, \"styleSchema\");\n    // Helper so that you can use typeof schema.BlockNoteEditor\n    d(this, \"BlockNoteEditor\", \"only for types\");\n    d(this, \"Block\", \"only for types\");\n    d(this, \"PartialBlock\", \"only for types\");\n    this.blockSpecs = (t == null ? void 0 : t.blockSpecs) || oe, this.inlineContentSpecs = (t == null ? void 0 : t.inlineContentSpecs) || ie, this.styleSpecs = (t == null ? void 0 : t.styleSpecs) || re, this.blockSchema = Zt(this.blockSpecs), this.inlineContentSchema = te(\n      this.inlineContentSpecs\n    ), this.styleSchema = ne(this.styleSpecs);\n  }\n  static create(t) {\n    return new Tt(t);\n  }\n}\nclass Xo extends _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Editor {\n  constructor(e, o) {\n    super({ ...e, content: void 0 });\n    d(this, \"_state\");\n    /**\n     * Mounts / unmounts the editor to a dom element\n     *\n     * @param element DOM element to mount to, ur null / undefined to destroy\n     */\n    d(this, \"mount\", (e) => {\n      e ? (this.options.element = e, this.createViewAlternative()) : this.destroy();\n    });\n    const r = this.schema;\n    let i;\n    const s = r.nodes.doc.createAndFill;\n    r.nodes.doc.createAndFill = (...l) => {\n      if (i)\n        return i;\n      const c = s.apply(r.nodes.doc, l), p = JSON.parse(JSON.stringify(c.toJSON()));\n      return p.content[0].content[0].attrs.id = \"initialBlockId\", i = prosemirror_model__WEBPACK_IMPORTED_MODULE_20__.Node.fromJSON(r, p), i;\n    };\n    let a;\n    try {\n      const l = e == null ? void 0 : e.content.map(\n        (c) => P(c, this.schema, o).toJSON()\n      );\n      a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_17__.createDocument)(\n        {\n          type: \"doc\",\n          content: [\n            {\n              type: \"blockGroup\",\n              content: l\n            }\n          ]\n        },\n        this.schema,\n        this.options.parseOptions\n      );\n    } catch (l) {\n      throw console.error(\n        \"Error creating document from blocks passed as `initialContent`. Caused by exception: \",\n        l\n      ), new Error(\n        \"Error creating document from blocks passed as `initialContent`:\\n\" + +JSON.stringify(e.content)\n      );\n    }\n    this._state = prosemirror_state__WEBPACK_IMPORTED_MODULE_19__.EditorState.create({\n      doc: a,\n      schema: this.schema\n      // selection: selection || undefined,\n    });\n  }\n  get state() {\n    return this.view && (this._state = this.view.state), this._state;\n  }\n  createView() {\n  }\n  /**\n   * Replace the default `createView` method with a custom one - which we call on mount\n   */\n  createViewAlternative() {\n    queueMicrotask(() => {\n      this.view = new prosemirror_view__WEBPACK_IMPORTED_MODULE_31__.EditorView(this.options.element, {\n        ...this.options.editorProps,\n        // @ts-ignore\n        dispatchTransaction: this.dispatchTransaction.bind(this),\n        state: this.state\n      });\n      const e = this.state.reconfigure({\n        plugins: this.extensionManager.plugins\n      });\n      this.view.updateState(e), this.createNodeViews();\n    });\n  }\n}\nconst Yo = {\n  enableInputRules: !0,\n  enablePasteRules: !0,\n  enableCoreExtensions: !1\n};\nclass de {\n  constructor(t) {\n    d(this, \"_tiptapEditor\");\n    d(this, \"blockCache\", /* @__PURE__ */ new WeakMap());\n    d(this, \"schema\");\n    d(this, \"blockImplementations\");\n    d(this, \"inlineContentImplementations\");\n    d(this, \"styleImplementations\");\n    d(this, \"formattingToolbar\");\n    d(this, \"hyperlinkToolbar\");\n    d(this, \"sideMenu\");\n    d(this, \"suggestionMenus\");\n    d(this, \"imageToolbar\");\n    d(this, \"tableHandles\");\n    d(this, \"uploadFile\");\n    var l, c, p, u, m, h, f, y;\n    this.options = t;\n    const e = t;\n    if (e.onEditorContentChange)\n      throw new Error(\n        \"onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)\"\n      );\n    if (e.onTextCursorPositionChange)\n      throw new Error(\n        \"onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)\"\n      );\n    if (e.onEditorReady)\n      throw new Error(\n        \"onEditorReady is deprecated. Editor is immediately ready for use after creation.\"\n      );\n    if (e.editable)\n      throw new Error(\n        \"editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false\"\n      );\n    const o = {\n      defaultStyles: !0,\n      schema: t.schema || Tt.create(),\n      ...t\n    };\n    this.schema = o.schema, this.blockImplementations = o.schema.blockSpecs, this.inlineContentImplementations = o.schema.inlineContentSpecs, this.styleImplementations = o.schema.styleSpecs, this.formattingToolbar = new co(this), this.hyperlinkToolbar = new ho(this), this.sideMenu = new Co(this), this.suggestionMenus = new yo(this), L(\"image\", this) && (this.imageToolbar = new fo(this)), L(\"table\", this) && (this.tableHandles = new Io(this));\n    const r = qo({\n      editor: this,\n      placeholders: o.placeholders,\n      domAttributes: o.domAttributes || {},\n      blockSchema: this.schema.blockSchema,\n      blockSpecs: this.schema.blockSpecs,\n      styleSpecs: this.schema.styleSpecs,\n      inlineContentSpecs: this.schema.inlineContentSpecs,\n      collaboration: o.collaboration\n    }), i = _tiptap_core__WEBPACK_IMPORTED_MODULE_17__.Extension.create({\n      name: \"BlockNoteUIExtension\",\n      addProseMirrorPlugins: () => [\n        this.formattingToolbar.plugin,\n        this.hyperlinkToolbar.plugin,\n        this.sideMenu.plugin,\n        this.suggestionMenus.plugin,\n        ...this.imageToolbar ? [this.imageToolbar.plugin] : [],\n        ...this.tableHandles ? [this.tableHandles.plugin] : []\n      ]\n    });\n    r.push(i), this.uploadFile = o.uploadFile, o.collaboration && o.initialContent && console.warn(\n      \"When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider\"\n    );\n    const s = o.initialContent || (t.collaboration ? [\n      {\n        type: \"paragraph\",\n        id: \"initialBlockId\"\n      }\n    ] : [\n      {\n        type: \"paragraph\",\n        id: Q.options.generateID()\n      }\n    ]);\n    if (!Array.isArray(s) || s.length === 0)\n      throw new Error(\n        \"initialContent must be a non-empty array of blocks, received: \" + s\n      );\n    const a = {\n      ...Yo,\n      ...o._tiptapOptions,\n      content: s,\n      extensions: o.enableBlockNoteExtensions === !1 ? ((l = o._tiptapOptions) == null ? void 0 : l.extensions) || [] : [...((c = o._tiptapOptions) == null ? void 0 : c.extensions) || [], ...r],\n      editorProps: {\n        ...(p = o._tiptapOptions) == null ? void 0 : p.editorProps,\n        attributes: {\n          ...(m = (u = o._tiptapOptions) == null ? void 0 : u.editorProps) == null ? void 0 : m.attributes,\n          ...(h = o.domAttributes) == null ? void 0 : h.editor,\n          class: R(\n            \"bn-editor\",\n            o.defaultStyles ? \"bn-default-styles\" : \"\",\n            ((y = (f = o.domAttributes) == null ? void 0 : f.editor) == null ? void 0 : y.class) || \"\"\n          )\n        },\n        transformPasted: Jo\n      }\n    };\n    this._tiptapEditor = new Xo(\n      a,\n      this.schema.styleSchema\n    );\n  }\n  static create(t = {}) {\n    return new de(t);\n  }\n  /**\n   * Mount the editor to a parent DOM element. Call mount(undefined) to clean up\n   *\n   * @warning Not needed for React, use BlockNoteView to take care of this\n   */\n  mount(t) {\n    this._tiptapEditor.mount(t);\n  }\n  get prosemirrorView() {\n    return this._tiptapEditor.view;\n  }\n  get domElement() {\n    return this._tiptapEditor.view.dom;\n  }\n  isFocused() {\n    return this._tiptapEditor.view.hasFocus();\n  }\n  focus() {\n    this._tiptapEditor.view.focus();\n  }\n  /**\n   * @deprecated, use `editor.document` instead\n   */\n  get topLevelBlocks() {\n    return this.topLevelBlocks;\n  }\n  /**\n   * Gets a snapshot of all top-level (non-nested) blocks in the editor.\n   * @returns A snapshot of all top-level (non-nested) blocks in the editor.\n   */\n  get document() {\n    const t = [];\n    return this._tiptapEditor.state.doc.firstChild.descendants((e) => (t.push(\n      k(\n        e,\n        this.schema.blockSchema,\n        this.schema.inlineContentSchema,\n        this.schema.styleSchema,\n        this.blockCache\n      )\n    ), !1)), t;\n  }\n  /**\n   * Gets a snapshot of an existing block from the editor.\n   * @param blockIdentifier The identifier of an existing block that should be retrieved.\n   * @returns The block that matches the identifier, or `undefined` if no matching block was found.\n   */\n  getBlock(t) {\n    const e = typeof t == \"string\" ? t : t.id;\n    let o;\n    return this._tiptapEditor.state.doc.firstChild.descendants((r) => typeof o < \"u\" ? !1 : r.type.name !== \"blockContainer\" || r.attrs.id !== e ? !0 : (o = k(\n      r,\n      this.schema.blockSchema,\n      this.schema.inlineContentSchema,\n      this.schema.styleSchema,\n      this.blockCache\n    ), !1)), o;\n  }\n  /**\n   * Traverses all blocks in the editor depth-first, and executes a callback for each.\n   * @param callback The callback to execute for each block. Returning `false` stops the traversal.\n   * @param reverse Whether the blocks should be traversed in reverse order.\n   */\n  forEachBlock(t, e = !1) {\n    const o = this.document.slice();\n    e && o.reverse();\n    function r(i) {\n      for (const s of i) {\n        if (!t(s))\n          return !1;\n        const a = e ? s.children.slice().reverse() : s.children;\n        if (!r(a))\n          return !1;\n      }\n      return !0;\n    }\n    r(o);\n  }\n  /**\n   * Executes a callback whenever the editor's contents change.\n   * @param callback The callback to execute.\n   */\n  onEditorContentChange(t) {\n    this._tiptapEditor.on(\"update\", t);\n  }\n  /**\n   * Executes a callback whenever the editor's selection changes.\n   * @param callback The callback to execute.\n   */\n  onEditorSelectionChange(t) {\n    this._tiptapEditor.on(\"selectionUpdate\", t);\n  }\n  /**\n   * Gets a snapshot of the current text cursor position.\n   * @returns A snapshot of the current text cursor position.\n   */\n  getTextCursorPosition() {\n    const { node: t, depth: e, startPos: o, endPos: r } = b(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    ), i = this._tiptapEditor.state.doc.resolve(r).index(e - 1), s = this._tiptapEditor.state.doc.resolve(r + 1).node().childCount;\n    let a;\n    i > 0 && (a = this._tiptapEditor.state.doc.resolve(o - 2).node());\n    let l;\n    return i < s - 1 && (l = this._tiptapEditor.state.doc.resolve(r + 2).node()), {\n      block: k(\n        t,\n        this.schema.blockSchema,\n        this.schema.inlineContentSchema,\n        this.schema.styleSchema,\n        this.blockCache\n      ),\n      prevBlock: a === void 0 ? void 0 : k(\n        a,\n        this.schema.blockSchema,\n        this.schema.inlineContentSchema,\n        this.schema.styleSchema,\n        this.blockCache\n      ),\n      nextBlock: l === void 0 ? void 0 : k(\n        l,\n        this.schema.blockSchema,\n        this.schema.inlineContentSchema,\n        this.schema.styleSchema,\n        this.blockCache\n      )\n    };\n  }\n  /**\n   * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could\n   * not be found.\n   * @param targetBlock The identifier of an existing block that the text cursor should be moved to.\n   * @param placement Whether the text cursor should be placed at the start or end of the block.\n   */\n  setTextCursorPosition(t, e = \"start\") {\n    const o = typeof t == \"string\" ? t : t.id, { posBeforeNode: r } = Et(o, this._tiptapEditor.state.doc), { startPos: i, contentNode: s } = b(\n      this._tiptapEditor.state.doc,\n      r + 2\n    ), a = this.schema.blockSchema[s.type.name].content;\n    if (a === \"none\") {\n      this._tiptapEditor.commands.setNodeSelection(i);\n      return;\n    }\n    if (a === \"inline\")\n      e === \"start\" ? this._tiptapEditor.commands.setTextSelection(i + 1) : this._tiptapEditor.commands.setTextSelection(\n        i + s.nodeSize - 1\n      );\n    else if (a === \"table\")\n      e === \"start\" ? this._tiptapEditor.commands.setTextSelection(i + 4) : this._tiptapEditor.commands.setTextSelection(\n        i + s.nodeSize - 4\n      );\n    else\n      throw new N(a);\n  }\n  /**\n   * Gets a snapshot of the current selection.\n   */\n  getSelection() {\n    if (this._tiptapEditor.state.selection.from === this._tiptapEditor.state.selection.to || \"node\" in this._tiptapEditor.state.selection)\n      return;\n    const t = [];\n    return this._tiptapEditor.state.doc.descendants((e, o) => e.type.spec.group !== \"blockContent\" || o + e.nodeSize < this._tiptapEditor.state.selection.from || o > this._tiptapEditor.state.selection.to ? !0 : (t.push(\n      k(\n        this._tiptapEditor.state.doc.resolve(o).node(),\n        this.schema.blockSchema,\n        this.schema.inlineContentSchema,\n        this.schema.styleSchema,\n        this.blockCache\n      )\n    ), !1)), { blocks: t };\n  }\n  /**\n   * Checks if the editor is currently editable, or if it's locked.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  get isEditable() {\n    return this._tiptapEditor.isEditable;\n  }\n  /**\n   * Makes the editor editable or locks it, depending on the argument passed.\n   * @param editable True to make the editor editable, or false to lock it.\n   */\n  set isEditable(t) {\n    this._tiptapEditor.setEditable(t);\n  }\n  /**\n   * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an\n   * error if the reference block could not be found.\n   * @param blocksToInsert An array of partial blocks that should be inserted.\n   * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.\n   * @param placement Whether the blocks should be inserted just before, just after, or nested inside the\n   * `referenceBlock`. Inserts the blocks at the start of the existing block's children if \"nested\" is used.\n   */\n  insertBlocks(t, e, o = \"before\") {\n    return qn(t, e, o, this);\n  }\n  /**\n   * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be\n   * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could\n   * not be found.\n   * @param blockToUpdate The block that should be updated.\n   * @param update A partial block which defines how the existing block should be changed.\n   */\n  updateBlock(t, e) {\n    return Kn(t, e, this);\n  }\n  /**\n   * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.\n   * @param blocksToRemove An array of identifiers for existing blocks that should be removed.\n   */\n  removeBlocks(t) {\n    return Jn(t, this);\n  }\n  /**\n   * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or\n   * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in\n   * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.\n   * @param blocksToRemove An array of blocks that should be replaced.\n   * @param blocksToInsert An array of partial blocks to replace the old ones with.\n   */\n  replaceBlocks(t, e) {\n    return Xn(t, e, this);\n  }\n  /**\n   * Insert a piece of content at the current cursor position.\n   *\n   * @param content can be a string, or array of partial inline content elements\n   */\n  insertInlineContent(t) {\n    const e = st(\n      t,\n      this._tiptapEditor.schema,\n      this.schema.styleSchema\n    );\n    Yn(\n      {\n        from: this._tiptapEditor.state.selection.from,\n        to: this._tiptapEditor.state.selection.to\n      },\n      e,\n      this\n    );\n  }\n  /**\n   * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.\n   */\n  getActiveStyles() {\n    const t = {}, e = this._tiptapEditor.state.selection.$to.marks();\n    for (const o of e) {\n      const r = this.schema.styleSchema[o.type.name];\n      if (!r) {\n        console.warn(\"mark not found in styleschema\", o.type.name);\n        continue;\n      }\n      r.propSchema === \"boolean\" ? t[r.type] = !0 : t[r.type] = o.attrs.stringValue;\n    }\n    return t;\n  }\n  /**\n   * Adds styles to the currently selected content.\n   * @param styles The styles to add.\n   */\n  addStyles(t) {\n    this._tiptapEditor.view.focus();\n    for (const [e, o] of Object.entries(t)) {\n      const r = this.schema.styleSchema[e];\n      if (!r)\n        throw new Error(`style ${e} not found in styleSchema`);\n      if (r.propSchema === \"boolean\")\n        this._tiptapEditor.commands.setMark(e);\n      else if (r.propSchema === \"string\")\n        this._tiptapEditor.commands.setMark(e, { stringValue: o });\n      else\n        throw new N(r.propSchema);\n    }\n  }\n  /**\n   * Removes styles from the currently selected content.\n   * @param styles The styles to remove.\n   */\n  removeStyles(t) {\n    this._tiptapEditor.view.focus();\n    for (const e of Object.keys(t))\n      this._tiptapEditor.commands.unsetMark(e);\n  }\n  /**\n   * Toggles styles on the currently selected content.\n   * @param styles The styles to toggle.\n   */\n  toggleStyles(t) {\n    this._tiptapEditor.view.focus();\n    for (const [e, o] of Object.entries(t)) {\n      const r = this.schema.styleSchema[e];\n      if (!r)\n        throw new Error(`style ${e} not found in styleSchema`);\n      if (r.propSchema === \"boolean\")\n        this._tiptapEditor.commands.toggleMark(e);\n      else if (r.propSchema === \"string\")\n        this._tiptapEditor.commands.toggleMark(e, { stringValue: o });\n      else\n        throw new N(r.propSchema);\n    }\n  }\n  /**\n   * Gets the currently selected text.\n   */\n  getSelectedText() {\n    return this._tiptapEditor.state.doc.textBetween(\n      this._tiptapEditor.state.selection.from,\n      this._tiptapEditor.state.selection.to\n    );\n  }\n  /**\n   * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.\n   */\n  getSelectedLinkUrl() {\n    return this._tiptapEditor.getAttributes(\"link\").href;\n  }\n  /**\n   * Creates a new link to replace the selected content.\n   * @param url The link URL.\n   * @param text The text to display the link with.\n   */\n  createLink(t, e) {\n    if (t === \"\")\n      return;\n    const { from: o, to: r } = this._tiptapEditor.state.selection;\n    e || (e = this._tiptapEditor.state.doc.textBetween(o, r));\n    const i = this._tiptapEditor.schema.mark(\"link\", { href: t });\n    this._tiptapEditor.view.dispatch(\n      this._tiptapEditor.view.state.tr.insertText(e, o, r).addMark(o, o + e.length, i)\n    );\n  }\n  /**\n   * Checks if the block containing the text cursor can be nested.\n   */\n  canNestBlock() {\n    const { startPos: t, depth: e } = b(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    );\n    return this._tiptapEditor.state.doc.resolve(t).index(e - 1) > 0;\n  }\n  /**\n   * Nests the block containing the text cursor into the block above it.\n   */\n  nestBlock() {\n    this._tiptapEditor.commands.sinkListItem(\"blockContainer\");\n  }\n  /**\n   * Checks if the block containing the text cursor is nested.\n   */\n  canUnnestBlock() {\n    const { depth: t } = b(\n      this._tiptapEditor.state.doc,\n      this._tiptapEditor.state.selection.from\n    );\n    return t > 2;\n  }\n  /**\n   * Lifts the block containing the text cursor out of its parent.\n   */\n  unnestBlock() {\n    this._tiptapEditor.commands.liftListItem(\"blockContainer\");\n  }\n  // TODO: Fix when implementing HTML/Markdown import & export\n  /**\n   * Serializes blocks into an HTML string. To better conform to HTML standards, children of blocks which aren't list\n   * items are un-nested in the output HTML.\n   * @param blocks An array of blocks that should be serialized into HTML.\n   * @returns The blocks, serialized as an HTML string.\n   */\n  async blocksToHTMLLossy(t = this.document) {\n    return at(\n      this._tiptapEditor.schema,\n      this\n    ).exportBlocks(t);\n  }\n  /**\n   * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and\n   * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote\n   * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.\n   * @param html The HTML string to parse blocks from.\n   * @returns The blocks parsed from the HTML string.\n   */\n  async tryParseHTMLToBlocks(t) {\n    return le(\n      t,\n      this.schema.blockSchema,\n      this.schema.inlineContentSchema,\n      this.schema.styleSchema,\n      this._tiptapEditor.schema\n    );\n  }\n  /**\n   * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of\n   * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.\n   * @param blocks An array of blocks that should be serialized into Markdown.\n   * @returns The blocks, serialized as a Markdown string.\n   */\n  async blocksToMarkdownLossy(t = this.document) {\n    return Zn(t, this._tiptapEditor.schema, this);\n  }\n  /**\n   * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on\n   * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it\n   * as text.\n   * @param markdown The Markdown string to parse blocks from.\n   * @returns The blocks parsed from the Markdown string.\n   */\n  async tryParseMarkdownToBlocks(t) {\n    return so(\n      t,\n      this.schema.blockSchema,\n      this.schema.inlineContentSchema,\n      this.schema.styleSchema,\n      this._tiptapEditor.schema\n    );\n  }\n  /**\n   * Updates the user info for the current user that's shown to other collaborators.\n   */\n  updateCollaborationUserInfo(t) {\n    if (!this.options.collaboration)\n      throw new Error(\n        \"Cannot update collaboration user info when collaboration is disabled.\"\n      );\n    this._tiptapEditor.commands.updateUser(t);\n  }\n  /**\n   * A callback function that runs whenever the editor's contents change.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  onChange(t) {\n    const e = () => {\n      t(this);\n    };\n    return this._tiptapEditor.on(\"update\", e), () => {\n      this._tiptapEditor.off(\"update\", e);\n    };\n  }\n  /**\n   * A callback function that runs whenever the text cursor position or selection changes.\n   *\n   * @param callback The callback to execute.\n   * @returns A function to remove the callback.\n   */\n  onSelectionChange(t) {\n    const e = () => {\n      t(this);\n    };\n    return this._tiptapEditor.on(\"selectionUpdate\", e), () => {\n      this._tiptapEditor.off(\"selectionUpdate\", e);\n    };\n  }\n}\nfunction Qo(n) {\n  let t = n.getTextCursorPosition().block, e = n.schema.blockSchema[t.type].content;\n  for (; e === \"none\"; )\n    t = n.getTextCursorPosition().nextBlock, e = n.schema.blockSchema[t.type].content, n.setTextCursorPosition(t, \"end\");\n}\nfunction A(n, t) {\n  const e = n.getTextCursorPosition().block;\n  if (e.content === void 0)\n    throw new Error(\"Slash Menu open in a block that doesn't contain content.\");\n  Array.isArray(e.content) && (e.content.length === 1 && Y(e.content[0]) && e.content[0].type === \"text\" && e.content[0].text === \"/\" || e.content.length === 0) ? n.updateBlock(e, t) : (n.insertBlocks([t], e, \"after\"), n.setTextCursorPosition(\n    n.getTextCursorPosition().nextBlock,\n    \"end\"\n  ));\n  const o = n.getTextCursorPosition().block;\n  return Qo(n), o;\n}\nfunction Fr(n) {\n  const t = [];\n  return L(\"heading\", n) && t.push(\n    {\n      title: \"Heading 1\",\n      onItemClick: () => {\n        A(n, {\n          type: \"heading\",\n          props: { level: 1 }\n        });\n      },\n      subtext: \"Used for a top-level heading\",\n      badge: V(\"Mod-Alt-1\"),\n      aliases: [\"h\", \"heading1\", \"h1\"],\n      group: \"Headings\"\n    },\n    {\n      title: \"Heading 2\",\n      onItemClick: () => {\n        A(n, {\n          type: \"heading\",\n          props: { level: 2 }\n        });\n      },\n      subtext: \"Used for key sections\",\n      badge: V(\"Mod-Alt-2\"),\n      aliases: [\"h2\", \"heading2\", \"subheading\"],\n      group: \"Headings\"\n    },\n    {\n      title: \"Heading 3\",\n      onItemClick: () => {\n        A(n, {\n          type: \"heading\",\n          props: { level: 3 }\n        });\n      },\n      subtext: \"Used for subsections and group headings\",\n      badge: V(\"Mod-Alt-3\"),\n      aliases: [\"h3\", \"heading3\", \"subheading\"],\n      group: \"Headings\"\n    }\n  ), L(\"numberedListItem\", n) && t.push({\n    title: \"Numbered List\",\n    onItemClick: () => {\n      A(n, {\n        type: \"numberedListItem\"\n      });\n    },\n    subtext: \"Used to display a numbered list\",\n    badge: V(\"Mod-Shift-7\"),\n    aliases: [\"ol\", \"li\", \"list\", \"numberedlist\", \"numbered list\"],\n    group: \"Basic blocks\"\n  }), L(\"bulletListItem\", n) && t.push({\n    title: \"Bullet List\",\n    onItemClick: () => {\n      A(n, {\n        type: \"bulletListItem\"\n      });\n    },\n    subtext: \"Used to display an unordered list\",\n    badge: V(\"Mod-Shift-8\"),\n    aliases: [\"ul\", \"li\", \"list\", \"bulletlist\", \"bullet list\"],\n    group: \"Basic blocks\"\n  }), L(\"paragraph\", n) && t.push({\n    title: \"Paragraph\",\n    onItemClick: () => {\n      A(n, {\n        type: \"paragraph\"\n      });\n    },\n    subtext: \"Used for the body of your document\",\n    badge: V(\"Mod-Alt-0\"),\n    aliases: [\"p\", \"paragraph\"],\n    group: \"Basic blocks\"\n  }), L(\"table\", n) && t.push({\n    title: \"Table\",\n    onItemClick: () => {\n      A(n, {\n        type: \"table\",\n        content: {\n          type: \"tableContent\",\n          rows: [\n            {\n              cells: [\"\", \"\", \"\"]\n            },\n            {\n              cells: [\"\", \"\", \"\"]\n            }\n          ]\n        }\n      });\n    },\n    subtext: \"Used for for tables\",\n    aliases: [\"table\"],\n    group: \"Advanced\",\n    badge: void 0\n  }), L(\"image\", n) && t.push({\n    title: \"Image\",\n    onItemClick: () => {\n      const e = A(n, {\n        type: \"image\"\n      });\n      n.prosemirrorView.dispatch(\n        n._tiptapEditor.state.tr.setMeta(n.imageToolbar.plugin, {\n          block: e\n        })\n      );\n    },\n    subtext: \"Insert an image\",\n    aliases: [\n      \"image\",\n      \"imageUpload\",\n      \"upload\",\n      \"img\",\n      \"picture\",\n      \"media\",\n      \"url\",\n      \"drive\",\n      \"dropbox\"\n    ],\n    group: \"Media\"\n  }), t;\n}\nfunction $r(n, t) {\n  return n.filter(\n    ({ title: e, aliases: o }) => e.toLowerCase().startsWith(t.toLowerCase()) || o && o.filter(\n      (r) => r.toLowerCase().startsWith(t.toLowerCase())\n    ).length !== 0\n  );\n}\nfunction ht(n = \"\") {\n  return typeof n == \"string\" ? [\n    {\n      type: \"text\",\n      text: n,\n      styles: {}\n    }\n  ] : n;\n}\nfunction pe(n) {\n  return typeof n == \"string\" ? ht(n) : Array.isArray(n) ? n.flatMap((t) => typeof t == \"string\" ? ht(t) : $t(t) ? {\n    ...t,\n    content: ht(t.content)\n  } : Y(t) ? t : {\n    props: {},\n    ...t,\n    content: pe(t.content)\n  }) : n;\n}\nfunction Gr(n, t) {\n  return t.map(\n    (e) => ue(n, e)\n  );\n}\nfunction ue(n, t) {\n  const e = {\n    id: \"\",\n    type: t.type,\n    props: {},\n    content: n[t.type].content === \"inline\" ? [] : void 0,\n    children: [],\n    ...t\n  };\n  return Object.entries(n[t.type].propSchema).forEach(\n    ([o, r]) => {\n      e.props[o] === void 0 && (e.props[o] = r.default);\n    }\n  ), {\n    ...e,\n    content: pe(e.content),\n    children: e.children.map((o) => ue(n, o))\n  };\n}\nfunction Zo(n) {\n  n.id || (n.id = Q.options.generateID()), n.children && tr(n.children);\n}\nfunction tr(n) {\n  for (const t of n)\n    Zo(t);\n}\n\n//# sourceMappingURL=blocknote.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9jb3JlL2Rpc3QvYmxvY2tub3RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ2dIO0FBQ2xGO0FBQ0k7QUFDTTtBQUNpWTtBQUMzUjtBQUM5RztBQUNtQjtBQUNYO0FBQ0E7QUFDRTtBQUNBO0FBQ0c7QUFDa0I7QUFDSTtBQUNOO0FBQ2lCO0FBQy9DO0FBQ0g7QUFDTTtBQUNKO0FBQzRCO0FBQytCO0FBQ3hDO0FBQ087QUFDUTtBQUNGO0FBQ0M7QUFDTDtBQUNOO0FBQ0E7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQUM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQUU7QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMkJBQTJCO0FBQ2hGO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtB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SUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJO0FBQzFJO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd1ZBQXdWLEdBQUcsMEVBQTBFLDJDQUEyQyx5QkFBeUIsRUFBRTtBQUMzZSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUE0QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtQkFBbUIseUNBQXlDLDhCQUE4QjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNCQUFzQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGFBQWE7QUFDYjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1GRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1ibG9ja25vdGUtYWR2YW5jZWQvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9jb3JlL2Rpc3QvYmxvY2tub3RlLmpzPzhkMjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGhlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIG1lID0gKG4sIHQsIGUpID0+IHQgaW4gbiA/IGhlKG4sIHQsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IGUgfSkgOiBuW3RdID0gZTtcbnZhciBkID0gKG4sIHQsIGUpID0+IChtZShuLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBlKSwgZSk7XG5pbXBvcnQgeyBTbGljZSBhcyBfLCBGcmFnbWVudCBhcyB4LCBET01TZXJpYWxpemVyIGFzIGd0LCBET01QYXJzZXIgYXMgZmUsIE5vZGUgYXMgZ2UgfSBmcm9tIFwicHJvc2VtaXJyb3ItbW9kZWxcIjtcbmltcG9ydCBSdCBmcm9tIFwicmVoeXBlLXBhcnNlXCI7XG5pbXBvcnQgenQgZnJvbSBcInJlaHlwZS1zdHJpbmdpZnlcIjtcbmltcG9ydCB7IHVuaWZpZWQgYXMgYnQgfSBmcm9tIFwidW5pZmllZFwiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uIGFzIE0sIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzIGFzIGJlLCBnZXRDaGFuZ2VkUmFuZ2VzIGFzIHllLCBmaW5kQ2hpbGRyZW5JblJhbmdlIGFzIGtlLCBOb2RlIGFzIGosIE1hcmsgYXMgeXQsIElucHV0UnVsZSBhcyBrdCwgY2FsbE9yUmV0dXJuIGFzIHdlLCBnZXRFeHRlbnNpb25GaWVsZCBhcyB2ZSwgbWVyZ2VBdHRyaWJ1dGVzIGFzIEVlLCBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCBhcyBTZSwgaXNOb2RlU2VsZWN0aW9uIGFzIENlLCBwb3NUb0RPTVJlY3QgYXMgbXQsIGdldE1hcmtSYW5nZSBhcyB4dCwgZmluZFBhcmVudE5vZGUgYXMgVGUsIGZpbmRDaGlsZHJlbiBhcyBNdCwgZXh0ZW5zaW9ucyBhcyBKLCBFZGl0b3IgYXMgeGUsIGNyZWF0ZURvY3VtZW50IGFzIE1lIH0gZnJvbSBcIkB0aXB0YXAvY29yZVwiO1xuaW1wb3J0IHsgUGx1Z2luIGFzIHYsIFBsdWdpbktleSBhcyBULCBTZWxlY3Rpb24gYXMgZHQsIE5vZGVTZWxlY3Rpb24gYXMgcnQsIFRleHRTZWxlY3Rpb24gYXMgbnQsIEVkaXRvclN0YXRlIGFzIEJlIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5pbXBvcnQgeyB2NCBhcyBJZSB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBmcm9tRG9tIGFzIEJ0IH0gZnJvbSBcImhhc3QtdXRpbC1mcm9tLWRvbVwiO1xuaW1wb3J0IExlIGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1ib2xkXCI7XG5pbXBvcnQgTmUgZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWNvZGVcIjtcbmltcG9ydCBBZSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taXRhbGljXCI7XG5pbXBvcnQgSGUgZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZVwiO1xuaW1wb3J0IFBlIGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi11bmRlcmxpbmVcIjtcbmltcG9ydCB7IFRhYmxlQ2VsbCBhcyBEZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi10YWJsZS1jZWxsXCI7XG5pbXBvcnQgeyBUYWJsZUhlYWRlciBhcyBPZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi10YWJsZS1oZWFkZXJcIjtcbmltcG9ydCB7IFRhYmxlUm93IGFzIF9lIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLXRhYmxlLXJvd1wiO1xuaW1wb3J0IHsgY29sdW1uUmVzaXppbmcgYXMgVWUsIHRhYmxlRWRpdGluZyBhcyBSZSB9IGZyb20gXCJwcm9zZW1pcnJvci10YWJsZXNcIjtcbmltcG9ydCB6ZSBmcm9tIFwicmVoeXBlLXJlbWFya1wiO1xuaW1wb3J0IFZ0IGZyb20gXCJyZW1hcmstZ2ZtXCI7XG5pbXBvcnQgVmUgZnJvbSBcInJlbWFyay1zdHJpbmdpZnlcIjtcbmltcG9ydCBGZSBmcm9tIFwicmVtYXJrLXBhcnNlXCI7XG5pbXBvcnQgJGUsIHsgZGVmYXVsdEhhbmRsZXJzIGFzIEdlIH0gZnJvbSBcInJlbWFyay1yZWh5cGVcIjtcbmltcG9ydCB7IERlY29yYXRpb25TZXQgYXMgJCwgRGVjb3JhdGlvbiBhcyBHLCBFZGl0b3JWaWV3IGFzIGplIH0gZnJvbSBcInByb3NlbWlycm9yLXZpZXdcIjtcbmltcG9ydCBXZSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvblwiO1xuaW1wb3J0IHFlIGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uLWN1cnNvclwiO1xuaW1wb3J0IHsgRHJvcGN1cnNvciBhcyBLZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yXCI7XG5pbXBvcnQgeyBHYXBjdXJzb3IgYXMgSmUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yXCI7XG5pbXBvcnQgeyBIYXJkQnJlYWsgYXMgWGUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVha1wiO1xuaW1wb3J0IHsgSGlzdG9yeSBhcyBZZSB9IGZyb20gXCJAdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5XCI7XG5pbXBvcnQgeyBMaW5rIGFzIFFlIH0gZnJvbSBcIkB0aXB0YXAvZXh0ZW5zaW9uLWxpbmtcIjtcbmltcG9ydCB7IFRleHQgYXMgWmUgfSBmcm9tIFwiQHRpcHRhcC9leHRlbnNpb24tdGV4dFwiO1xuZnVuY3Rpb24gdG4obiwgdCA9IEpTT04uc3RyaW5naWZ5KSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgcmV0dXJuIG4uZmlsdGVyKChvKSA9PiB7XG4gICAgY29uc3QgciA9IHQobyk7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCByKSA/ICExIDogZVtyXSA9ICEwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVuKG4pIHtcbiAgY29uc3QgdCA9IG4uZmlsdGVyKFxuICAgIChvLCByKSA9PiBuLmluZGV4T2YobykgIT09IHJcbiAgKTtcbiAgcmV0dXJuIHRuKHQpO1xufVxuY29uc3QgUSA9IE0uY3JlYXRlKHtcbiAgbmFtZTogXCJ1bmlxdWVJRFwiLFxuICAvLyB3ZeKAmWxsIHNldCBhIHZlcnkgaGlnaCBwcmlvcml0eSB0byBtYWtlIHN1cmUgdGhpcyBydW5zIGZpcnN0XG4gIC8vIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggYGFwcGVuZFRyYW5zYWN0aW9uYCBob29rcyBvZiBvdGhlciBleHRlbnNpb25zXG4gIHByaW9yaXR5OiAxZTQsXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiaWRcIixcbiAgICAgIHR5cGVzOiBbXSxcbiAgICAgIGdlbmVyYXRlSUQ6ICgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cuX19URVNUX09QVElPTlMpIHtcbiAgICAgICAgICBjb25zdCBuID0gd2luZG93Ll9fVEVTVF9PUFRJT05TO1xuICAgICAgICAgIHJldHVybiBuLm1vY2tJRCA9PT0gdm9pZCAwID8gbi5tb2NrSUQgPSAwIDogbi5tb2NrSUQrKywgbi5tb2NrSUQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSWUoKTtcbiAgICAgIH0sXG4gICAgICBmaWx0ZXJUcmFuc2FjdGlvbjogbnVsbFxuICAgIH07XG4gIH0sXG4gIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdHlwZXM6IHRoaXMub3B0aW9ucy50eXBlcyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIFt0aGlzLm9wdGlvbnMuYXR0cmlidXRlTmFtZV06IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmdldEF0dHJpYnV0ZShgZGF0YS0ke3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lfWApLFxuICAgICAgICAgICAgcmVuZGVySFRNTDogKG4pID0+ICh7XG4gICAgICAgICAgICAgIFtgZGF0YS0ke3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lfWBdOiBuW3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVOYW1lXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICAvLyBjaGVjayBpbml0aWFsIGNvbnRlbnQgZm9yIG1pc3NpbmcgaWRzXG4gIC8vIG9uQ3JlYXRlKCkge1xuICAvLyAgIC8vIERvbuKAmXQgZG8gdGhpcyB3aGVuIHRoZSBjb2xsYWJvcmF0aW9uIGV4dGVuc2lvbiBpcyBhY3RpdmVcbiAgLy8gICAvLyBiZWNhdXNlIHRoaXMgbWF5IHVwZGF0ZSB0aGUgY29udGVudCwgc28gWS5qcyB0cmllcyB0byBtZXJnZSB0aGVzZSBjaGFuZ2VzLlxuICAvLyAgIC8vIFRoaXMgbGVhZHMgdG8gZW1wdHkgYmxvY2sgbm9kZXMuXG4gIC8vICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI0MDBcbiAgLy8gICBpZiAoXG4gIC8vICAgICB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmV4dGVuc2lvbnMuZmluZChcbiAgLy8gICAgICAgKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLm5hbWUgPT09IFwiY29sbGFib3JhdGlvblwiXG4gIC8vICAgICApXG4gIC8vICAgKSB7XG4gIC8vICAgICByZXR1cm47XG4gIC8vICAgfVxuICAvLyAgIGNvbnN0IHsgdmlldywgc3RhdGUgfSA9IHRoaXMuZWRpdG9yO1xuICAvLyAgIGNvbnN0IHsgdHIsIGRvYyB9ID0gc3RhdGU7XG4gIC8vICAgY29uc3QgeyB0eXBlcywgYXR0cmlidXRlTmFtZSwgZ2VuZXJhdGVJRCB9ID0gdGhpcy5vcHRpb25zO1xuICAvLyAgIGNvbnN0IG5vZGVzV2l0aG91dElkID0gZmluZENoaWxkcmVuKGRvYywgKG5vZGUpID0+IHtcbiAgLy8gICAgIHJldHVybiAoXG4gIC8vICAgICAgIHR5cGVzLmluY2x1ZGVzKG5vZGUudHlwZS5uYW1lKSAmJiBub2RlLmF0dHJzW2F0dHJpYnV0ZU5hbWVdID09PSBudWxsXG4gIC8vICAgICApO1xuICAvLyAgIH0pO1xuICAvLyAgIG5vZGVzV2l0aG91dElkLmZvckVhY2goKHsgbm9kZSwgcG9zIH0pID0+IHtcbiAgLy8gICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcbiAgLy8gICAgICAgLi4ubm9kZS5hdHRycyxcbiAgLy8gICAgICAgW2F0dHJpYnV0ZU5hbWVdOiBnZW5lcmF0ZUlEKCksXG4gIC8vICAgICB9KTtcbiAgLy8gICB9KTtcbiAgLy8gICB0ci5zZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIsIGZhbHNlKTtcbiAgLy8gICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgLy8gfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGxldCBuID0gbnVsbCwgdCA9ICExO1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgdih7XG4gICAgICAgIGtleTogbmV3IFQoXCJ1bmlxdWVJRFwiKSxcbiAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246IChlLCBvLCByKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IGUuc29tZSgoZikgPT4gZi5kb2NDaGFuZ2VkKSAmJiAhby5kb2MuZXEoci5kb2MpLCBzID0gdGhpcy5vcHRpb25zLmZpbHRlclRyYW5zYWN0aW9uICYmIGUuc29tZSgoZikgPT4ge1xuICAgICAgICAgICAgbGV0IHksIFM7XG4gICAgICAgICAgICByZXR1cm4gISghKChTID0gKHkgPSB0aGlzLm9wdGlvbnMpLmZpbHRlclRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBTID09PSB2b2lkIDApICYmIFMuY2FsbCh5LCBmKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFpIHx8IHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgeyB0cjogYSB9ID0gciwgeyB0eXBlczogbCwgYXR0cmlidXRlTmFtZTogYywgZ2VuZXJhdGVJRDogcCB9ID0gdGhpcy5vcHRpb25zLCB1ID0gYmUoXG4gICAgICAgICAgICBvLmRvYyxcbiAgICAgICAgICAgIGVcbiAgICAgICAgICApLCB7IG1hcHBpbmc6IG0gfSA9IHU7XG4gICAgICAgICAgaWYgKHllKHUpLmZvckVhY2goKHsgbmV3UmFuZ2U6IGYgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeSA9IGtlKFxuICAgICAgICAgICAgICByLmRvYyxcbiAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgKEUpID0+IGwuaW5jbHVkZXMoRS50eXBlLm5hbWUpXG4gICAgICAgICAgICApLCBTID0geS5tYXAoKHsgbm9kZTogRSB9KSA9PiBFLmF0dHJzW2NdKS5maWx0ZXIoKEUpID0+IEUgIT09IG51bGwpLCBCID0gZW4oUyk7XG4gICAgICAgICAgICB5LmZvckVhY2goKHsgbm9kZTogRSwgcG9zOiBEIH0pID0+IHtcbiAgICAgICAgICAgICAgbGV0IHo7XG4gICAgICAgICAgICAgIGNvbnN0IEsgPSAoeiA9IGEuZG9jLm5vZGVBdChEKSkgPT09IG51bGwgfHwgeiA9PT0gdm9pZCAwID8gdm9pZCAwIDogei5hdHRyc1tjXTtcbiAgICAgICAgICAgICAgaWYgKEsgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsdCA9IG8uZG9jLnR5cGUuY3JlYXRlQW5kRmlsbCgpLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKG8uZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChsdCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV0ID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoci5kb2MudG9KU09OKCkpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKGV0LmNvbnRlbnRbMF0uY29udGVudFswXS5hdHRycy5pZCA9IFwiaW5pdGlhbEJsb2NrSWRcIiwgSlNPTi5zdHJpbmdpZnkoZXQuY29udGVudCkgPT09IEpTT04uc3RyaW5naWZ5KGx0LnRvSlNPTigpKSkge1xuICAgICAgICAgICAgICAgICAgICBhLnNldE5vZGVNYXJrdXAoRCwgdm9pZCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uRS5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICBbY106IFwiaW5pdGlhbEJsb2NrSWRcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLnNldE5vZGVNYXJrdXAoRCwgdm9pZCAwLCB7XG4gICAgICAgICAgICAgICAgICAuLi5FLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgW2NdOiBwKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgeyBkZWxldGVkOiBnIH0gPSBtLmludmVydCgpLm1hcFJlc3VsdChEKTtcbiAgICAgICAgICAgICAgZyAmJiBCLmluY2x1ZGVzKEspICYmIGEuc2V0Tm9kZU1hcmt1cChELCB2b2lkIDAsIHtcbiAgICAgICAgICAgICAgICAuLi5FLmF0dHJzLFxuICAgICAgICAgICAgICAgIFtjXTogcCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSksICEhYS5zdGVwcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2UgcmVnaXN0ZXIgYSBnbG9iYWwgZHJhZyBoYW5kbGVyIHRvIHRyYWNrIHRoZSBjdXJyZW50IGRyYWcgc291cmNlIGVsZW1lbnRcbiAgICAgICAgdmlldyhlKSB7XG4gICAgICAgICAgY29uc3QgbyA9IChyKSA9PiB7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIG4gPSAhKChpID0gZS5kb20ucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgaSA9PT0gdm9pZCAwKSAmJiBpLmNvbnRhaW5zKHIudGFyZ2V0KSA/IGUuZG9tLnBhcmVudEVsZW1lbnQgOiBudWxsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIG8pLCB7XG4gICAgICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIC8vIGBoYW5kbGVET01FdmVudHNgIGlzIGNhbGxlZCBiZWZvcmUgYHRyYW5zZm9ybVBhc3RlZGBcbiAgICAgICAgICAvLyBzbyB3ZSBjYW4gZG8gc29tZSBjaGVja3MgYmVmb3JlXG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAvLyBvbmx5IGNyZWF0ZSBuZXcgaWRzIGZvciBkcm9wcGVkIGNvbnRlbnQgd2hpbGUgaG9sZGluZyBgYWx0YFxuICAgICAgICAgICAgLy8gb3IgY29udGVudCBpcyBkcmFnZ2VkIGZyb20gYW5vdGhlciBlZGl0b3JcbiAgICAgICAgICAgIGRyb3A6IChlLCBvKSA9PiB7XG4gICAgICAgICAgICAgIGxldCByO1xuICAgICAgICAgICAgICByZXR1cm4gKG4gIT09IGUuZG9tLnBhcmVudEVsZW1lbnQgfHwgKChyID0gby5kYXRhVHJhbnNmZXIpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIuZWZmZWN0QWxsb3dlZCkgPT09IFwiY29weVwiKSAmJiAobiA9IG51bGwsIHQgPSAhMCksICExO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGFsd2F5cyBjcmVhdGUgbmV3IGlkcyBvbiBwYXN0ZWQgY29udGVudFxuICAgICAgICAgICAgcGFzdGU6ICgpID0+ICh0ID0gITAsICExKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gd2XigJlsbCByZW1vdmUgaWRzIGZvciBldmVyeSBwYXN0ZWQgbm9kZVxuICAgICAgICAgIC8vIHNvIHdlIGNhbiBjcmVhdGUgYSBuZXcgb25lIHdpdGhpbiBgYXBwZW5kVHJhbnNhY3Rpb25gXG4gICAgICAgICAgdHJhbnNmb3JtUGFzdGVkOiAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0KVxuICAgICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZXM6IG8sIGF0dHJpYnV0ZU5hbWU6IHIgfSA9IHRoaXMub3B0aW9ucywgaSA9IChzKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgICAgcmV0dXJuIHMuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgICAgYS5wdXNoKGwpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW8uaW5jbHVkZXMobC50eXBlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBhLnB1c2gobC5jb3B5KGkobC5jb250ZW50KSkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjID0gbC50eXBlLmNyZWF0ZShcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubC5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgW3JdOiBudWxsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgaShsLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgbC5tYXJrc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGMpO1xuICAgICAgICAgICAgICB9KSwgeC5mcm9tKGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0ID0gITEsIG5ldyBfKFxuICAgICAgICAgICAgICBpKGUuY29udGVudCksXG4gICAgICAgICAgICAgIGUub3BlblN0YXJ0LFxuICAgICAgICAgICAgICBlLm9wZW5FbmRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pO1xuZnVuY3Rpb24gRnQobikge1xuICBjb25zdCB0ID0gbi5hdHRycy5pZCwgZSA9IG4uZmlyc3RDaGlsZCwgbyA9IGUudHlwZSwgciA9IG4uY2hpbGRDb3VudCA9PT0gMiA/IG4ubGFzdENoaWxkLmNoaWxkQ291bnQgOiAwO1xuICByZXR1cm4ge1xuICAgIGlkOiB0LFxuICAgIG5vZGU6IG4sXG4gICAgY29udGVudE5vZGU6IGUsXG4gICAgY29udGVudFR5cGU6IG8sXG4gICAgbnVtQ2hpbGRCbG9ja3M6IHJcbiAgfTtcbn1cbmZ1bmN0aW9uIGIobiwgdCkge1xuICBjb25zdCBvID0gbi5ub2RlU2l6ZSAtIDI7XG4gIGlmICh0IDw9IDEpXG4gICAgZm9yICh0ID0gMSArIDE7IG4ucmVzb2x2ZSh0KS5wYXJlbnQudHlwZS5uYW1lICE9PSBcImJsb2NrQ29udGFpbmVyXCIgJiYgdCA8IG87IClcbiAgICAgIHQrKztcbiAgZWxzZSBpZiAodCA+PSBvKVxuICAgIGZvciAodCA9IG8gLSAxOyBuLnJlc29sdmUodCkucGFyZW50LnR5cGUubmFtZSAhPT0gXCJibG9ja0NvbnRhaW5lclwiICYmIHQgPiAxOyApXG4gICAgICB0LS07XG4gIG4ucmVzb2x2ZSh0KS5wYXJlbnQudHlwZS5uYW1lID09PSBcImJsb2NrR3JvdXBcIiAmJiB0Kys7XG4gIGNvbnN0IHIgPSBuLnJlc29sdmUodCksIGkgPSByLmRlcHRoO1xuICBsZXQgcyA9IHIubm9kZShpKSwgYSA9IGk7XG4gIGZvciAoOyA7ICkge1xuICAgIGlmIChhIDwgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb3VsZCBub3QgZmluZCBibG9ja0NvbnRhaW5lciBub2RlLiBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgdW5kZXJseWluZyBCbG9ja05vdGUgc2NoZW1hIGhhcyBiZWVuIGVkaXRlZC5cIlxuICAgICAgKTtcbiAgICBpZiAocy50eXBlLm5hbWUgPT09IFwiYmxvY2tDb250YWluZXJcIilcbiAgICAgIGJyZWFrO1xuICAgIGEgLT0gMSwgcyA9IHIubm9kZShhKTtcbiAgfVxuICBjb25zdCB7IGlkOiBsLCBjb250ZW50Tm9kZTogYywgY29udGVudFR5cGU6IHAsIG51bUNoaWxkQmxvY2tzOiB1IH0gPSBGdChzKSwgbSA9IHIuc3RhcnQoYSksIGggPSByLmVuZChhKTtcbiAgcmV0dXJuIHtcbiAgICBpZDogbCxcbiAgICBub2RlOiBzLFxuICAgIGNvbnRlbnROb2RlOiBjLFxuICAgIGNvbnRlbnRUeXBlOiBwLFxuICAgIG51bUNoaWxkQmxvY2tzOiB1LFxuICAgIHN0YXJ0UG9zOiBtLFxuICAgIGVuZFBvczogaCxcbiAgICBkZXB0aDogYVxuICB9O1xufVxuZnVuY3Rpb24gSXQobikge1xuICByZXR1cm4gbi50eXBlID09PSBcImxpbmtcIjtcbn1cbmZ1bmN0aW9uICR0KG4pIHtcbiAgcmV0dXJuIHR5cGVvZiBuICE9IFwic3RyaW5nXCIgJiYgbi50eXBlID09PSBcImxpbmtcIjtcbn1cbmZ1bmN0aW9uIFkobikge1xuICByZXR1cm4gdHlwZW9mIG4gIT0gXCJzdHJpbmdcIiAmJiBuLnR5cGUgPT09IFwidGV4dFwiO1xufVxuY2xhc3MgTiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKGBVbnJlYWNoYWJsZSBjYXNlOiAke3R9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEx0KG4sIHQsIGUpIHtcbiAgY29uc3QgbyA9IFtdO1xuICBmb3IgKGNvbnN0IFtyLCBpXSBvZiBPYmplY3QuZW50cmllcyhuLnN0eWxlcykpIHtcbiAgICBjb25zdCBzID0gZVtyXTtcbiAgICBpZiAoIXMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0eWxlICR7cn0gbm90IGZvdW5kIGluIHN0eWxlU2NoZW1hYCk7XG4gICAgaWYgKHMucHJvcFNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICBvLnB1c2godC5tYXJrKHIpKTtcbiAgICBlbHNlIGlmIChzLnByb3BTY2hlbWEgPT09IFwic3RyaW5nXCIpXG4gICAgICBvLnB1c2godC5tYXJrKHIsIHsgc3RyaW5nVmFsdWU6IGkgfSkpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBOKHMucHJvcFNjaGVtYSk7XG4gIH1cbiAgcmV0dXJuIG4udGV4dC5zcGxpdCgvKFxcbikvZykuZmlsdGVyKChyKSA9PiByLmxlbmd0aCA+IDApLm1hcCgocikgPT4gciA9PT0gYFxuYCA/IHQubm9kZXMuaGFyZEJyZWFrLmNyZWF0ZSgpIDogdC50ZXh0KHIsIG8pKTtcbn1cbmZ1bmN0aW9uIG5uKG4sIHQsIGUpIHtcbiAgY29uc3QgbyA9IHQubWFya3MubGluay5jcmVhdGUoe1xuICAgIGhyZWY6IG4uaHJlZlxuICB9KTtcbiAgcmV0dXJuIGZ0KG4uY29udGVudCwgdCwgZSkubWFwKFxuICAgIChyKSA9PiB7XG4gICAgICBpZiAoci50eXBlLm5hbWUgPT09IFwidGV4dFwiKVxuICAgICAgICByZXR1cm4gci5tYXJrKFsuLi5yLm1hcmtzLCBvXSk7XG4gICAgICBpZiAoci50eXBlLm5hbWUgPT09IFwiaGFyZEJyZWFrXCIpXG4gICAgICAgIHJldHVybiByO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBub2RlIHR5cGVcIik7XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gZnQobiwgdCwgZSkge1xuICBjb25zdCBvID0gW107XG4gIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBvLnB1c2goXG4gICAgICAuLi5MdChcbiAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbiwgc3R5bGVzOiB7fSB9LFxuICAgICAgICB0LFxuICAgICAgICBlXG4gICAgICApXG4gICAgKSwgbztcbiAgZm9yIChjb25zdCByIG9mIG4pXG4gICAgby5wdXNoKC4uLkx0KHIsIHQsIGUpKTtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBzdChuLCB0LCBlKSB7XG4gIGNvbnN0IG8gPSBbXTtcbiAgZm9yIChjb25zdCByIG9mIG4pXG4gICAgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiA/IG8ucHVzaCguLi5mdChyLCB0LCBlKSkgOiAkdChyKSA/IG8ucHVzaCguLi5ubihyLCB0LCBlKSkgOiBZKHIpID8gby5wdXNoKC4uLmZ0KFtyXSwgdCwgZSkpIDogby5wdXNoKFxuICAgICAganQociwgdCwgZSlcbiAgICApO1xuICByZXR1cm4gbztcbn1cbmZ1bmN0aW9uIEd0KG4sIHQsIGUpIHtcbiAgY29uc3QgbyA9IFtdO1xuICBmb3IgKGNvbnN0IHIgb2Ygbi5yb3dzKSB7XG4gICAgY29uc3QgaSA9IFtdO1xuICAgIGZvciAoY29uc3QgYSBvZiByLmNlbGxzKSB7XG4gICAgICBsZXQgbDtcbiAgICAgIGlmICghYSlcbiAgICAgICAgbCA9IHQubm9kZXMudGFibGVQYXJhZ3JhcGguY3JlYXRlKHt9KTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpXG4gICAgICAgIGwgPSB0Lm5vZGVzLnRhYmxlUGFyYWdyYXBoLmNyZWF0ZSh7fSwgdC50ZXh0KGEpKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwID0gc3QoYSwgdCwgZSk7XG4gICAgICAgIGwgPSB0Lm5vZGVzLnRhYmxlUGFyYWdyYXBoLmNyZWF0ZSh7fSwgcCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gdC5ub2Rlcy50YWJsZUNlbGwuY3JlYXRlKHt9LCBsKTtcbiAgICAgIGkucHVzaChjKTtcbiAgICB9XG4gICAgY29uc3QgcyA9IHQubm9kZXMudGFibGVSb3cuY3JlYXRlKHt9LCBpKTtcbiAgICBvLnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBqdChuLCB0LCBlKSB7XG4gIGxldCBvLCByID0gbi50eXBlO1xuICBpZiAociA9PT0gdm9pZCAwICYmIChyID0gXCJwYXJhZ3JhcGhcIiksICF0Lm5vZGVzW3JdKVxuICAgIHRocm93IG5ldyBFcnJvcihgbm9kZSB0eXBlICR7cn0gbm90IGZvdW5kIGluIHNjaGVtYWApO1xuICBpZiAoIW4uY29udGVudClcbiAgICBvID0gdC5ub2Rlc1tyXS5jcmVhdGUobi5wcm9wcyk7XG4gIGVsc2UgaWYgKHR5cGVvZiBuLmNvbnRlbnQgPT0gXCJzdHJpbmdcIilcbiAgICBvID0gdC5ub2Rlc1tyXS5jcmVhdGUoXG4gICAgICBuLnByb3BzLFxuICAgICAgdC50ZXh0KG4uY29udGVudClcbiAgICApO1xuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG4uY29udGVudCkpIHtcbiAgICBjb25zdCBpID0gc3Qobi5jb250ZW50LCB0LCBlKTtcbiAgICBvID0gdC5ub2Rlc1tyXS5jcmVhdGUobi5wcm9wcywgaSk7XG4gIH0gZWxzZSBpZiAobi5jb250ZW50LnR5cGUgPT09IFwidGFibGVDb250ZW50XCIpIHtcbiAgICBjb25zdCBpID0gR3Qobi5jb250ZW50LCB0LCBlKTtcbiAgICBvID0gdC5ub2Rlc1tyXS5jcmVhdGUobi5wcm9wcywgaSk7XG4gIH0gZWxzZVxuICAgIHRocm93IG5ldyBOKG4uY29udGVudC50eXBlKTtcbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBQKG4sIHQsIGUpIHtcbiAgbGV0IG8gPSBuLmlkO1xuICBvID09PSB2b2lkIDAgJiYgKG8gPSBRLm9wdGlvbnMuZ2VuZXJhdGVJRCgpKTtcbiAgY29uc3QgciA9IGp0KFxuICAgIG4sXG4gICAgdCxcbiAgICBlXG4gICksIGkgPSBbXTtcbiAgaWYgKG4uY2hpbGRyZW4pXG4gICAgZm9yIChjb25zdCBhIG9mIG4uY2hpbGRyZW4pXG4gICAgICBpLnB1c2goUChhLCB0LCBlKSk7XG4gIGNvbnN0IHMgPSB0Lm5vZGVzLmJsb2NrR3JvdXAuY3JlYXRlKHt9LCBpKTtcbiAgcmV0dXJuIHQubm9kZXMuYmxvY2tDb250YWluZXIuY3JlYXRlKFxuICAgIHtcbiAgICAgIGlkOiBvLFxuICAgICAgLi4ubi5wcm9wc1xuICAgIH0sXG4gICAgaS5sZW5ndGggPiAwID8gW3IsIHNdIDogclxuICApO1xufVxuZnVuY3Rpb24gb24obiwgdCwgZSkge1xuICBjb25zdCBvID0ge1xuICAgIHR5cGU6IFwidGFibGVDb250ZW50XCIsXG4gICAgcm93czogW11cbiAgfTtcbiAgcmV0dXJuIG4uY29udGVudC5mb3JFYWNoKChyKSA9PiB7XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIGNlbGxzOiBbXVxuICAgIH07XG4gICAgci5jb250ZW50LmZvckVhY2goKHMpID0+IHtcbiAgICAgIGkuY2VsbHMucHVzaChcbiAgICAgICAgd3QoXG4gICAgICAgICAgcy5maXJzdENoaWxkLFxuICAgICAgICAgIHQsXG4gICAgICAgICAgZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pLCBvLnJvd3MucHVzaChpKTtcbiAgfSksIG87XG59XG5mdW5jdGlvbiB3dChuLCB0LCBlKSB7XG4gIGNvbnN0IG8gPSBbXTtcbiAgbGV0IHI7XG4gIHJldHVybiBuLmNvbnRlbnQuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGlmIChpLnR5cGUubmFtZSA9PT0gXCJoYXJkQnJlYWtcIikge1xuICAgICAgaWYgKHIpXG4gICAgICAgIGlmIChZKHIpKVxuICAgICAgICAgIHIudGV4dCArPSBgXG5gO1xuICAgICAgICBlbHNlIGlmIChJdChyKSlcbiAgICAgICAgICByLmNvbnRlbnRbci5jb250ZW50Lmxlbmd0aCAtIDFdLnRleHQgKz0gYFxuYDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWRcIik7XG4gICAgICBlbHNlXG4gICAgICAgIHIgPSB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogYFxuYCxcbiAgICAgICAgICBzdHlsZXM6IHt9XG4gICAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpLnR5cGUubmFtZSAhPT0gXCJsaW5rXCIgJiYgaS50eXBlLm5hbWUgIT09IFwidGV4dFwiICYmIHRbaS50eXBlLm5hbWVdKSB7XG4gICAgICByICYmIChvLnB1c2gociksIHIgPSB2b2lkIDApLCBvLnB1c2goXG4gICAgICAgIFd0KGksIHQsIGUpXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzID0ge307XG4gICAgbGV0IGE7XG4gICAgZm9yIChjb25zdCBsIG9mIGkubWFya3MpXG4gICAgICBpZiAobC50eXBlLm5hbWUgPT09IFwibGlua1wiKVxuICAgICAgICBhID0gbDtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjID0gZVtsLnR5cGUubmFtZV07XG4gICAgICAgIGlmICghYylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0eWxlICR7bC50eXBlLm5hbWV9IG5vdCBmb3VuZCBpbiBzdHlsZVNjaGVtYWApO1xuICAgICAgICBpZiAoYy5wcm9wU2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICBzW2MudHlwZV0gPSAhMDtcbiAgICAgICAgZWxzZSBpZiAoYy5wcm9wU2NoZW1hID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHNbYy50eXBlXSA9IGwuYXR0cnMuc3RyaW5nVmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgTihjLnByb3BTY2hlbWEpO1xuICAgICAgfVxuICAgIHIgPyBZKHIpID8gYSA/IChvLnB1c2gociksIHIgPSB7XG4gICAgICB0eXBlOiBcImxpbmtcIixcbiAgICAgIGhyZWY6IGEuYXR0cnMuaHJlZixcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IGkudGV4dENvbnRlbnQsXG4gICAgICAgICAgc3R5bGVzOiBzXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KSA6IEpTT04uc3RyaW5naWZ5KHIuc3R5bGVzKSA9PT0gSlNPTi5zdHJpbmdpZnkocykgPyByLnRleHQgKz0gaS50ZXh0Q29udGVudCA6IChvLnB1c2gociksIHIgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHRleHQ6IGkudGV4dENvbnRlbnQsXG4gICAgICBzdHlsZXM6IHNcbiAgICB9KSA6IEl0KHIpICYmIChhID8gci5ocmVmID09PSBhLmF0dHJzLmhyZWYgPyBKU09OLnN0cmluZ2lmeShcbiAgICAgIHIuY29udGVudFtyLmNvbnRlbnQubGVuZ3RoIC0gMV0uc3R5bGVzXG4gICAgKSA9PT0gSlNPTi5zdHJpbmdpZnkocykgPyByLmNvbnRlbnRbci5jb250ZW50Lmxlbmd0aCAtIDFdLnRleHQgKz0gaS50ZXh0Q29udGVudCA6IHIuY29udGVudC5wdXNoKHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogaS50ZXh0Q29udGVudCxcbiAgICAgIHN0eWxlczogc1xuICAgIH0pIDogKG8ucHVzaChyKSwgciA9IHtcbiAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgaHJlZjogYS5hdHRycy5ocmVmLFxuICAgICAgY29udGVudDogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogaS50ZXh0Q29udGVudCxcbiAgICAgICAgICBzdHlsZXM6IHNcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pIDogKG8ucHVzaChyKSwgciA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogaS50ZXh0Q29udGVudCxcbiAgICAgIHN0eWxlczogc1xuICAgIH0pKSA6IGEgPyByID0ge1xuICAgICAgdHlwZTogXCJsaW5rXCIsXG4gICAgICBocmVmOiBhLmF0dHJzLmhyZWYsXG4gICAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICB0ZXh0OiBpLnRleHRDb250ZW50LFxuICAgICAgICAgIHN0eWxlczogc1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfSA6IHIgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHRleHQ6IGkudGV4dENvbnRlbnQsXG4gICAgICBzdHlsZXM6IHNcbiAgICB9O1xuICB9KSwgciAmJiBvLnB1c2gociksIG87XG59XG5mdW5jdGlvbiBXdChuLCB0LCBlKSB7XG4gIGlmIChuLnR5cGUubmFtZSA9PT0gXCJ0ZXh0XCIgfHwgbi50eXBlLm5hbWUgPT09IFwibGlua1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWRcIik7XG4gIGNvbnN0IG8gPSB7fSwgciA9IHRbbi50eXBlLm5hbWVdO1xuICBmb3IgKGNvbnN0IFthLCBsXSBvZiBPYmplY3QuZW50cmllcyhuLmF0dHJzKSkge1xuICAgIGlmICghcilcbiAgICAgIHRocm93IEVycm9yKFwiaWMgbm9kZSBpcyBvZiBhbiB1bnJlY29nbml6ZWQgdHlwZTogXCIgKyBuLnR5cGUubmFtZSk7XG4gICAgY29uc3QgYyA9IHIucHJvcFNjaGVtYTtcbiAgICBhIGluIGMgJiYgKG9bYV0gPSBsKTtcbiAgfVxuICBsZXQgaTtcbiAgcmV0dXJuIHIuY29udGVudCA9PT0gXCJzdHlsZWRcIiA/IGkgPSB3dChcbiAgICBuLFxuICAgIHQsXG4gICAgZVxuICApIDogaSA9IHZvaWQgMCwge1xuICAgIHR5cGU6IG4udHlwZS5uYW1lLFxuICAgIHByb3BzOiBvLFxuICAgIGNvbnRlbnQ6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIGsobiwgdCwgZSwgbywgcikge1xuICBpZiAobi50eXBlLm5hbWUgIT09IFwiYmxvY2tDb250YWluZXJcIilcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiTm9kZSBtdXN0IGJlIG9mIHR5cGUgYmxvY2tDb250YWluZXIsIGJ1dCBpcyBvZiB0eXBlXCIgKyBuLnR5cGUubmFtZSArIFwiLlwiXG4gICAgKTtcbiAgY29uc3QgaSA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZ2V0KG4pO1xuICBpZiAoaSlcbiAgICByZXR1cm4gaTtcbiAgY29uc3QgcyA9IEZ0KG4pO1xuICBsZXQgYSA9IHMuaWQ7XG4gIGEgPT09IG51bGwgJiYgKGEgPSBRLm9wdGlvbnMuZ2VuZXJhdGVJRCgpKTtcbiAgY29uc3QgbCA9IHt9O1xuICBmb3IgKGNvbnN0IFtoLCBmXSBvZiBPYmplY3QuZW50cmllcyh7XG4gICAgLi4ubi5hdHRycyxcbiAgICAuLi5zLmNvbnRlbnROb2RlLmF0dHJzXG4gIH0pKSB7XG4gICAgY29uc3QgeSA9IHRbcy5jb250ZW50VHlwZS5uYW1lXTtcbiAgICBpZiAoIXkpXG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJCbG9jayBpcyBvZiBhbiB1bnJlY29nbml6ZWQgdHlwZTogXCIgKyBzLmNvbnRlbnRUeXBlLm5hbWVcbiAgICAgICk7XG4gICAgY29uc3QgUyA9IHkucHJvcFNjaGVtYTtcbiAgICBoIGluIFMgJiYgKGxbaF0gPSBmKTtcbiAgfVxuICBjb25zdCBjID0gdFtzLmNvbnRlbnRUeXBlLm5hbWVdLCBwID0gW107XG4gIGZvciAobGV0IGggPSAwOyBoIDwgcy5udW1DaGlsZEJsb2NrczsgaCsrKVxuICAgIHAucHVzaChcbiAgICAgIGsoXG4gICAgICAgIG4ubGFzdENoaWxkLmNoaWxkKGgpLFxuICAgICAgICB0LFxuICAgICAgICBlLFxuICAgICAgICBvLFxuICAgICAgICByXG4gICAgICApXG4gICAgKTtcbiAgbGV0IHU7XG4gIGlmIChjLmNvbnRlbnQgPT09IFwiaW5saW5lXCIpXG4gICAgdSA9IHd0KFxuICAgICAgcy5jb250ZW50Tm9kZSxcbiAgICAgIGUsXG4gICAgICBvXG4gICAgKTtcbiAgZWxzZSBpZiAoYy5jb250ZW50ID09PSBcInRhYmxlXCIpXG4gICAgdSA9IG9uKFxuICAgICAgcy5jb250ZW50Tm9kZSxcbiAgICAgIGUsXG4gICAgICBvXG4gICAgKTtcbiAgZWxzZSBpZiAoYy5jb250ZW50ID09PSBcIm5vbmVcIilcbiAgICB1ID0gdm9pZCAwO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IE4oYy5jb250ZW50KTtcbiAgY29uc3QgbSA9IHtcbiAgICBpZDogYSxcbiAgICB0eXBlOiBjLnR5cGUsXG4gICAgcHJvcHM6IGwsXG4gICAgY29udGVudDogdSxcbiAgICBjaGlsZHJlbjogcFxuICB9O1xuICByZXR1cm4gciA9PSBudWxsIHx8IHIuc2V0KG4sIG0pLCBtO1xufVxuZnVuY3Rpb24gcm4obikge1xuICByZXR1cm4gbi5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG59XG5jb25zdCBxdCA9IChuLCB0LCBlLCBvLCByKSA9PiB7XG4gIGlmICghZS5ub2Rlc1tuLnR5cGUubmFtZV0pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VyaWFsaXplciBpcyBtaXNzaW5nIGEgbm9kZSB0eXBlOiBcIiArIG4udHlwZS5uYW1lKTtcbiAgY29uc3QgeyBkb206IGksIGNvbnRlbnRET006IHMgfSA9IGd0LnJlbmRlclNwZWMoXG4gICAgcm4odCksXG4gICAgZS5ub2Rlc1tuLnR5cGUubmFtZV0obilcbiAgKTtcbiAgaWYgKHMpIHtcbiAgICBpZiAobi5pc0xlYWYpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBub3QgYWxsb3dlZCBpbiBhIGxlYWYgbm9kZSBzcGVjXCIpO1xuICAgIGlmIChuLnR5cGUubmFtZSA9PT0gXCJibG9ja0NvbnRhaW5lclwiKSB7XG4gICAgICBjb25zdCBhID0gbi5jaGlsZENvdW50ID4gMCAmJiBuLmZpcnN0Q2hpbGQudHlwZS5zcGVjLmdyb3VwID09PSBcImJsb2NrQ29udGVudFwiID8gbi5maXJzdENoaWxkIDogdm9pZCAwLCBsID0gbi5jaGlsZENvdW50ID4gMCAmJiBuLmxhc3RDaGlsZC50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tHcm91cFwiID8gbi5sYXN0Q2hpbGQgOiB2b2lkIDA7XG4gICAgICBpZiAoYSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGMgPSBvLmJsb2NrSW1wbGVtZW50YXRpb25zW2EudHlwZS5uYW1lXS5pbXBsZW1lbnRhdGlvbiwgdSA9IChyID8gYy50b0V4dGVybmFsSFRNTCA6IGMudG9JbnRlcm5hbEhUTUwpKFxuICAgICAgICAgIGsoXG4gICAgICAgICAgICBuLFxuICAgICAgICAgICAgby5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICAgICAgICBvLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgICAgICAgby5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgICAgICBvLmJsb2NrQ2FjaGVcbiAgICAgICAgICApLFxuICAgICAgICAgIG9cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHUuY29udGVudERPTSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKG4uaXNMZWFmKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ29udGVudCBob2xlIG5vdCBhbGxvd2VkIGluIGEgbGVhZiBub2RlIHNwZWNcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB1LmNvbnRlbnRET00uYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBlLnNlcmlhbGl6ZUZyYWdtZW50KGEuY29udGVudCwgdClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHMuYXBwZW5kQ2hpbGQodS5kb20pO1xuICAgICAgfVxuICAgICAgbCAhPT0gdm9pZCAwICYmIGUuc2VyaWFsaXplRnJhZ21lbnQoXG4gICAgICAgIHguZnJvbShsKSxcbiAgICAgICAgdCxcbiAgICAgICAgc1xuICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIGUuc2VyaWFsaXplRnJhZ21lbnQobi5jb250ZW50LCB0LCBzKTtcbiAgfVxuICByZXR1cm4gaTtcbn0sIEt0ID0gKG4sIHQpID0+IHtcbiAgY29uc3QgZSA9IHQuc2VyaWFsaXplRnJhZ21lbnQobiksIG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByZXR1cm4gby5hcHBlbmRDaGlsZChlKSwgby5pbm5lckhUTUw7XG59O1xuZnVuY3Rpb24gc24obikge1xuICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgIC4uLm4ub3JkZXJlZExpc3RJdGVtQmxvY2tUeXBlcyxcbiAgICAuLi5uLnVub3JkZXJlZExpc3RJdGVtQmxvY2tUeXBlc1xuICBdKSwgZSA9IChvKSA9PiB7XG4gICAgdmFyIHM7XG4gICAgaWYgKG8uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmICgocyA9IG8uY2hpbGRyZW5bMF0ucHJvcGVydGllcykgPT0gbnVsbCA/IHZvaWQgMCA6IHMuZGF0YU5vZGVUeXBlKSA9PT0gXCJibG9ja0dyb3VwXCIpIHtcbiAgICAgIGNvbnN0IGEgPSBvLmNoaWxkcmVuWzBdO1xuICAgICAgby5jaGlsZHJlbi5wb3AoKSwgby5jaGlsZHJlbi5wdXNoKC4uLmEuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBsZXQgciA9IG8uY2hpbGRyZW4ubGVuZ3RoLCBpO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgcjsgYSsrKSB7XG4gICAgICBjb25zdCBjID0gby5jaGlsZHJlblthXS5jaGlsZHJlblswXSwgcCA9IGMuY2hpbGRyZW5bMF0sIHUgPSBjLmNoaWxkcmVuLmxlbmd0aCA9PT0gMiA/IGMuY2hpbGRyZW5bMV0gOiBudWxsLCBtID0gdC5oYXMoXG4gICAgICAgIHAucHJvcGVydGllcy5kYXRhQ29udGVudFR5cGVcbiAgICAgICksIGggPSBtID8gbi5vcmRlcmVkTGlzdEl0ZW1CbG9ja1R5cGVzLmhhcyhcbiAgICAgICAgcC5wcm9wZXJ0aWVzLmRhdGFDb250ZW50VHlwZVxuICAgICAgKSA/IFwib2xcIiA6IFwidWxcIiA6IG51bGw7XG4gICAgICBpZiAodSAhPT0gbnVsbCAmJiBlKHUpLCBpICYmIGkudGFnTmFtZSAhPT0gaCkge1xuICAgICAgICBvLmNoaWxkcmVuLnNwbGljZShcbiAgICAgICAgICBhIC0gaS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgaS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBmID0gaS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBhIC09IGYsIHIgLT0gZiwgaSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmIChtKSB7XG4gICAgICAgIGkgfHwgKGkgPSBCdChcbiAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGgpXG4gICAgICAgICkpO1xuICAgICAgICBjb25zdCBmID0gQnQoXG4gICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpXG4gICAgICAgICk7XG4gICAgICAgIGYuY2hpbGRyZW4ucHVzaChwLmNoaWxkcmVuWzBdKSwgdSAhPT0gbnVsbCAmJiBmLmNoaWxkcmVuLnB1c2goLi4udS5jaGlsZHJlbiksIGkuY2hpbGRyZW4ucHVzaChmKTtcbiAgICAgIH0gZWxzZSBpZiAodSAhPT0gbnVsbCkge1xuICAgICAgICBvLmNoaWxkcmVuLnNwbGljZShhICsgMSwgMCwgLi4udS5jaGlsZHJlbiksIG8uY2hpbGRyZW5bYV0gPSBwLmNoaWxkcmVuWzBdO1xuICAgICAgICBjb25zdCBmID0gdS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGEgKz0gZiwgciArPSBmO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG8uY2hpbGRyZW5bYV0gPSBwLmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICBpICYmIG8uY2hpbGRyZW4uc3BsaWNlKFxuICAgICAgciAtIGkuY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgaS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICBpXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIGU7XG59XG5jb25zdCBhdCA9IChuLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSBndC5mcm9tU2NoZW1hKG4pO1xuICByZXR1cm4gZS5zZXJpYWxpemVOb2RlSW5uZXIgPSAobywgcikgPT4gcXQobywgciwgZSwgdCwgITApLCBlLmV4cG9ydFByb3NlTWlycm9yRnJhZ21lbnQgPSAobykgPT4gYnQoKS51c2UoUnQsIHsgZnJhZ21lbnQ6ICEwIH0pLnVzZShzbiwge1xuICAgIG9yZGVyZWRMaXN0SXRlbUJsb2NrVHlwZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm51bWJlcmVkTGlzdEl0ZW1cIl0pLFxuICAgIHVub3JkZXJlZExpc3RJdGVtQmxvY2tUeXBlczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYnVsbGV0TGlzdEl0ZW1cIl0pXG4gIH0pLnVzZSh6dCkucHJvY2Vzc1N5bmMoS3QobywgZSkpLnZhbHVlLCBlLmV4cG9ydEJsb2NrcyA9IChvKSA9PiB7XG4gICAgY29uc3QgciA9IG8ubWFwKFxuICAgICAgKHMpID0+IFAocywgbiwgdC5zY2hlbWEuc3R5bGVTY2hlbWEpXG4gICAgKSwgaSA9IG4ubm9kZXMuYmxvY2tHcm91cC5jcmVhdGUobnVsbCwgcik7XG4gICAgcmV0dXJuIGUuZXhwb3J0UHJvc2VNaXJyb3JGcmFnbWVudCh4LmZyb20oaSkpO1xuICB9LCBlO1xufSwgSnQgPSAobiwgdCkgPT4ge1xuICBjb25zdCBlID0gZ3QuZnJvbVNjaGVtYShuKTtcbiAgcmV0dXJuIGUuc2VyaWFsaXplTm9kZUlubmVyID0gKG8sIHIpID0+IHF0KG8sIHIsIGUsIHQsICExKSwgZS5zZXJpYWxpemVQcm9zZU1pcnJvckZyYWdtZW50ID0gKG8pID0+IEt0KG8sIGUpLCBlLnNlcmlhbGl6ZUJsb2NrcyA9IChvKSA9PiB7XG4gICAgY29uc3QgciA9IG8ubWFwKFxuICAgICAgKHMpID0+IFAocywgbiwgdC5zY2hlbWEuc3R5bGVTY2hlbWEpXG4gICAgKSwgaSA9IG4ubm9kZXMuYmxvY2tHcm91cC5jcmVhdGUobnVsbCwgcik7XG4gICAgcmV0dXJuIGUuc2VyaWFsaXplUHJvc2VNaXJyb3JGcmFnbWVudCh4LmZyb20oaSkpO1xuICB9LCBlO1xufSwgSHIgPSBhc3luYyAobikgPT4ge1xuICBjb25zdCB0ID0gbmV3IEZvcm1EYXRhKCk7XG4gIHJldHVybiB0LmFwcGVuZChcImZpbGVcIiwgbiksIChhd2FpdCAoYXdhaXQgZmV0Y2goXCJodHRwczovL3RtcGZpbGVzLm9yZy9hcGkvdjEvdXBsb2FkXCIsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IHRcbiAgfSkpLmpzb24oKSkuZGF0YS51cmwucmVwbGFjZShcbiAgICBcInRtcGZpbGVzLm9yZy9cIixcbiAgICBcInRtcGZpbGVzLm9yZy9kbC9cIlxuICApO1xufSwgYW4gPSAoKSA9PiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgKC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSB8fCAvQXBwbGVXZWJLaXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL01vYmlsZVxcL1xcdysvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xuZnVuY3Rpb24gVihuKSB7XG4gIHJldHVybiBhbigpID8gbi5yZXBsYWNlKFwiTW9kXCIsIFwi4oyYXCIpIDogbi5yZXBsYWNlKFwiTW9kXCIsIFwiQ3RybFwiKTtcbn1cbmZ1bmN0aW9uIFIoLi4ubikge1xuICByZXR1cm4gbi5maWx0ZXIoKHQpID0+IHQpLmpvaW4oXCIgXCIpO1xufVxuY29uc3QgUHIgPSAoKSA9PiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuZnVuY3Rpb24gWihuLCB0LCBlLCBvKSB7XG4gIGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICByLmNsYXNzTmFtZSA9IFIoXG4gICAgXCJibi1ibG9jay1jb250ZW50XCIsXG4gICAgZS5jbGFzc1xuICApLCByLnNldEF0dHJpYnV0ZShcImRhdGEtY29udGVudC10eXBlXCIsIG4pO1xuICBmb3IgKGNvbnN0IFtzLCBhXSBvZiBPYmplY3QuZW50cmllcyhlKSlcbiAgICBzICE9PSBcImNsYXNzXCIgJiYgci5zZXRBdHRyaWJ1dGUocywgYSk7XG4gIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHQpO1xuICBpLmNsYXNzTmFtZSA9IFIoXG4gICAgXCJibi1pbmxpbmUtY29udGVudFwiLFxuICAgIG8uY2xhc3NcbiAgKTtcbiAgZm9yIChjb25zdCBbcywgYV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgb1xuICApKVxuICAgIHMgIT09IFwiY2xhc3NcIiAmJiBpLnNldEF0dHJpYnV0ZShzLCBhKTtcbiAgcmV0dXJuIHIuYXBwZW5kQ2hpbGQoaSksIHtcbiAgICBkb206IHIsXG4gICAgY29udGVudERPTTogaVxuICB9O1xufVxuY29uc3QgTnQgPSAobiwgdCkgPT4ge1xuICBjb25zdCBlID0gUChcbiAgICBuLFxuICAgIHQuX3RpcHRhcEVkaXRvci5zY2hlbWEsXG4gICAgdC5zY2hlbWEuc3R5bGVTY2hlbWFcbiAgKS5maXJzdENoaWxkLCBvID0gdC5fdGlwdGFwRWRpdG9yLnNjaGVtYS5ub2Rlc1tlLnR5cGUubmFtZV0uc3BlYy50b0RPTTtcbiAgaWYgKG8gPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoaXMgYmxvY2sgaGFzIG5vIGRlZmF1bHQgSFRNTCBzZXJpYWxpemF0aW9uIGFzIGl0cyBjb3JyZXNwb25kaW5nIFRpcFRhcCBub2RlIGRvZXNuJ3QgaW1wbGVtZW50IGByZW5kZXJIVE1MYC5cIlxuICAgICk7XG4gIGNvbnN0IHIgPSBvKGUpO1xuICBpZiAodHlwZW9mIHIgIT0gXCJvYmplY3RcIiB8fCAhKFwiZG9tXCIgaW4gcikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJDYW5ub3QgdXNlIHRoaXMgYmxvY2sncyBkZWZhdWx0IEhUTUwgc2VyaWFsaXphdGlvbiBhcyBpdHMgY29ycmVzcG9uZGluZyBUaXBUYXAgbm9kZSdzIGByZW5kZXJIVE1MYCBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIGBkb21gIHByb3BlcnR5LlwiXG4gICAgKTtcbiAgcmV0dXJuIHI7XG59LCB3ID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICBkZWZhdWx0OiBcImRlZmF1bHRcIlxuICB9LFxuICB0ZXh0Q29sb3I6IHtcbiAgICBkZWZhdWx0OiBcImRlZmF1bHRcIlxuICB9LFxuICB0ZXh0QWxpZ25tZW50OiB7XG4gICAgZGVmYXVsdDogXCJsZWZ0XCIsXG4gICAgdmFsdWVzOiBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIiwgXCJqdXN0aWZ5XCJdXG4gIH1cbn0sIFh0ID0gW1wiYmFja2dyb3VuZENvbG9yXCIsIFwidGV4dENvbG9yXCJdO1xuZnVuY3Rpb24gaXQobikge1xuICByZXR1cm4gXCJkYXRhLVwiICsgbi5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBZdChuKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG4pLmZpbHRlcigoW2UsIG9dKSA9PiAhWHQuaW5jbHVkZXMoZSkpLmZvckVhY2goKFtlLCBvXSkgPT4ge1xuICAgIHRbZV0gPSB7XG4gICAgICBkZWZhdWx0OiBvLmRlZmF1bHQsXG4gICAgICBrZWVwT25TcGxpdDogITAsXG4gICAgICAvLyBQcm9wcyBhcmUgZGlzcGxheWVkIGluIGtlYmFiLWNhc2UgYXMgSFRNTCBhdHRyaWJ1dGVzLiBJZiBhIHByb3Anc1xuICAgICAgLy8gdmFsdWUgaXMgdGhlIHNhbWUgYXMgaXRzIGRlZmF1bHQsIHdlIGRvbid0IGRpc3BsYXkgYW4gSFRNTFxuICAgICAgLy8gYXR0cmlidXRlIGZvciBpdC5cbiAgICAgIHBhcnNlSFRNTDogKHIpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHIuZ2V0QXR0cmlidXRlKGl0KGUpKTtcbiAgICAgICAgaWYgKGkgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygby5kZWZhdWx0ID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgIHJldHVybiBpID09PSBcInRydWVcIiA/ICEwIDogaSA9PT0gXCJmYWxzZVwiID8gITEgOiBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG8uZGVmYXVsdCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29uc3QgcyA9IHBhcnNlRmxvYXQoaSk7XG4gICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4ocykgJiYgTnVtYmVyLmlzRmluaXRlKHMpID8gcyA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9LFxuICAgICAgcmVuZGVySFRNTDogKHIpID0+IHJbZV0gIT09IG8uZGVmYXVsdCA/IHtcbiAgICAgICAgW2l0KGUpXTogcltlXVxuICAgICAgfSA6IHt9XG4gICAgfTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBsbihuLCB0LCBlLCBvKSB7XG4gIGlmICh0eXBlb2YgbiA9PSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbm5vdCBmaW5kIG5vZGUgcG9zaXRpb24gYXMgZ2V0UG9zIGlzIGEgYm9vbGVhbiwgbm90IGEgZnVuY3Rpb24uXCJcbiAgICApO1xuICBjb25zdCByID0gbigpLCBzID0gZS5zdGF0ZS5kb2MucmVzb2x2ZShyKS5ub2RlKCkuYXR0cnMuaWQsIGEgPSB0LmdldEJsb2NrKHMpO1xuICBpZiAoYS50eXBlICE9PSBvKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIHR5cGUgZG9lcyBub3QgbWF0Y2hcIik7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gcHQobiwgdCwgZSwgbywgcikge1xuICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgaWYgKHIgIT09IHZvaWQgMClcbiAgICBmb3IgKGNvbnN0IFtzLCBhXSBvZiBPYmplY3QuZW50cmllcyhyKSlcbiAgICAgIHMgIT09IFwiY2xhc3NcIiAmJiBpLnNldEF0dHJpYnV0ZShzLCBhKTtcbiAgaS5jbGFzc05hbWUgPSBSKFxuICAgIFwiYm4tYmxvY2stY29udGVudFwiLFxuICAgIChyID09IG51bGwgPyB2b2lkIDAgOiByLmNsYXNzKSB8fCBcIlwiXG4gICksIGkuc2V0QXR0cmlidXRlKFwiZGF0YS1jb250ZW50LXR5cGVcIiwgdCk7XG4gIGZvciAoY29uc3QgW3MsIGFdIG9mIE9iamVjdC5lbnRyaWVzKGUpKVxuICAgICFYdC5pbmNsdWRlcyhzKSAmJiBhICE9PSBvW3NdLmRlZmF1bHQgJiYgaS5zZXRBdHRyaWJ1dGUoaXQocyksIGEpO1xuICByZXR1cm4gaS5hcHBlbmRDaGlsZChuLmRvbSksIG4uY29udGVudERPTSAhPT0gdm9pZCAwICYmIChuLmNvbnRlbnRET00uY2xhc3NOYW1lID0gUihcbiAgICBcImJuLWlubGluZS1jb250ZW50XCIsXG4gICAgbi5jb250ZW50RE9NLmNsYXNzTmFtZVxuICApLCBuLmNvbnRlbnRET00uc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0YWJsZVwiLCBcIlwiKSksIHtcbiAgICAuLi5uLFxuICAgIGRvbTogaVxuICB9O1xufVxuZnVuY3Rpb24gVyhuKSB7XG4gIHJldHVybiBqLmNyZWF0ZShuKTtcbn1cbmZ1bmN0aW9uIFF0KG4sIHQpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25maWc6IG4sXG4gICAgaW1wbGVtZW50YXRpb246IHRcbiAgfTtcbn1cbmZ1bmN0aW9uIHR0KG4sIHQsIGUpIHtcbiAgcmV0dXJuIFF0KFxuICAgIHtcbiAgICAgIHR5cGU6IG4ubmFtZSxcbiAgICAgIGNvbnRlbnQ6IG4uY29uZmlnLmNvbnRlbnQgPT09IFwiaW5saW5lKlwiID8gXCJpbmxpbmVcIiA6IG4uY29uZmlnLmNvbnRlbnQgPT09IFwidGFibGVSb3crXCIgPyBcInRhYmxlXCIgOiBcIm5vbmVcIixcbiAgICAgIHByb3BTY2hlbWE6IHRcbiAgICB9LFxuICAgIHtcbiAgICAgIG5vZGU6IG4sXG4gICAgICByZXF1aXJlZEV4dGVuc2lvbnM6IGUsXG4gICAgICB0b0ludGVybmFsSFRNTDogTnQsXG4gICAgICB0b0V4dGVybmFsSFRNTDogTnRcbiAgICAgIC8vIHBhcnNlOiAoKSA9PiB1bmRlZmluZWQsIC8vIHBhcnNlIHJ1bGVzIGFyZSBpbiBub2RlIGFscmVhZHlcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBadChuKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMobikubWFwKChbdCwgZV0pID0+IFt0LCBlLmNvbmZpZ10pXG4gICk7XG59XG5mdW5jdGlvbiBjbihuLCB0KSB7XG4gIGNvbnN0IGUgPSBbXG4gICAge1xuICAgICAgdGFnOiBcIltkYXRhLWNvbnRlbnQtdHlwZT1cIiArIG4udHlwZSArIFwiXVwiLFxuICAgICAgY29udGVudEVsZW1lbnQ6IFwiW2RhdGEtZWRpdGFibGVdXCJcbiAgICB9XG4gIF07XG4gIHJldHVybiB0ICYmIGUucHVzaCh7XG4gICAgdGFnOiBcIipcIixcbiAgICBnZXRBdHRycyhvKSB7XG4gICAgICBpZiAodHlwZW9mIG8gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgciA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQobyk7XG4gICAgICByZXR1cm4gciA9PT0gdm9pZCAwID8gITEgOiByO1xuICAgIH1cbiAgfSksIGU7XG59XG5mdW5jdGlvbiBkbihuLCB0KSB7XG4gIGNvbnN0IGUgPSBXKHtcbiAgICBuYW1lOiBuLnR5cGUsXG4gICAgY29udGVudDogbi5jb250ZW50ID09PSBcImlubGluZVwiID8gXCJpbmxpbmUqXCIgOiBcIlwiLFxuICAgIGdyb3VwOiBcImJsb2NrQ29udGVudFwiLFxuICAgIHNlbGVjdGFibGU6ICEwLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICByZXR1cm4gWXQobi5wcm9wU2NoZW1hKTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgIHJldHVybiBjbihuLCB0LnBhcnNlKTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoKSB7XG4gICAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHJldHVybiBvLnNldEF0dHJpYnV0ZShcImRhdGEtdG1wLXBsYWNlaG9sZGVyXCIsIFwidHJ1ZVwiKSwge1xuICAgICAgICBkb206IG9cbiAgICAgIH07XG4gICAgfSxcbiAgICBhZGROb2RlVmlldygpIHtcbiAgICAgIHJldHVybiAoeyBnZXRQb3M6IG8gfSkgPT4ge1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5lZGl0b3IsIGkgPSBsbihcbiAgICAgICAgICBvLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgdGhpcy5lZGl0b3IsXG4gICAgICAgICAgbi50eXBlXG4gICAgICAgICksIHMgPSAoKGwgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGwuYmxvY2tDb250ZW50KSB8fCB7fSwgYSA9IHQucmVuZGVyKGksIHIpO1xuICAgICAgICByZXR1cm4gcHQoXG4gICAgICAgICAgYSxcbiAgICAgICAgICBpLnR5cGUsXG4gICAgICAgICAgaS5wcm9wcyxcbiAgICAgICAgICBuLnByb3BTY2hlbWEsXG4gICAgICAgICAgc1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAoZS5uYW1lICE9PSBuLnR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJOb2RlIG5hbWUgZG9lcyBub3QgbWF0Y2ggYmxvY2sgdHlwZS4gVGhpcyBpcyBhIGJ1ZyBpbiBCbG9ja05vdGUuXCJcbiAgICApO1xuICByZXR1cm4gUXQobiwge1xuICAgIG5vZGU6IGUsXG4gICAgdG9JbnRlcm5hbEhUTUw6IChvLCByKSA9PiB7XG4gICAgICB2YXIgYTtcbiAgICAgIGNvbnN0IGkgPSAoKGEgPSBlLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuYmxvY2tDb250ZW50KSB8fCB7fSwgcyA9IHQucmVuZGVyKG8sIHIpO1xuICAgICAgcmV0dXJuIHB0KFxuICAgICAgICBzLFxuICAgICAgICBvLnR5cGUsXG4gICAgICAgIG8ucHJvcHMsXG4gICAgICAgIG4ucHJvcFNjaGVtYSxcbiAgICAgICAgaVxuICAgICAgKTtcbiAgICB9LFxuICAgIHRvRXh0ZXJuYWxIVE1MOiAobywgcikgPT4ge1xuICAgICAgdmFyIGEsIGw7XG4gICAgICBjb25zdCBpID0gKChhID0gZS5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBhLmJsb2NrQ29udGVudCkgfHwge307XG4gICAgICBsZXQgcyA9IChsID0gdC50b0V4dGVybmFsSFRNTCkgPT0gbnVsbCA/IHZvaWQgMCA6IGwuY2FsbChcbiAgICAgICAgdCxcbiAgICAgICAgbyxcbiAgICAgICAgclxuICAgICAgKTtcbiAgICAgIHJldHVybiBzID09PSB2b2lkIDAgJiYgKHMgPSB0LnJlbmRlcihvLCByKSksIHB0KFxuICAgICAgICBzLFxuICAgICAgICBvLnR5cGUsXG4gICAgICAgIG8ucHJvcHMsXG4gICAgICAgIG4ucHJvcFNjaGVtYSxcbiAgICAgICAgaVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcG4obiwgdCwgZSwgbykge1xuICByZXR1cm4gbi5kb20uc2V0QXR0cmlidXRlKFwiZGF0YS1pbmxpbmUtY29udGVudC10eXBlXCIsIHQpLCBPYmplY3QuZW50cmllcyhlKS5maWx0ZXIoKFtyLCBpXSkgPT4gaSAhPT0gb1tyXS5kZWZhdWx0KS5tYXAoKFtyLCBpXSkgPT4gW2l0KHIpLCBpXSkuZm9yRWFjaCgoW3IsIGldKSA9PiBuLmRvbS5zZXRBdHRyaWJ1dGUociwgaSkpLCBuLmNvbnRlbnRET00gIT09IHZvaWQgMCAmJiBuLmNvbnRlbnRET00uc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0YWJsZVwiLCBcIlwiKSwgbjtcbn1cbmZ1bmN0aW9uIHVuKG4pIHtcbiAgcmV0dXJuIHtcbiAgICBCYWNrc3BhY2U6ICh7IGVkaXRvcjogdCB9KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICByZXR1cm4gdC5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgZS5ub2RlKCkudHlwZS5uYW1lID09PSBuLnR5cGUgJiYgZS5wYXJlbnRPZmZzZXQgPT09IDA7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaG4obiwgdCkge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZzogbixcbiAgICBpbXBsZW1lbnRhdGlvbjogdFxuICB9O1xufVxuZnVuY3Rpb24gbW4obiwgdCkge1xuICByZXR1cm4gaG4oXG4gICAge1xuICAgICAgdHlwZTogbi5uYW1lLFxuICAgICAgcHJvcFNjaGVtYTogdCxcbiAgICAgIGNvbnRlbnQ6IG4uY29uZmlnLmNvbnRlbnQgPT09IFwiaW5saW5lKlwiID8gXCJzdHlsZWRcIiA6IFwibm9uZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBub2RlOiBuXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gdGUobikge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG4pLm1hcCgoW3QsIGVdKSA9PiBbdCwgZS5jb25maWddKVxuICApO1xufVxuZnVuY3Rpb24gZm4obikge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHRhZzogYFtkYXRhLWlubGluZS1jb250ZW50LXR5cGU9XCIke24udHlwZX1cIl1gLFxuICAgICAgY29udGVudEVsZW1lbnQ6ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGUgPSB0O1xuICAgICAgICByZXR1cm4gZS5tYXRjaGVzKFwiW2RhdGEtZWRpdGFibGVdXCIpID8gZSA6IGUucXVlcnlTZWxlY3RvcihcIltkYXRhLWVkaXRhYmxlXVwiKSB8fCBlO1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIERyKG4sIHQpIHtcbiAgY29uc3QgZSA9IGouY3JlYXRlKHtcbiAgICBuYW1lOiBuLnR5cGUsXG4gICAgaW5saW5lOiAhMCxcbiAgICBncm91cDogXCJpbmxpbmVcIixcbiAgICBzZWxlY3RhYmxlOiBuLmNvbnRlbnQgPT09IFwic3R5bGVkXCIsXG4gICAgYXRvbTogbi5jb250ZW50ID09PSBcIm5vbmVcIixcbiAgICBjb250ZW50OiBuLmNvbnRlbnQgPT09IFwic3R5bGVkXCIgPyBcImlubGluZSpcIiA6IFwiXCIsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBZdChuLnByb3BTY2hlbWEpO1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICByZXR1cm4gdW4obik7XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICByZXR1cm4gZm4obik7XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgbm9kZTogbyB9KSB7XG4gICAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmVkaXRvciwgaSA9IHQucmVuZGVyKFxuICAgICAgICBXdChcbiAgICAgICAgICBvLFxuICAgICAgICAgIHIuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICAgICAgci5zY2hlbWEuc3R5bGVTY2hlbWFcbiAgICAgICAgKVxuICAgICAgICAvLyBUT0RPOiBmaXggY2FzdFxuICAgICAgKTtcbiAgICAgIHJldHVybiBwbihcbiAgICAgICAgaSxcbiAgICAgICAgbi50eXBlLFxuICAgICAgICBvLmF0dHJzLFxuICAgICAgICBuLnByb3BTY2hlbWFcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1uKFxuICAgIGUsXG4gICAgbi5wcm9wU2NoZW1hXG4gICk7XG59XG5mdW5jdGlvbiBnbihuKSB7XG4gIHJldHVybiBuID09PSBcImJvb2xlYW5cIiA/IHt9IDoge1xuICAgIHN0cmluZ1ZhbHVlOiB7XG4gICAgICBkZWZhdWx0OiB2b2lkIDAsXG4gICAgICBrZWVwT25TcGxpdDogITAsXG4gICAgICBwYXJzZUhUTUw6ICh0KSA9PiB0LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiksXG4gICAgICByZW5kZXJIVE1MOiAodCkgPT4gdC5zdHJpbmdWYWx1ZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICBcImRhdGEtdmFsdWVcIjogdC5zdHJpbmdWYWx1ZVxuICAgICAgfSA6IHt9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYm4obiwgdCwgZSwgbykge1xuICByZXR1cm4gbi5kb20uc2V0QXR0cmlidXRlKFwiZGF0YS1zdHlsZS10eXBlXCIsIHQpLCBvID09PSBcInN0cmluZ1wiICYmIG4uZG9tLnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiwgZSksIG4uY29udGVudERPTSAhPT0gdm9pZCAwICYmIG4uY29udGVudERPTS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRhYmxlXCIsIFwiXCIpLCBuO1xufVxuZnVuY3Rpb24gZWUobiwgdCkge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZzogbixcbiAgICBpbXBsZW1lbnRhdGlvbjogdFxuICB9O1xufVxuZnVuY3Rpb24gTyhuLCB0KSB7XG4gIHJldHVybiBlZShcbiAgICB7XG4gICAgICB0eXBlOiBuLm5hbWUsXG4gICAgICBwcm9wU2NoZW1hOiB0XG4gICAgfSxcbiAgICB7XG4gICAgICBtYXJrOiBuXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gbmUobikge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG4pLm1hcCgoW3QsIGVdKSA9PiBbdCwgZS5jb25maWddKVxuICApO1xufVxuZnVuY3Rpb24geW4obikge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHRhZzogYFtkYXRhLXN0eWxlLXR5cGU9XCIke24udHlwZX1cIl1gLFxuICAgICAgY29udGVudEVsZW1lbnQ6ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGUgPSB0O1xuICAgICAgICByZXR1cm4gZS5tYXRjaGVzKFwiW2RhdGEtZWRpdGFibGVdXCIpID8gZSA6IGUucXVlcnlTZWxlY3RvcihcIltkYXRhLWVkaXRhYmxlXVwiKSB8fCBlO1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIE9yKG4sIHQpIHtcbiAgY29uc3QgZSA9IHl0LmNyZWF0ZSh7XG4gICAgbmFtZTogbi50eXBlLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICByZXR1cm4gZ24obi5wcm9wU2NoZW1hKTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgIHJldHVybiB5bihuKTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBtYXJrOiBvIH0pIHtcbiAgICAgIGxldCByO1xuICAgICAgaWYgKG4ucHJvcFNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHIgPSB0LnJlbmRlcigpO1xuICAgICAgZWxzZSBpZiAobi5wcm9wU2NoZW1hID09PSBcInN0cmluZ1wiKVxuICAgICAgICByID0gdC5yZW5kZXIoby5hdHRycy5zdHJpbmdWYWx1ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBOKG4ucHJvcFNjaGVtYSk7XG4gICAgICByZXR1cm4gYm4oXG4gICAgICAgIHIsXG4gICAgICAgIG4udHlwZSxcbiAgICAgICAgby5hdHRycy5zdHJpbmdWYWx1ZSxcbiAgICAgICAgbi5wcm9wU2NoZW1hXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlZShuLCB7XG4gICAgbWFyazogZVxuICB9KTtcbn1cbmNvbnN0IGtuID0geXQuY3JlYXRlKHtcbiAgbmFtZTogXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyaW5nVmFsdWU6IHtcbiAgICAgICAgZGVmYXVsdDogdm9pZCAwLFxuICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmdldEF0dHJpYnV0ZShcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiKSxcbiAgICAgICAgcmVuZGVySFRNTDogKG4pID0+ICh7XG4gICAgICAgICAgXCJkYXRhLWJhY2tncm91bmQtY29sb3JcIjogbi5zdHJpbmdWYWx1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwic3BhblwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyAhMSA6IG4uaGFzQXR0cmlidXRlKFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCIpID8ge1xuICAgICAgICAgIHN0cmluZ1ZhbHVlOiBuLmdldEF0dHJpYnV0ZShcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiKVxuICAgICAgICB9IDogITFcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXM6IG4gfSkge1xuICAgIHJldHVybiBbXCJzcGFuXCIsIG4sIDBdO1xuICB9XG59KSwgd24gPSBPKFxuICBrbixcbiAgXCJzdHJpbmdcIlxuKSwgdm4gPSB5dC5jcmVhdGUoe1xuICBuYW1lOiBcInRleHRDb2xvclwiLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpbmdWYWx1ZToge1xuICAgICAgICBkZWZhdWx0OiB2b2lkIDAsXG4gICAgICAgIHBhcnNlSFRNTDogKG4pID0+IG4uZ2V0QXR0cmlidXRlKFwiZGF0YS10ZXh0LWNvbG9yXCIpLFxuICAgICAgICByZW5kZXJIVE1MOiAobikgPT4gKHtcbiAgICAgICAgICBcImRhdGEtdGV4dC1jb2xvclwiOiBuLnN0cmluZ1ZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJzcGFuXCIsXG4gICAgICAgIGdldEF0dHJzOiAobikgPT4gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiA/ICExIDogbi5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRleHQtY29sb3JcIikgPyB7IHN0cmluZ1ZhbHVlOiBuLmdldEF0dHJpYnV0ZShcImRhdGEtdGV4dC1jb2xvclwiKSB9IDogITFcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXM6IG4gfSkge1xuICAgIHJldHVybiBbXCJzcGFuXCIsIG4sIDBdO1xuICB9XG59KSwgRW4gPSBPKHZuLCBcInN0cmluZ1wiKSwgU24gPSB7XG4gIC4uLncsXG4gIGxldmVsOiB7IGRlZmF1bHQ6IDEsIHZhbHVlczogWzEsIDIsIDNdIH1cbn0sIENuID0gVyh7XG4gIG5hbWU6IFwiaGVhZGluZ1wiLFxuICBjb250ZW50OiBcImlubGluZSpcIixcbiAgZ3JvdXA6IFwiYmxvY2tDb250ZW50XCIsXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgIC8vIGluc3RlYWQgb2YgXCJsZXZlbFwiIGF0dHJpYnV0ZXMsIHVzZSBcImRhdGEtbGV2ZWxcIlxuICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1sZXZlbFwiKSwgZSA9IHBhcnNlSW50KHQpO1xuICAgICAgICAgIGlmIChpc0Zpbml0ZShlKSlcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXJIVE1MOiAobikgPT4gKHtcbiAgICAgICAgICBcImRhdGEtbGV2ZWxcIjogbi5sZXZlbC50b1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLi4uWzEsIDIsIDNdLm1hcCgobikgPT4gbmV3IGt0KHtcbiAgICAgICAgZmluZDogbmV3IFJlZ0V4cChgXigjeyR7bn19KVxcXFxzJGApLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZTogdCwgY2hhaW46IGUsIHJhbmdlOiBvIH0pID0+IHtcbiAgICAgICAgICBlKCkuQk5VcGRhdGVCbG9jayh0LnNlbGVjdGlvbi5mcm9tLCB7XG4gICAgICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIGxldmVsOiBuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuZGVsZXRlUmFuZ2UoeyBmcm9tOiBvLmZyb20sIHRvOiBvLnRvIH0pO1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICBdO1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJNb2QtQWx0LTFcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuQk5VcGRhdGVCbG9jayh0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCB7XG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxldmVsOiAxXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgXCJNb2QtQWx0LTJcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuQk5VcGRhdGVCbG9jayh0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCB7XG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxldmVsOiAyXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgXCJNb2QtQWx0LTNcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuQk5VcGRhdGVCbG9jayh0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCB7XG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGxldmVsOiAzXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkaXZbZGF0YS1jb250ZW50LXR5cGU9XCIgKyB0aGlzLm5hbWUgKyBcIl1cIixcbiAgICAgICAgZ2V0QXR0cnM6IChuKSA9PiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiID8gITEgOiB7XG4gICAgICAgICAgbGV2ZWw6IG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1sZXZlbFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6IFwiaDFcIixcbiAgICAgICAgYXR0cnM6IHsgbGV2ZWw6IDEgfSxcbiAgICAgICAgbm9kZTogXCJoZWFkaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJoMlwiLFxuICAgICAgICBhdHRyczogeyBsZXZlbDogMiB9LFxuICAgICAgICBub2RlOiBcImhlYWRpbmdcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImgzXCIsXG4gICAgICAgIGF0dHJzOiB7IGxldmVsOiAzIH0sXG4gICAgICAgIG5vZGU6IFwiaGVhZGluZ1wiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IG5vZGU6IG4sIEhUTUxBdHRyaWJ1dGVzOiB0IH0pIHtcbiAgICB2YXIgZSwgbztcbiAgICByZXR1cm4gWihcbiAgICAgIHRoaXMubmFtZSxcbiAgICAgIGBoJHtuLmF0dHJzLmxldmVsfWAsXG4gICAgICB7XG4gICAgICAgIC4uLigoZSA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogZS5ibG9ja0NvbnRlbnQpIHx8IHt9LFxuICAgICAgICAuLi50XG4gICAgICB9LFxuICAgICAgKChvID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBvLmlubGluZUNvbnRlbnQpIHx8IHt9XG4gICAgKTtcbiAgfVxufSksIFRuID0gdHQoXG4gIENuLFxuICBTblxuKSwgeG4gPSB7XG4gIHRleHRBbGlnbm1lbnQ6IHcudGV4dEFsaWdubWVudCxcbiAgYmFja2dyb3VuZENvbG9yOiB3LmJhY2tncm91bmRDb2xvcixcbiAgLy8gSW1hZ2UgdXJsLlxuICB1cmw6IHtcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sXG4gIC8vIEltYWdlIGNhcHRpb24uXG4gIGNhcHRpb246IHtcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sXG4gIC8vIEltYWdlIHdpZHRoIGluIHB4LlxuICB3aWR0aDoge1xuICAgIGRlZmF1bHQ6IDUxMlxuICB9XG59LCBBdCA9IChuKSA9PiB7XG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICByZXR1cm4gXCJmbGV4LXN0YXJ0XCI7XG4gICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICByZXR1cm4gXCJmbGV4LWVuZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJmbGV4LXN0YXJ0XCI7XG4gIH1cbn0sIEh0ID0gNjQsIE1uID0gKG4sIHQpID0+IHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGUuY2xhc3NOYW1lID0gXCJibi1pbWFnZS1ibG9jay1jb250ZW50LXdyYXBwZXJcIiwgZS5zdHlsZS5hbGlnbkl0ZW1zID0gQXQoXG4gICAgbi5wcm9wcy50ZXh0QWxpZ25tZW50XG4gICk7XG4gIGNvbnN0IG8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBvLmNsYXNzTmFtZSA9IFwiYm4tYWRkLWltYWdlLWJ1dHRvblwiO1xuICBjb25zdCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgci5jbGFzc05hbWUgPSBcImJuLWFkZC1pbWFnZS1idXR0b24taWNvblwiO1xuICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gIGkuY2xhc3NOYW1lID0gXCJibi1hZGQtaW1hZ2UtYnV0dG9uLXRleHRcIiwgaS5pbm5lclRleHQgPSBcIkFkZCBJbWFnZVwiO1xuICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcy5jbGFzc05hbWUgPSBcImJuLWltYWdlLWFuZC1jYXB0aW9uLXdyYXBwZXJcIjtcbiAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGEuY2xhc3NOYW1lID0gXCJibi1pbWFnZS13cmFwcGVyXCI7XG4gIGNvbnN0IGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICBsLmNsYXNzTmFtZSA9IFwiYm4taW1hZ2VcIiwgbC5zcmMgPSBuLnByb3BzLnVybCwgbC5hbHQgPSBcInBsYWNlaG9sZGVyXCIsIGwuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiLCBsLmRyYWdnYWJsZSA9ICExLCBsLnN0eWxlLndpZHRoID0gYCR7TWF0aC5taW4oXG4gICAgbi5wcm9wcy53aWR0aCxcbiAgICB0LmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xpZW50V2lkdGhcbiAgKX1weGA7XG4gIGNvbnN0IGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjLmNsYXNzTmFtZSA9IFwiYm4taW1hZ2UtcmVzaXplLWhhbmRsZVwiLCBjLnN0eWxlLmxlZnQgPSBcIjRweFwiO1xuICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcC5jbGFzc05hbWUgPSBcImJuLWltYWdlLXJlc2l6ZS1oYW5kbGVcIiwgcC5zdHlsZS5yaWdodCA9IFwiNHB4XCI7XG4gIGNvbnN0IHUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgdS5jbGFzc05hbWUgPSBcImJuLWltYWdlLWNhcHRpb25cIiwgdS5pbm5lclRleHQgPSBuLnByb3BzLmNhcHRpb24sIHUuc3R5bGUucGFkZGluZyA9IG4ucHJvcHMuY2FwdGlvbiA/IFwiNHB4XCIgOiBcIlwiO1xuICBjb25zdCBtID0gKCkgPT4ge1xuICAgIHZhciBjdDtcbiAgICBjb25zdCBnID0gKChjdCA9IHQuZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBjdC5ibG9ja3MpIHx8IFtdO1xuICAgIFt0LmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrLCAuLi5nXS5maW5kKFxuICAgICAgKGV0KSA9PiBldC5pZCA9PT0gbi5pZFxuICAgICkgIT09IHZvaWQgMCA/IChvLnN0eWxlLm91dGxpbmUgPSBcIjRweCBzb2xpZCByZ2IoMTAwLCAxNjAsIDI1NSlcIiwgcy5zdHlsZS5vdXRsaW5lID0gXCI0cHggc29saWQgcmdiKDEwMCwgMTYwLCAyNTUpXCIpIDogKG8uc3R5bGUub3V0bGluZSA9IFwiXCIsIHMuc3R5bGUub3V0bGluZSA9IFwiXCIpO1xuICB9O1xuICB0Lm9uRWRpdG9yQ29udGVudENoYW5nZShtKSwgdC5vbkVkaXRvclNlbGVjdGlvbkNoYW5nZShtKTtcbiAgbGV0IGg7XG4gIGNvbnN0IGYgPSAoZykgPT4ge1xuICAgIGlmICghaCkge1xuICAgICAgIXQuaXNFZGl0YWJsZSAmJiBhLmNvbnRhaW5zKGMpICYmIGEuY29udGFpbnMocCkgJiYgKGEucmVtb3ZlQ2hpbGQoYyksIGEucmVtb3ZlQ2hpbGQocCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgSTtcbiAgICBBdChuLnByb3BzLnRleHRBbGlnbm1lbnQpID09PSBcImNlbnRlclwiID8gaC5oYW5kbGVVc2VkID09PSBcImxlZnRcIiA/IEkgPSBoLmluaXRpYWxXaWR0aCArIChoLmluaXRpYWxDbGllbnRYIC0gZy5jbGllbnRYKSAqIDIgOiBJID0gaC5pbml0aWFsV2lkdGggKyAoZy5jbGllbnRYIC0gaC5pbml0aWFsQ2xpZW50WCkgKiAyIDogaC5oYW5kbGVVc2VkID09PSBcImxlZnRcIiA/IEkgPSBoLmluaXRpYWxXaWR0aCArIGguaW5pdGlhbENsaWVudFggLSBnLmNsaWVudFggOiBJID0gaC5pbml0aWFsV2lkdGggKyBnLmNsaWVudFggLSBoLmluaXRpYWxDbGllbnRYLCBJIDwgSHQgPyBsLnN0eWxlLndpZHRoID0gYCR7SHR9cHhgIDogSSA+IHQuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5jbGllbnRXaWR0aCA/IGwuc3R5bGUud2lkdGggPSBgJHt0LmRvbUVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xpZW50V2lkdGh9cHhgIDogbC5zdHlsZS53aWR0aCA9IGAke0l9cHhgO1xuICB9LCB5ID0gKGcpID0+IHtcbiAgICAoIWcudGFyZ2V0IHx8ICFhLmNvbnRhaW5zKGcudGFyZ2V0KSB8fCAhdC5pc0VkaXRhYmxlKSAmJiBhLmNvbnRhaW5zKGMpICYmIGEuY29udGFpbnMocCkgJiYgKGEucmVtb3ZlQ2hpbGQoYyksIGEucmVtb3ZlQ2hpbGQocCkpLCBoICYmIChoID0gdm9pZCAwLCB0LnVwZGF0ZUJsb2NrKG4sIHtcbiAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIC8vIFJlbW92ZXMgXCJweFwiIGZyb20gdGhlIGVuZCBvZiB0aGUgd2lkdGggc3RyaW5nIGFuZCBjb252ZXJ0cyB0byBmbG9hdC5cbiAgICAgICAgd2lkdGg6IHBhcnNlRmxvYXQobC5zdHlsZS53aWR0aC5zbGljZSgwLCAtMikpXG4gICAgICB9XG4gICAgfSkpO1xuICB9LCBTID0gKGcpID0+IHtcbiAgICBnLnByZXZlbnREZWZhdWx0KCk7XG4gIH0sIEIgPSAoKSA9PiB7XG4gICAgdC5fdGlwdGFwRWRpdG9yLnZpZXcuZGlzcGF0Y2goXG4gICAgICB0Ll90aXB0YXBFZGl0b3Iuc3RhdGUudHIuc2V0TWV0YSh0LmltYWdlVG9vbGJhci5wbHVnaW4sIHtcbiAgICAgICAgYmxvY2s6IG5cbiAgICAgIH0pXG4gICAgKTtcbiAgfSwgRSA9ICgpID0+IHtcbiAgICB0LmlzRWRpdGFibGUgJiYgKGEuYXBwZW5kQ2hpbGQoYyksIGEuYXBwZW5kQ2hpbGQocCkpO1xuICB9LCBEID0gKGcpID0+IHtcbiAgICBnLnJlbGF0ZWRUYXJnZXQgPT09IGMgfHwgZy5yZWxhdGVkVGFyZ2V0ID09PSBwIHx8IGggfHwgdC5pc0VkaXRhYmxlICYmIGEuY29udGFpbnMoYykgJiYgYS5jb250YWlucyhwKSAmJiAoYS5yZW1vdmVDaGlsZChjKSwgYS5yZW1vdmVDaGlsZChwKSk7XG4gIH0sIHogPSAoZykgPT4ge1xuICAgIGcucHJldmVudERlZmF1bHQoKSwgYS5hcHBlbmRDaGlsZChjKSwgYS5hcHBlbmRDaGlsZChwKSwgaCA9IHtcbiAgICAgIGhhbmRsZVVzZWQ6IFwibGVmdFwiLFxuICAgICAgaW5pdGlhbFdpZHRoOiBuLnByb3BzLndpZHRoLFxuICAgICAgaW5pdGlhbENsaWVudFg6IGcuY2xpZW50WFxuICAgIH07XG4gIH0sIEsgPSAoZykgPT4ge1xuICAgIGcucHJldmVudERlZmF1bHQoKSwgYS5hcHBlbmRDaGlsZChjKSwgYS5hcHBlbmRDaGlsZChwKSwgaCA9IHtcbiAgICAgIGhhbmRsZVVzZWQ6IFwicmlnaHRcIixcbiAgICAgIGluaXRpYWxXaWR0aDogbi5wcm9wcy53aWR0aCxcbiAgICAgIGluaXRpYWxDbGllbnRYOiBnLmNsaWVudFhcbiAgICB9O1xuICB9O1xuICByZXR1cm4gby5hcHBlbmRDaGlsZChyKSwgby5hcHBlbmRDaGlsZChpKSwgcy5hcHBlbmRDaGlsZChhKSwgYS5hcHBlbmRDaGlsZChsKSwgcy5hcHBlbmRDaGlsZCh1KSwgbi5wcm9wcy51cmwgPT09IFwiXCIgPyBlLmFwcGVuZENoaWxkKG8pIDogZS5hcHBlbmRDaGlsZChzKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZiksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB5KSwgby5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIFMpLCBvLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBCKSwgbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCBFKSwgbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBEKSwgYy5hZGRFdmVudExpc3RlbmVyKFxuICAgIFwibW91c2Vkb3duXCIsXG4gICAgelxuICApLCBwLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgXCJtb3VzZWRvd25cIixcbiAgICBLXG4gICksIHtcbiAgICBkb206IGUsXG4gICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgZiksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB5KSwgby5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNlZG93blwiLFxuICAgICAgICBTXG4gICAgICApLCBvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBCKSwgYy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNlZG93blwiLFxuICAgICAgICB6XG4gICAgICApLCBwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2Vkb3duXCIsXG4gICAgICAgIEtcbiAgICAgICk7XG4gICAgfVxuICB9O1xufSwgQm4gPSBkbihcbiAge1xuICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICBwcm9wU2NoZW1hOiB4bixcbiAgICBjb250ZW50OiBcIm5vbmVcIlxuICB9LFxuICB7XG4gICAgcmVuZGVyOiBNbixcbiAgICB0b0V4dGVybmFsSFRNTDogKG4pID0+IHtcbiAgICAgIGlmIChuLnByb3BzLnVybCA9PT0gXCJcIikge1xuICAgICAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgIHJldHVybiBvLmlubmVySFRNTCA9IFwiQWRkIEltYWdlXCIsIHtcbiAgICAgICAgICBkb206IG9cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmlndXJlXCIpLCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIGlmIChlLnNyYyA9IG4ucHJvcHMudXJsLCB0LmFwcGVuZENoaWxkKGUpLCBuLnByb3BzLmNhcHRpb24gIT09IFwiXCIpIHtcbiAgICAgICAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWdjYXB0aW9uXCIpO1xuICAgICAgICBvLmlubmVySFRNTCA9IG4ucHJvcHMuY2FwdGlvbiwgdC5hcHBlbmRDaGlsZChvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogdFxuICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlOiAobikgPT4ge1xuICAgICAgaWYgKG4udGFnTmFtZSA9PT0gXCJGSUdVUkVcIikge1xuICAgICAgICBjb25zdCB0ID0gbi5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpLCBlID0gbi5xdWVyeVNlbGVjdG9yKFwiZmlnY2FwdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1cmw6ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmdldEF0dHJpYnV0ZShcInNyY1wiKSkgfHwgXCJcIixcbiAgICAgICAgICBjYXB0aW9uOiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS50ZXh0Q29udGVudCkgfHwgKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZ2V0QXR0cmlidXRlKFwiYWx0XCIpKSB8fCB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobi50YWdOYW1lID09PSBcIklNR1wiKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVybDogbi5nZXRBdHRyaWJ1dGUoXCJzcmNcIikgfHwgXCJcIixcbiAgICAgICAgICBjYXB0aW9uOiBuLmdldEF0dHJpYnV0ZShcImFsdFwiKSB8fCB2b2lkIDBcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbiksIHZ0ID0gKG4pID0+IHtcbiAgY29uc3QgeyBub2RlOiB0LCBjb250ZW50VHlwZTogZSB9ID0gYihcbiAgICBuLnN0YXRlLmRvYyxcbiAgICBuLnN0YXRlLnNlbGVjdGlvbi5mcm9tXG4gICksIG8gPSBuLnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPT09IG4uc3RhdGUuc2VsZWN0aW9uLmhlYWQ7XG4gIHJldHVybiAhZS5uYW1lLmVuZHNXaXRoKFwiTGlzdEl0ZW1cIikgfHwgIW8gPyAhMSA6IG4uY29tbWFuZHMuZmlyc3QoKHsgc3RhdGU6IHIsIGNoYWluOiBpLCBjb21tYW5kczogcyB9KSA9PiBbXG4gICAgKCkgPT4gKFxuICAgICAgLy8gQ2hhbmdlcyBsaXN0IGl0ZW0gYmxvY2sgdG8gYSB0ZXh0IGJsb2NrIGlmIHRoZSBjb250ZW50IGlzIGVtcHR5LlxuICAgICAgcy5jb21tYW5kKCgpID0+IHQudGV4dENvbnRlbnQubGVuZ3RoID09PSAwID8gcy5CTlVwZGF0ZUJsb2NrKHIuc2VsZWN0aW9uLmZyb20sIHtcbiAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgcHJvcHM6IHt9XG4gICAgICB9KSA6ICExKVxuICAgICksXG4gICAgKCkgPT4gKFxuICAgICAgLy8gU3BsaXRzIHRoZSBjdXJyZW50IGJsb2NrLCBtb3ZpbmcgY29udGVudCBpbnNpZGUgdGhhdCdzIGFmdGVyIHRoZSBjdXJzb3IgdG8gYSBuZXcgYmxvY2sgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLy8gYmVsb3cuXG4gICAgICBzLmNvbW1hbmQoKCkgPT4gdC50ZXh0Q29udGVudC5sZW5ndGggPiAwID8gKGkoKS5kZWxldGVTZWxlY3Rpb24oKS5CTlNwbGl0QmxvY2soci5zZWxlY3Rpb24uZnJvbSwgITApLnJ1bigpLCAhMCkgOiAhMSlcbiAgICApXG4gIF0pO1xufSwgSW4gPSB7XG4gIC4uLndcbn0sIExuID0gVyh7XG4gIG5hbWU6IFwiYnVsbGV0TGlzdEl0ZW1cIixcbiAgY29udGVudDogXCJpbmxpbmUqXCIsXG4gIGdyb3VwOiBcImJsb2NrQ29udGVudFwiLFxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBDcmVhdGVzIGFuIHVub3JkZXJlZCBsaXN0IHdoZW4gc3RhcnRpbmcgd2l0aCBcIi1cIiwgXCIrXCIsIG9yIFwiKlwiLlxuICAgICAgbmV3IGt0KHtcbiAgICAgICAgZmluZDogbmV3IFJlZ0V4cChcIl5bLSsqXVxcXFxzJFwiKSxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGU6IG4sIGNoYWluOiB0LCByYW5nZTogZSB9KSA9PiB7XG4gICAgICAgICAgdCgpLkJOVXBkYXRlQmxvY2sobi5zZWxlY3Rpb24uZnJvbSwge1xuICAgICAgICAgICAgdHlwZTogXCJidWxsZXRMaXN0SXRlbVwiLFxuICAgICAgICAgICAgcHJvcHM6IHt9XG4gICAgICAgICAgfSkuZGVsZXRlUmFuZ2UoeyBmcm9tOiBlLmZyb20sIHRvOiBlLnRvIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBFbnRlcjogKCkgPT4gdnQodGhpcy5lZGl0b3IpLFxuICAgICAgXCJNb2QtU2hpZnQtOFwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5CTlVwZGF0ZUJsb2NrKHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIHtcbiAgICAgICAgdHlwZTogXCJidWxsZXRMaXN0SXRlbVwiLFxuICAgICAgICBwcm9wczoge31cbiAgICAgIH0pXG4gICAgfTtcbiAgfSxcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBDYXNlIGZvciByZWd1bGFyIEhUTUwgbGlzdCBzdHJ1Y3R1cmUuXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJkaXZbZGF0YS1jb250ZW50LXR5cGU9XCIgKyB0aGlzLm5hbWUgKyBcIl1cIlxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgaWYgd2UgY2FuJ3QgY29tZSB1cCB3aXRoIHRlc3QgY2FzZSB0aGF0IG5lZWRzIHRoaXNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJsaVwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBjb25zdCB0ID0gbi5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIHJldHVybiB0ID09PSBudWxsID8gITEgOiB0LnRhZ05hbWUgPT09IFwiVUxcIiB8fCB0LnRhZ05hbWUgPT09IFwiRElWXCIgJiYgdC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09IFwiVUxcIiA/IHt9IDogITE7XG4gICAgICAgIH0sXG4gICAgICAgIG5vZGU6IFwiYnVsbGV0TGlzdEl0ZW1cIlxuICAgICAgfSxcbiAgICAgIC8vIENhc2UgZm9yIEJsb2NrTm90ZSBsaXN0IHN0cnVjdHVyZS5cbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInBcIixcbiAgICAgICAgZ2V0QXR0cnM6IChuKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgY29uc3QgdCA9IG4ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICByZXR1cm4gdCA9PT0gbnVsbCA/ICExIDogdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbnRlbnQtdHlwZVwiKSA9PT0gXCJidWxsZXRMaXN0SXRlbVwiID8ge30gOiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJpb3JpdHk6IDMwMCxcbiAgICAgICAgbm9kZTogXCJidWxsZXRMaXN0SXRlbVwiXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBuIH0pIHtcbiAgICB2YXIgdCwgZTtcbiAgICByZXR1cm4gWihcbiAgICAgIHRoaXMubmFtZSxcbiAgICAgIC8vIFdlIHVzZSBhIDxwPiB0YWcsIGJlY2F1c2UgZm9yIDxsaT4gdGFncyB3ZSdkIG5lZWQgYSA8dWw+IGVsZW1lbnQgdG8gcHV0XG4gICAgICAvLyB0aGVtIGluIHRvIGJlIHNlbWFudGljYWxseSBjb3JyZWN0LCB3aGljaCB3ZSBjYW4ndCBoYXZlIGR1ZSB0byB0aGVcbiAgICAgIC8vIHNjaGVtYS5cbiAgICAgIFwicFwiLFxuICAgICAge1xuICAgICAgICAuLi4oKHQgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuYmxvY2tDb250ZW50KSB8fCB7fSxcbiAgICAgICAgLi4ublxuICAgICAgfSxcbiAgICAgICgoZSA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogZS5pbmxpbmVDb250ZW50KSB8fCB7fVxuICAgICk7XG4gIH1cbn0pLCBObiA9IHR0KFxuICBMbixcbiAgSW5cbiksIEFuID0gbmV3IFQoXCJudW1iZXJlZC1saXN0LWluZGV4aW5nXCIpLCBIbiA9ICgpID0+IG5ldyB2KHtcbiAga2V5OiBBbixcbiAgYXBwZW5kVHJhbnNhY3Rpb246IChuLCB0LCBlKSA9PiB7XG4gICAgY29uc3QgbyA9IGUudHI7XG4gICAgby5zZXRNZXRhKFwibnVtYmVyZWRMaXN0SW5kZXhpbmdcIiwgITApO1xuICAgIGxldCByID0gITE7XG4gICAgcmV0dXJuIGUuZG9jLmRlc2NlbmRhbnRzKChpLCBzKSA9PiB7XG4gICAgICBpZiAoaS50eXBlLm5hbWUgPT09IFwiYmxvY2tDb250YWluZXJcIiAmJiBpLmZpcnN0Q2hpbGQudHlwZS5uYW1lID09PSBcIm51bWJlcmVkTGlzdEl0ZW1cIikge1xuICAgICAgICBsZXQgYSA9IFwiMVwiO1xuICAgICAgICBjb25zdCBsID0gcyA9PT0gMSwgYyA9IGIoby5kb2MsIHMgKyAxKTtcbiAgICAgICAgaWYgKGMgPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghbCkge1xuICAgICAgICAgIGNvbnN0IG0gPSBiKG8uZG9jLCBzIC0gMik7XG4gICAgICAgICAgaWYgKG0gPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoIShjLmRlcHRoICE9PSBtLmRlcHRoKSkge1xuICAgICAgICAgICAgY29uc3QgZiA9IG0uY29udGVudE5vZGU7XG4gICAgICAgICAgICBpZiAobS5jb250ZW50VHlwZS5uYW1lID09PSBcIm51bWJlcmVkTGlzdEl0ZW1cIikge1xuICAgICAgICAgICAgICBjb25zdCBCID0gZi5hdHRycy5pbmRleDtcbiAgICAgICAgICAgICAgYSA9IChwYXJzZUludChCKSArIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGMuY29udGVudE5vZGUuYXR0cnMuaW5kZXggIT09IGEgJiYgKHIgPSAhMCwgby5zZXROb2RlTWFya3VwKHMgKyAxLCB2b2lkIDAsIHtcbiAgICAgICAgICBpbmRleDogYVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSksIHIgPyBvIDogbnVsbDtcbiAgfVxufSksIFBuID0ge1xuICAuLi53XG59LCBEbiA9IFcoe1xuICBuYW1lOiBcIm51bWJlcmVkTGlzdEl0ZW1cIixcbiAgY29udGVudDogXCJpbmxpbmUqXCIsXG4gIGdyb3VwOiBcImJsb2NrQ29udGVudFwiLFxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmdldEF0dHJpYnV0ZShcImRhdGEtaW5kZXhcIiksXG4gICAgICAgIHJlbmRlckhUTUw6IChuKSA9PiAoe1xuICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBuLmluZGV4XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQ3JlYXRlcyBhbiBvcmRlcmVkIGxpc3Qgd2hlbiBzdGFydGluZyB3aXRoIFwiMS5cIi5cbiAgICAgIG5ldyBrdCh7XG4gICAgICAgIGZpbmQ6IG5ldyBSZWdFeHAoXCJeMVxcXFwuXFxcXHMkXCIpLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZTogbiwgY2hhaW46IHQsIHJhbmdlOiBlIH0pID0+IHtcbiAgICAgICAgICB0KCkuQk5VcGRhdGVCbG9jayhuLnNlbGVjdGlvbi5mcm9tLCB7XG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlcmVkTGlzdEl0ZW1cIixcbiAgICAgICAgICAgIHByb3BzOiB7fVxuICAgICAgICAgIH0pLmRlbGV0ZVJhbmdlKHsgZnJvbTogZS5mcm9tLCB0bzogZS50byB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9LFxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRW50ZXI6ICgpID0+IHZ0KHRoaXMuZWRpdG9yKSxcbiAgICAgIFwiTW9kLVNoaWZ0LTdcIjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuQk5VcGRhdGVCbG9jayh0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyZWRMaXN0SXRlbVwiLFxuICAgICAgICBwcm9wczoge31cbiAgICAgIH0pXG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbSG4oKV07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwiZGl2W2RhdGEtY29udGVudC10eXBlPVwiICsgdGhpcy5uYW1lICsgXCJdXCJcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGlmIHdlIGNhbid0IGNvbWUgdXAgd2l0aCB0ZXN0IGNhc2UgdGhhdCBuZWVkcyB0aGlzXG4gICAgICB9LFxuICAgICAgLy8gQ2FzZSBmb3IgcmVndWxhciBIVE1MIGxpc3Qgc3RydWN0dXJlLlxuICAgICAgLy8gKGUuZy46IHdoZW4gcGFzdGluZyBmcm9tIG90aGVyIGFwcHMpXG4gICAgICB7XG4gICAgICAgIHRhZzogXCJsaVwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICBjb25zdCB0ID0gbi5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIHJldHVybiB0ID09PSBudWxsID8gITEgOiB0LnRhZ05hbWUgPT09IFwiT0xcIiB8fCB0LnRhZ05hbWUgPT09IFwiRElWXCIgJiYgdC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09IFwiT0xcIiA/IHt9IDogITE7XG4gICAgICAgIH0sXG4gICAgICAgIG5vZGU6IFwibnVtYmVyZWRMaXN0SXRlbVwiXG4gICAgICB9LFxuICAgICAgLy8gQ2FzZSBmb3IgQmxvY2tOb3RlIGxpc3Qgc3RydWN0dXJlLlxuICAgICAgLy8gKGUuZy46IHdoZW4gcGFzdGluZyBmcm9tIGJsb2Nrbm90ZSlcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInBcIixcbiAgICAgICAgZ2V0QXR0cnM6IChuKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgY29uc3QgdCA9IG4ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICByZXR1cm4gdCA9PT0gbnVsbCA/ICExIDogdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbnRlbnQtdHlwZVwiKSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCIgPyB7fSA6ICExO1xuICAgICAgICB9LFxuICAgICAgICBwcmlvcml0eTogMzAwLFxuICAgICAgICBub2RlOiBcIm51bWJlcmVkTGlzdEl0ZW1cIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogbiB9KSB7XG4gICAgdmFyIHQsIGU7XG4gICAgcmV0dXJuIFooXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICAvLyBXZSB1c2UgYSA8cD4gdGFnLCBiZWNhdXNlIGZvciA8bGk+IHRhZ3Mgd2UnZCBuZWVkIGFuIDxvbD4gZWxlbWVudCB0b1xuICAgICAgLy8gcHV0IHRoZW0gaW4gdG8gYmUgc2VtYW50aWNhbGx5IGNvcnJlY3QsIHdoaWNoIHdlIGNhbid0IGhhdmUgZHVlIHRvIHRoZVxuICAgICAgLy8gc2NoZW1hLlxuICAgICAgXCJwXCIsXG4gICAgICB7XG4gICAgICAgIC4uLigodCA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogdC5ibG9ja0NvbnRlbnQpIHx8IHt9LFxuICAgICAgICAuLi5uXG4gICAgICB9LFxuICAgICAgKChlID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBlLmlubGluZUNvbnRlbnQpIHx8IHt9XG4gICAgKTtcbiAgfVxufSksIE9uID0gdHQoXG4gIERuLFxuICBQblxuKSwgX24gPSB7XG4gIC4uLndcbn0sIFVuID0gVyh7XG4gIG5hbWU6IFwicGFyYWdyYXBoXCIsXG4gIGNvbnRlbnQ6IFwiaW5saW5lKlwiLFxuICBncm91cDogXCJibG9ja0NvbnRlbnRcIixcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEVudGVyOiAoKSA9PiB2dCh0aGlzLmVkaXRvciksXG4gICAgICBcIk1vZC1BbHQtMFwiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5CTlVwZGF0ZUJsb2NrKHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIHtcbiAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgcHJvcHM6IHt9XG4gICAgICB9KVxuICAgIH07XG4gIH0sXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB0YWc6IFwiZGl2W2RhdGEtY29udGVudC10eXBlPVwiICsgdGhpcy5uYW1lICsgXCJdXCIgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcInBcIixcbiAgICAgICAgcHJpb3JpdHk6IDIwMCxcbiAgICAgICAgbm9kZTogXCJwYXJhZ3JhcGhcIlxuICAgICAgfVxuICAgIF07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogbiB9KSB7XG4gICAgdmFyIHQsIGU7XG4gICAgcmV0dXJuIFooXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICBcInBcIixcbiAgICAgIHtcbiAgICAgICAgLi4uKCh0ID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiB0LmJsb2NrQ29udGVudCkgfHwge30sXG4gICAgICAgIC4uLm5cbiAgICAgIH0sXG4gICAgICAoKGUgPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaW5saW5lQ29udGVudCkgfHwge31cbiAgICApO1xuICB9XG59KSwgUm4gPSB0dChcbiAgVW4sXG4gIF9uXG4pLCB6biA9IE0uY3JlYXRlKHtcbiAgbmFtZTogXCJCbG9ja05vdGVUYWJsZUV4dGVuc2lvblwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnM6ICgpID0+IFtcbiAgICBVZSh7XG4gICAgICBjZWxsTWluV2lkdGg6IDEwMFxuICAgIH0pLFxuICAgIFJlKClcbiAgXSxcbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIE1ha2VzIGVudGVyIGNyZWF0ZSBhIG5ldyBsaW5lIHdpdGhpbiB0aGUgY2VsbC5cbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgdGhpcy5lZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLiRoZWFkLnBhcmVudC50eXBlLm5hbWUgPT09IFwidGFibGVQYXJhZ3JhcGhcIiA/ICh0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSwgITApIDogITEsXG4gICAgICAvLyBFbnN1cmVzIHRoYXQgYmFja3NwYWNlIHdvbid0IGRlbGV0ZSB0aGUgdGFibGUgaWYgdGhlIHRleHQgY3Vyc29yIGlzIGF0XG4gICAgICAvLyB0aGUgc3RhcnQgb2YgYSBjZWxsIGFuZCB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5LlxuICAgICAgQmFja3NwYWNlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb24sIHQgPSBuLmVtcHR5LCBlID0gbi4kaGVhZC5wYXJlbnRPZmZzZXQgPT09IDAsIG8gPSBuLiRoZWFkLm5vZGUoKS50eXBlLm5hbWUgPT09IFwidGFibGVQYXJhZ3JhcGhcIjtcbiAgICAgICAgcmV0dXJuIHQgJiYgZSAmJiBvO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGV4dGVuZE5vZGVTY2hlbWEobikge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICBuYW1lOiBuLm5hbWUsXG4gICAgICBvcHRpb25zOiBuLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBuLnN0b3JhZ2VcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZVJvbGU6IHdlKFxuICAgICAgICB2ZShuLCBcInRhYmxlUm9sZVwiLCB0KVxuICAgICAgKVxuICAgIH07XG4gIH1cbn0pLCBWbiA9IHtcbiAgLi4ud1xufSwgRm4gPSBXKHtcbiAgbmFtZTogXCJ0YWJsZVwiLFxuICBjb250ZW50OiBcInRhYmxlUm93K1wiLFxuICBncm91cDogXCJibG9ja0NvbnRlbnRcIixcbiAgdGFibGVSb2xlOiBcInRhYmxlXCIsXG4gIGlzb2xhdGluZzogITAsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiBcInRhYmxlXCIgfV07XG4gIH0sXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlczogbiB9KSB7XG4gICAgdmFyIHQsIGU7XG4gICAgcmV0dXJuIFooXG4gICAgICB0aGlzLm5hbWUsXG4gICAgICBcInRhYmxlXCIsXG4gICAgICB7XG4gICAgICAgIC4uLigodCA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogdC5ibG9ja0NvbnRlbnQpIHx8IHt9LFxuICAgICAgICAuLi5uXG4gICAgICB9LFxuICAgICAgKChlID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBlLmlubGluZUNvbnRlbnQpIHx8IHt9XG4gICAgKTtcbiAgfVxufSksICRuID0gai5jcmVhdGUoe1xuICBuYW1lOiBcInRhYmxlUGFyYWdyYXBoXCIsXG4gIGdyb3VwOiBcInRhYmxlQ29udGVudFwiLFxuICBjb250ZW50OiBcImlubGluZSpcIixcbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6IFwicFwiIH1dO1xuICB9LFxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXM6IG4gfSkge1xuICAgIHJldHVybiBbXG4gICAgICBcInBcIixcbiAgICAgIEVlKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgbiksXG4gICAgICAwXG4gICAgXTtcbiAgfVxufSksIEduID0gdHQoXG4gIEZuLFxuICBWbixcbiAgW1xuICAgIHpuLFxuICAgICRuLFxuICAgIE9lLmV4dGVuZCh7XG4gICAgICBjb250ZW50OiBcInRhYmxlQ29udGVudFwiXG4gICAgfSksXG4gICAgRGUuZXh0ZW5kKHtcbiAgICAgIGNvbnRlbnQ6IFwidGFibGVDb250ZW50XCJcbiAgICB9KSxcbiAgICBfZVxuICBdXG4pLCBvZSA9IHtcbiAgcGFyYWdyYXBoOiBSbixcbiAgaGVhZGluZzogVG4sXG4gIGJ1bGxldExpc3RJdGVtOiBObixcbiAgbnVtYmVyZWRMaXN0SXRlbTogT24sXG4gIGltYWdlOiBCbixcbiAgdGFibGU6IEduXG59LCBqbiA9IFp0KG9lKSwgcmUgPSB7XG4gIGJvbGQ6IE8oTGUsIFwiYm9vbGVhblwiKSxcbiAgaXRhbGljOiBPKEFlLCBcImJvb2xlYW5cIiksXG4gIHVuZGVybGluZTogTyhQZSwgXCJib29sZWFuXCIpLFxuICBzdHJpa2U6IE8oSGUsIFwiYm9vbGVhblwiKSxcbiAgY29kZTogTyhOZSwgXCJib29sZWFuXCIpLFxuICB0ZXh0Q29sb3I6IEVuLFxuICBiYWNrZ3JvdW5kQ29sb3I6IHduXG59LCBfciA9IG5lKHJlKSwgaWUgPSB7XG4gIHRleHQ6IHsgY29uZmlnOiBcInRleHRcIiwgaW1wbGVtZW50YXRpb246IHt9IH0sXG4gIGxpbms6IHsgY29uZmlnOiBcImxpbmtcIiwgaW1wbGVtZW50YXRpb246IHt9IH1cbn0sIFVyID0gdGUoXG4gIGllXG4pO1xuZnVuY3Rpb24gTChuLCB0KSB7XG4gIHJldHVybiBuIGluIHQuc2NoZW1hLmJsb2NrU2NoZW1hICYmIHQuc2NoZW1hLmJsb2NrU2NoZW1hW25dID09PSBqbltuXTtcbn1cbmZ1bmN0aW9uIFJyKG4sIHQsIGUpIHtcbiAgcmV0dXJuIHQudHlwZSA9PT0gbiAmJiB0LnR5cGUgaW4gZS5zY2hlbWEuYmxvY2tTY2hlbWEgJiYgTCh0LnR5cGUsIGUpO1xufVxuZnVuY3Rpb24gV24obiwgdCwgZSkge1xuICByZXR1cm4gdCBpbiBlLnNjaGVtYS5ibG9ja1NjaGVtYSAmJiBuIGluIGUuc2NoZW1hLmJsb2NrU2NoZW1hW3RdLnByb3BTY2hlbWEgJiYgZS5zY2hlbWEuYmxvY2tTY2hlbWFbdF0ucHJvcFNjaGVtYVtuXSA9PT0gd1tuXTtcbn1cbmZ1bmN0aW9uIHpyKG4sIHQsIGUpIHtcbiAgcmV0dXJuIFduKG4sIHQudHlwZSwgZSk7XG59XG5mdW5jdGlvbiBFdChuLCB0KSB7XG4gIGxldCBlLCBvO1xuICBpZiAodC5maXJzdENoaWxkLmRlc2NlbmRhbnRzKChyLCBpKSA9PiBlID8gITEgOiByLnR5cGUubmFtZSAhPT0gXCJibG9ja0NvbnRhaW5lclwiIHx8IHIuYXR0cnMuaWQgIT09IG4gPyAhMCA6IChlID0gciwgbyA9IGkgKyAxLCAhMSkpLCBlID09PSB2b2lkIDAgfHwgbyA9PT0gdm9pZCAwKVxuICAgIHRocm93IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2sgaW4gdGhlIGVkaXRvciB3aXRoIG1hdGNoaW5nIElELlwiKTtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBlLFxuICAgIHBvc0JlZm9yZU5vZGU6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIHFuKG4sIHQsIGUgPSBcImJlZm9yZVwiLCBvKSB7XG4gIGNvbnN0IHIgPSBvLl90aXB0YXBFZGl0b3IsIGkgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQuaWQsIHMgPSBbXTtcbiAgZm9yIChjb25zdCBwIG9mIG4pXG4gICAgcy5wdXNoKFxuICAgICAgUChwLCByLnNjaGVtYSwgby5zY2hlbWEuc3R5bGVTY2hlbWEpXG4gICAgKTtcbiAgY29uc3QgeyBub2RlOiBhLCBwb3NCZWZvcmVOb2RlOiBsIH0gPSBFdChpLCByLnN0YXRlLmRvYyk7XG4gIGlmIChlID09PSBcImJlZm9yZVwiICYmIHIudmlldy5kaXNwYXRjaChcbiAgICByLnN0YXRlLnRyLmluc2VydChsLCBzKVxuICApLCBlID09PSBcImFmdGVyXCIgJiYgci52aWV3LmRpc3BhdGNoKFxuICAgIHIuc3RhdGUudHIuaW5zZXJ0KGwgKyBhLm5vZGVTaXplLCBzKVxuICApLCBlID09PSBcIm5lc3RlZFwiICYmIGEuY2hpbGRDb3VudCA8IDIpIHtcbiAgICBjb25zdCBwID0gci5zdGF0ZS5zY2hlbWEubm9kZXMuYmxvY2tHcm91cC5jcmVhdGUoXG4gICAgICB7fSxcbiAgICAgIHNcbiAgICApO1xuICAgIHIudmlldy5kaXNwYXRjaChcbiAgICAgIHIuc3RhdGUudHIuaW5zZXJ0KFxuICAgICAgICBsICsgYS5maXJzdENoaWxkLm5vZGVTaXplICsgMSxcbiAgICAgICAgcFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgY29uc3QgYyA9IFtdO1xuICBmb3IgKGNvbnN0IHAgb2YgcylcbiAgICBjLnB1c2goXG4gICAgICBrKFxuICAgICAgICBwLFxuICAgICAgICBvLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgICAgby5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgby5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgIG8uYmxvY2tDYWNoZVxuICAgICAgKVxuICAgICk7XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gS24obiwgdCwgZSkge1xuICBjb25zdCBvID0gZS5fdGlwdGFwRWRpdG9yLCByID0gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiA/IG4gOiBuLmlkLCB7IHBvc0JlZm9yZU5vZGU6IGkgfSA9IEV0KHIsIG8uc3RhdGUuZG9jKTtcbiAgby5jb21tYW5kcy5CTlVwZGF0ZUJsb2NrKGkgKyAxLCB0KTtcbiAgY29uc3QgcyA9IG8uc3RhdGUuZG9jLnJlc29sdmUoaSArIDEpLm5vZGUoKTtcbiAgcmV0dXJuIGsoXG4gICAgcyxcbiAgICBlLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICBlLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgIGUuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgIGUuYmxvY2tDYWNoZVxuICApO1xufVxuZnVuY3Rpb24gc2UobiwgdCwgZSkge1xuICBjb25zdCBvID0gdC5fdGlwdGFwRWRpdG9yLCByID0gby5zdGF0ZS50ciwgaSA9IG5ldyBTZXQoXG4gICAgbi5tYXAoXG4gICAgICAobCkgPT4gdHlwZW9mIGwgPT0gXCJzdHJpbmdcIiA/IGwgOiBsLmlkXG4gICAgKVxuICApLCBzID0gW107XG4gIGxldCBhID0gMDtcbiAgaWYgKG8uc3RhdGUuZG9jLmRlc2NlbmRhbnRzKChsLCBjKSA9PiB7XG4gICAgaWYgKGkuc2l6ZSA9PT0gMClcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAobC50eXBlLm5hbWUgIT09IFwiYmxvY2tDb250YWluZXJcIiB8fCAhaS5oYXMobC5hdHRycy5pZCkpXG4gICAgICByZXR1cm4gITA7XG4gICAgcy5wdXNoKFxuICAgICAgayhcbiAgICAgICAgbCxcbiAgICAgICAgdC5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICAgIHQuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICAgIHQuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgICB0LmJsb2NrQ2FjaGVcbiAgICAgIClcbiAgICApLCBpLmRlbGV0ZShsLmF0dHJzLmlkKSwgYSA9IChlID09IG51bGwgPyB2b2lkIDAgOiBlKGwsIGMsIHIsIGEpKSB8fCBhO1xuICAgIGNvbnN0IHAgPSByLmRvYy5ub2RlU2l6ZTtcbiAgICByLmRlbGV0ZShjIC0gYSAtIDEsIGMgLSBhICsgbC5ub2RlU2l6ZSArIDEpO1xuICAgIGNvbnN0IHUgPSByLmRvYy5ub2RlU2l6ZTtcbiAgICByZXR1cm4gYSArPSBwIC0gdSwgITE7XG4gIH0pLCBpLnNpemUgPiAwKSB7XG4gICAgY29uc3QgbCA9IFsuLi5pXS5qb2luKGBcbmApO1xuICAgIHRocm93IEVycm9yKFxuICAgICAgXCJCbG9ja3Mgd2l0aCB0aGUgZm9sbG93aW5nIElEcyBjb3VsZCBub3QgYmUgZm91bmQgaW4gdGhlIGVkaXRvcjogXCIgKyBsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gby52aWV3LmRpc3BhdGNoKHIpLCBzO1xufVxuZnVuY3Rpb24gSm4obiwgdCkge1xuICByZXR1cm4gc2UobiwgdCk7XG59XG5mdW5jdGlvbiBYbihuLCB0LCBlKSB7XG4gIGNvbnN0IG8gPSBlLl90aXB0YXBFZGl0b3IsIHIgPSBbXTtcbiAgZm9yIChjb25zdCBsIG9mIHQpXG4gICAgci5wdXNoKFxuICAgICAgUChsLCBvLnNjaGVtYSwgZS5zY2hlbWEuc3R5bGVTY2hlbWEpXG4gICAgKTtcbiAgY29uc3QgaSA9IHR5cGVvZiBuWzBdID09IFwic3RyaW5nXCIgPyBuWzBdIDogblswXS5pZCwgcyA9IHNlKFxuICAgIG4sXG4gICAgZSxcbiAgICAobCwgYywgcCwgdSkgPT4ge1xuICAgICAgaWYgKGwuYXR0cnMuaWQgPT09IGkpIHtcbiAgICAgICAgY29uc3QgbSA9IHAuZG9jLm5vZGVTaXplO1xuICAgICAgICBwLmluc2VydChjLCByKTtcbiAgICAgICAgY29uc3QgaCA9IHAuZG9jLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gdSArIG0gLSBoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHU7XG4gICAgfVxuICApLCBhID0gW107XG4gIGZvciAoY29uc3QgbCBvZiByKVxuICAgIGEucHVzaChcbiAgICAgIGsoXG4gICAgICAgIGwsXG4gICAgICAgIGUuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgICBlLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgICBlLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgICAgZS5ibG9ja0NhY2hlXG4gICAgICApXG4gICAgKTtcbiAgcmV0dXJuIHsgaW5zZXJ0ZWRCbG9ja3M6IGEsIHJlbW92ZWRCbG9ja3M6IHMgfTtcbn1cbmZ1bmN0aW9uIFluKG4sIHQsIGUsIG8gPSB7IHVwZGF0ZVNlbGVjdGlvbjogITAgfSkge1xuICBjb25zdCByID0gZS5fdGlwdGFwRWRpdG9yLCBpID0gci5zdGF0ZS50cjtcbiAgbGV0IHsgZnJvbTogcywgdG86IGEgfSA9IHR5cGVvZiBuID09IFwibnVtYmVyXCIgPyB7IGZyb206IG4sIHRvOiBuIH0gOiB7IGZyb206IG4uZnJvbSwgdG86IG4udG8gfSwgbCA9ICEwLCBjID0gITAsIHAgPSBcIlwiO1xuICBpZiAodC5mb3JFYWNoKCh1KSA9PiB7XG4gICAgdS5jaGVjaygpLCBsICYmIHUuaXNUZXh0ICYmIHUubWFya3MubGVuZ3RoID09PSAwID8gcCArPSB1LnRleHQgOiBsID0gITEsIGMgPSBjID8gdS5pc0Jsb2NrIDogITE7XG4gIH0pLCBzID09PSBhICYmIGMpIHtcbiAgICBjb25zdCB7IHBhcmVudDogdSB9ID0gaS5kb2MucmVzb2x2ZShzKTtcbiAgICB1LmlzVGV4dGJsb2NrICYmICF1LnR5cGUuc3BlYy5jb2RlICYmICF1LmNoaWxkQ291bnQgJiYgKHMgLT0gMSwgYSArPSAxKTtcbiAgfVxuICByZXR1cm4gbCA/IGkuaW5zZXJ0VGV4dChwLCBzLCBhKSA6IGkucmVwbGFjZVdpdGgocywgYSwgdCksIG8udXBkYXRlU2VsZWN0aW9uICYmIFNlKGksIGkuc3RlcHMubGVuZ3RoIC0gMSwgLTEpLCByLnZpZXcuZGlzcGF0Y2goaSksICEwO1xufVxuZnVuY3Rpb24gUW4oKSB7XG4gIGNvbnN0IG4gPSAodCkgPT4ge1xuICAgIGxldCBlID0gdC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBlOyBvKyspIHtcbiAgICAgIGNvbnN0IHIgPSB0LmNoaWxkcmVuW29dO1xuICAgICAgaWYgKHIudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgKG4ociksIHIudGFnTmFtZSA9PT0gXCJ1XCIpKVxuICAgICAgICBpZiAoci5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdC5jaGlsZHJlbi5zcGxpY2UobywgMSwgLi4uci5jaGlsZHJlbik7XG4gICAgICAgICAgY29uc3QgaSA9IHIuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgICBlICs9IGksIG8gKz0gaTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdC5jaGlsZHJlbi5zcGxpY2UobywgMSksIGUtLSwgby0tO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBTdChuKSB7XG4gIHJldHVybiBidCgpLnVzZShSdCwgeyBmcmFnbWVudDogITAgfSkudXNlKFFuKS51c2UoemUpLnVzZShWdCkudXNlKFZlKS5wcm9jZXNzU3luYyhuKS52YWx1ZTtcbn1cbmZ1bmN0aW9uIFpuKG4sIHQsIGUpIHtcbiAgY29uc3QgciA9IGF0KHQsIGUpLmV4cG9ydEJsb2NrcyhuKTtcbiAgcmV0dXJuIFN0KHIpO1xufVxuZnVuY3Rpb24gdG8obikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChuLnBhcmVudEVsZW1lbnQuY2hpbGROb2Rlcywgbik7XG59XG5mdW5jdGlvbiBlbyhuKSB7XG4gIHJldHVybiBuLm5vZGVUeXBlID09PSAzICYmICEvXFxTLy50ZXN0KG4ubm9kZVZhbHVlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gbm8obikge1xuICBuLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaSA+IHVsLCBsaSA+IG9sXCIpLmZvckVhY2goKHQpID0+IHtcbiAgICBjb25zdCBlID0gdG8odCksIG8gPSB0LnBhcmVudEVsZW1lbnQsIHIgPSBBcnJheS5mcm9tKG8uY2hpbGROb2Rlcykuc2xpY2UoXG4gICAgICBlICsgMVxuICAgICk7XG4gICAgdC5yZW1vdmUoKSwgci5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBpLnJlbW92ZSgpO1xuICAgIH0pLCBvLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIHQpLCByLnJldmVyc2UoKS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBpZiAoZW8oaSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgICBzLmFwcGVuZChpKSwgdC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLCBzKTtcbiAgICB9KSwgby5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCAmJiBvLnJlbW92ZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9vKG4pIHtcbiAgbi5xdWVyeVNlbGVjdG9yQWxsKFwibGkgKyB1bCwgbGkgKyBvbFwiKS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgdmFyIGksIHM7XG4gICAgY29uc3QgZSA9IHQucHJldmlvdXNFbGVtZW50U2libGluZywgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLCBvKSwgby5hcHBlbmQoZSk7XG4gICAgY29uc3QgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZm9yIChyLnNldEF0dHJpYnV0ZShcImRhdGEtbm9kZS10eXBlXCIsIFwiYmxvY2tHcm91cFwiKSwgby5hcHBlbmQocik7ICgoaSA9IG8ubmV4dEVsZW1lbnRTaWJsaW5nKSA9PSBudWxsID8gdm9pZCAwIDogaS5ub2RlTmFtZSkgPT09IFwiVUxcIiB8fCAoKHMgPSBvLm5leHRFbGVtZW50U2libGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IHMubm9kZU5hbWUpID09PSBcIk9MXCI7IClcbiAgICAgIHIuYXBwZW5kKG8ubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgfSk7XG59XG5sZXQgUHQgPSBudWxsO1xuZnVuY3Rpb24gcm8oKSB7XG4gIHJldHVybiBQdCB8fCAoUHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0aXRsZVwiKSk7XG59XG5mdW5jdGlvbiBhZShuKSB7XG4gIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgdCA9IHJvKCkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0LmlubmVySFRNTCA9IG4sIG4gPSB0O1xuICB9XG4gIHJldHVybiBubyhuKSwgb28obiksIG47XG59XG5hc3luYyBmdW5jdGlvbiBsZShuLCB0LCBlLCBvLCByKSB7XG4gIGNvbnN0IGkgPSBhZShuKSwgYSA9IGZlLmZyb21TY2hlbWEocikucGFyc2UoaSwge1xuICAgIHRvcE5vZGU6IHIubm9kZXMuYmxvY2tHcm91cC5jcmVhdGUoKVxuICB9KSwgbCA9IFtdO1xuICBmb3IgKGxldCBjID0gMDsgYyA8IGEuY2hpbGRDb3VudDsgYysrKVxuICAgIGwucHVzaChcbiAgICAgIGsoYS5jaGlsZChjKSwgdCwgZSwgbylcbiAgICApO1xuICByZXR1cm4gbDtcbn1cbmZ1bmN0aW9uIGlvKG4sIHQpIHtcbiAgY29uc3QgZSA9IHQudmFsdWUgPyB0LnZhbHVlICsgYFxuYCA6IFwiXCIsIG8gPSB7fTtcbiAgdC5sYW5nICYmIChvW1wiZGF0YS1sYW5ndWFnZVwiXSA9IHQubGFuZyk7XG4gIGxldCByID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiY29kZVwiLFxuICAgIHByb3BlcnRpZXM6IG8sXG4gICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogZSB9XVxuICB9O1xuICByZXR1cm4gdC5tZXRhICYmIChyLmRhdGEgPSB7IG1ldGE6IHQubWV0YSB9KSwgbi5wYXRjaCh0LCByKSwgciA9IG4uYXBwbHlEYXRhKHQsIHIpLCByID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwicHJlXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IFtyXVxuICB9LCBuLnBhdGNoKHQsIHIpLCByO1xufVxuZnVuY3Rpb24gc28obiwgdCwgZSwgbywgcikge1xuICBjb25zdCBpID0gYnQoKS51c2UoRmUpLnVzZShWdCkudXNlKCRlLCB7XG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIC4uLkdlLFxuICAgICAgY29kZTogaW9cbiAgICB9XG4gIH0pLnVzZSh6dCkucHJvY2Vzc1N5bmMobik7XG4gIHJldHVybiBsZShcbiAgICBpLnZhbHVlLFxuICAgIHQsXG4gICAgZSxcbiAgICBvLFxuICAgIHJcbiAgKTtcbn1cbmNsYXNzIHEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGQodGhpcywgXCJjYWxsYmFja3NcIiwge30pO1xuICB9XG4gIG9uKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFja3NbdF0gfHwgKHRoaXMuY2FsbGJhY2tzW3RdID0gW10pLCB0aGlzLmNhbGxiYWNrc1t0XS5wdXNoKGUpLCAoKSA9PiB0aGlzLm9mZih0LCBlKTtcbiAgfVxuICBlbWl0KHQsIC4uLmUpIHtcbiAgICBjb25zdCBvID0gdGhpcy5jYWxsYmFja3NbdF07XG4gICAgbyAmJiBvLmZvckVhY2goKHIpID0+IHIuYXBwbHkodGhpcywgZSkpO1xuICB9XG4gIG9mZih0LCBlKSB7XG4gICAgY29uc3QgbyA9IHRoaXMuY2FsbGJhY2tzW3RdO1xuICAgIG8gJiYgKGUgPyB0aGlzLmNhbGxiYWNrc1t0XSA9IG8uZmlsdGVyKChyKSA9PiByICE9PSBlKSA6IGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1t0XSk7XG4gIH1cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gIH1cbn1cbmNsYXNzIGFvIHtcbiAgY29uc3RydWN0b3IodCwgZSwgbykge1xuICAgIGQodGhpcywgXCJzdGF0ZVwiKTtcbiAgICBkKHRoaXMsIFwiZW1pdFVwZGF0ZVwiKTtcbiAgICBkKHRoaXMsIFwicHJldmVudEhpZGVcIiwgITEpO1xuICAgIGQodGhpcywgXCJwcmV2ZW50U2hvd1wiLCAhMSk7XG4gICAgZCh0aGlzLCBcInByZXZXYXNFZGl0YWJsZVwiLCBudWxsKTtcbiAgICBkKHRoaXMsIFwic2hvdWxkU2hvd1wiLCAoeyBzdGF0ZTogdCB9KSA9PiAhdC5zZWxlY3Rpb24uZW1wdHkpO1xuICAgIGQodGhpcywgXCJ2aWV3TW91c2Vkb3duSGFuZGxlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnByZXZlbnRTaG93ID0gITA7XG4gICAgfSk7XG4gICAgZCh0aGlzLCBcInZpZXdNb3VzZXVwSGFuZGxlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnByZXZlbnRTaG93ID0gITEsIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGUodGhpcy5wbVZpZXcpKTtcbiAgICB9KTtcbiAgICAvLyBGb3IgZHJhZ2dpbmcgdGhlIHdob2xlIGVkaXRvci5cbiAgICBkKHRoaXMsIFwiZHJhZ0hhbmRsZXJcIiwgKCkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICAodCA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgdC5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCkpO1xuICAgIH0pO1xuICAgIGQodGhpcywgXCJmb2N1c0hhbmRsZXJcIiwgKCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnVwZGF0ZSh0aGlzLnBtVmlldykpO1xuICAgIH0pO1xuICAgIGQodGhpcywgXCJibHVySGFuZGxlclwiLCAodCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICBpZiAodGhpcy5wcmV2ZW50SGlkZSkge1xuICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGUgPSB0aGlzLnBtVmlldy5kb20ucGFyZW50RWxlbWVudDtcbiAgICAgIC8vIEFuIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgIHQgJiYgdC5yZWxhdGVkVGFyZ2V0ICYmIC8vIEVsZW1lbnQgaXMgaW5zaWRlIHRoZSBlZGl0b3IuXG4gICAgICAoZSA9PT0gdC5yZWxhdGVkVGFyZ2V0IHx8IGUuY29udGFpbnModC5yZWxhdGVkVGFyZ2V0KSkgfHwgKG8gPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIG8uc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgICB9KTtcbiAgICBkKHRoaXMsIFwic2Nyb2xsSGFuZGxlclwiLCAoKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgICh0ID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiB0LnNob3cgJiYgKHRoaXMuc3RhdGUucmVmZXJlbmNlUG9zID0gdGhpcy5nZXRTZWxlY3Rpb25Cb3VuZGluZ0JveCgpLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSB0LCB0aGlzLnBtVmlldyA9IGUsIHRoaXMuZW1pdFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQXR0ZW1wdGluZyB0byB1cGRhdGUgdW5pbml0aWFsaXplZCBmb3JtYXR0aW5nIHRvb2xiYXJcIlxuICAgICAgICApO1xuICAgICAgbyh0aGlzLnN0YXRlKTtcbiAgICB9LCBlLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMudmlld01vdXNlZG93bkhhbmRsZXIpLCBlLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnZpZXdNb3VzZXVwSGFuZGxlciksIGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgdGhpcy5kcmFnSGFuZGxlciksIGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLmRyYWdIYW5kbGVyKSwgZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZm9jdXNIYW5kbGVyKSwgZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5ibHVySGFuZGxlciksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgfVxuICB1cGRhdGUodCwgZSkge1xuICAgIHZhciBtLCBoO1xuICAgIGNvbnN0IHsgc3RhdGU6IG8sIGNvbXBvc2luZzogciB9ID0gdCwgeyBkb2M6IGksIHNlbGVjdGlvbjogcyB9ID0gbywgYSA9IGUgJiYgZS5kb2MuZXEoaSkgJiYgZS5zZWxlY3Rpb24uZXEocyk7XG4gICAgaWYgKCh0aGlzLnByZXZXYXNFZGl0YWJsZSA9PT0gbnVsbCB8fCB0aGlzLnByZXZXYXNFZGl0YWJsZSA9PT0gdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkgJiYgKHIgfHwgYSkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5wcmV2V2FzRWRpdGFibGUgPSB0aGlzLmVkaXRvci5pc0VkaXRhYmxlO1xuICAgIGNvbnN0IHsgcmFuZ2VzOiBsIH0gPSBzLCBjID0gTWF0aC5taW4oLi4ubC5tYXAoKGYpID0+IGYuJGZyb20ucG9zKSksIHAgPSBNYXRoLm1heCguLi5sLm1hcCgoZikgPT4gZi4kdG8ucG9zKSksIHUgPSAobSA9IHRoaXMuc2hvdWxkU2hvdykgPT0gbnVsbCA/IHZvaWQgMCA6IG0uY2FsbCh0aGlzLCB7XG4gICAgICB2aWV3OiB0LFxuICAgICAgc3RhdGU6IG8sXG4gICAgICBmcm9tOiBjLFxuICAgICAgdG86IHBcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lZGl0b3IuaXNFZGl0YWJsZSAmJiAhdGhpcy5wcmV2ZW50U2hvdyAmJiAodSB8fCB0aGlzLnByZXZlbnRIaWRlKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc2hvdzogITAsXG4gICAgICAgIHJlZmVyZW5jZVBvczogdGhpcy5nZXRTZWxlY3Rpb25Cb3VuZGluZ0JveCgpXG4gICAgICB9LCB0aGlzLmVtaXRVcGRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChoID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBoLnNob3cgJiYgIXRoaXMucHJldmVudEhpZGUgJiYgKCF1IHx8IHRoaXMucHJldmVudFNob3cgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpKSB7XG4gICAgICB0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy52aWV3TW91c2Vkb3duSGFuZGxlciksIHRoaXMucG1WaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnZpZXdNb3VzZXVwSGFuZGxlciksIHRoaXMucG1WaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIHRoaXMuZHJhZ0hhbmRsZXIpLCB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuZHJhZ0hhbmRsZXIpLCB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZm9jdXNIYW5kbGVyKSwgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuYmx1ckhhbmRsZXIpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gIH1cbiAgZ2V0U2VsZWN0aW9uQm91bmRpbmdCb3goKSB7XG4gICAgY29uc3QgeyBzdGF0ZTogdCB9ID0gdGhpcy5wbVZpZXcsIHsgc2VsZWN0aW9uOiBlIH0gPSB0LCB7IHJhbmdlczogbyB9ID0gZSwgciA9IE1hdGgubWluKC4uLm8ubWFwKChzKSA9PiBzLiRmcm9tLnBvcykpLCBpID0gTWF0aC5tYXgoLi4uby5tYXAoKHMpID0+IHMuJHRvLnBvcykpO1xuICAgIGlmIChDZShlKSkge1xuICAgICAgY29uc3QgcyA9IHRoaXMucG1WaWV3Lm5vZGVET00ocik7XG4gICAgICBpZiAocylcbiAgICAgICAgcmV0dXJuIHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBtdCh0aGlzLnBtVmlldywgciwgaSk7XG4gIH1cbn1cbmNvbnN0IGxvID0gbmV3IFQoXG4gIFwiRm9ybWF0dGluZ1Rvb2xiYXJQbHVnaW5cIlxuKTtcbmNsYXNzIGNvIGV4dGVuZHMgcSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICAgIGQodGhpcywgXCJ2aWV3XCIpO1xuICAgIGQodGhpcywgXCJwbHVnaW5cIik7XG4gICAgdGhpcy5wbHVnaW4gPSBuZXcgdih7XG4gICAgICBrZXk6IGxvLFxuICAgICAgdmlldzogKG8pID0+ICh0aGlzLnZpZXcgPSBuZXcgYW8oZSwgbywgKHIpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHIpO1xuICAgICAgfSksIHRoaXMudmlldylcbiAgICB9KTtcbiAgfVxuICBvblVwZGF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMub24oXCJ1cGRhdGVcIiwgZSk7XG4gIH1cbn1cbmNsYXNzIHBvIHtcbiAgY29uc3RydWN0b3IodCwgZSwgbykge1xuICAgIGQodGhpcywgXCJzdGF0ZVwiKTtcbiAgICBkKHRoaXMsIFwiZW1pdFVwZGF0ZVwiKTtcbiAgICBkKHRoaXMsIFwibWVudVVwZGF0ZVRpbWVyXCIpO1xuICAgIGQodGhpcywgXCJzdGFydE1lbnVVcGRhdGVUaW1lclwiKTtcbiAgICBkKHRoaXMsIFwic3RvcE1lbnVVcGRhdGVUaW1lclwiKTtcbiAgICBkKHRoaXMsIFwibW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFya1wiKTtcbiAgICBkKHRoaXMsIFwibW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFya1JhbmdlXCIpO1xuICAgIGQodGhpcywgXCJrZXlib2FyZEhvdmVyZWRIeXBlcmxpbmtNYXJrXCIpO1xuICAgIGQodGhpcywgXCJrZXlib2FyZEhvdmVyZWRIeXBlcmxpbmtNYXJrUmFuZ2VcIik7XG4gICAgZCh0aGlzLCBcImh5cGVybGlua01hcmtcIik7XG4gICAgZCh0aGlzLCBcImh5cGVybGlua01hcmtSYW5nZVwiKTtcbiAgICBkKHRoaXMsIFwibW91c2VPdmVySGFuZGxlclwiLCAodCkgPT4ge1xuICAgICAgaWYgKHRoaXMubW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFyayA9IHZvaWQgMCwgdGhpcy5tb3VzZUhvdmVyZWRIeXBlcmxpbmtNYXJrUmFuZ2UgPSB2b2lkIDAsIHRoaXMuc3RvcE1lbnVVcGRhdGVUaW1lcigpLCB0LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50ICYmIHQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkFcIikge1xuICAgICAgICBjb25zdCBlID0gdC50YXJnZXQsIG8gPSB0aGlzLnBtVmlldy5wb3NBdERPTShlLCAwKSArIDEsIHIgPSB0aGlzLnBtVmlldy5zdGF0ZS5kb2MucmVzb2x2ZShcbiAgICAgICAgICBvXG4gICAgICAgICksIGkgPSByLm1hcmtzKCk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBpKVxuICAgICAgICAgIGlmIChzLnR5cGUubmFtZSA9PT0gdGhpcy5wbVZpZXcuc3RhdGUuc2NoZW1hLm1hcmsoXCJsaW5rXCIpLnR5cGUubmFtZSkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZUhvdmVyZWRIeXBlcmxpbmtNYXJrID0gcywgdGhpcy5tb3VzZUhvdmVyZWRIeXBlcmxpbmtNYXJrUmFuZ2UgPSB4dChcbiAgICAgICAgICAgICAgcixcbiAgICAgICAgICAgICAgcy50eXBlLFxuICAgICAgICAgICAgICBzLmF0dHJzXG4gICAgICAgICAgICApIHx8IHZvaWQgMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0TWVudVVwZGF0ZVRpbWVyKCksICExO1xuICAgIH0pO1xuICAgIGQodGhpcywgXCJjbGlja0hhbmRsZXJcIiwgKHQpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgY29uc3QgZSA9IHRoaXMucG1WaWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgLy8gVG9vbGJhciBpcyBvcGVuLlxuICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrICYmIC8vIEFuIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgIHQgJiYgdC50YXJnZXQgJiYgLy8gVGhlIGNsaWNrZWQgZWxlbWVudCBpcyBub3QgdGhlIGVkaXRvci5cbiAgICAgICEoZSA9PT0gdC50YXJnZXQgfHwgZS5jb250YWlucyh0LnRhcmdldCkpICYmIChvID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBvLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gICAgfSk7XG4gICAgZCh0aGlzLCBcInNjcm9sbEhhbmRsZXJcIiwgKCkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICB0aGlzLmh5cGVybGlua01hcmsgIT09IHZvaWQgMCAmJiAodCA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgdC5zaG93ICYmICh0aGlzLnN0YXRlLnJlZmVyZW5jZVBvcyA9IG10KFxuICAgICAgICB0aGlzLnBtVmlldyxcbiAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UuZnJvbSxcbiAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UudG9cbiAgICAgICksIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IHQsIHRoaXMucG1WaWV3ID0gZSwgdGhpcy5lbWl0VXBkYXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHVwZGF0ZSB1bmluaXRpYWxpemVkIGh5cGVybGluayB0b29sYmFyXCIpO1xuICAgICAgbyh0aGlzLnN0YXRlKTtcbiAgICB9LCB0aGlzLnN0YXJ0TWVudVVwZGF0ZVRpbWVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5tZW51VXBkYXRlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSwgdGhpcy5zdG9wTWVudVVwZGF0ZVRpbWVyID0gKCkgPT4gKHRoaXMubWVudVVwZGF0ZVRpbWVyICYmIChjbGVhclRpbWVvdXQodGhpcy5tZW51VXBkYXRlVGltZXIpLCB0aGlzLm1lbnVVcGRhdGVUaW1lciA9IHZvaWQgMCksICExKSwgdGhpcy5wbVZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgdGhpcy5tb3VzZU92ZXJIYW5kbGVyKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuY2xpY2tIYW5kbGVyLCAhMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgfVxuICBlZGl0SHlwZXJsaW5rKHQsIGUpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCBvID0gdGhpcy5wbVZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dChcbiAgICAgIGUsXG4gICAgICB0aGlzLmh5cGVybGlua01hcmtSYW5nZS5mcm9tLFxuICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UudG9cbiAgICApO1xuICAgIG8uYWRkTWFyayhcbiAgICAgIHRoaXMuaHlwZXJsaW5rTWFya1JhbmdlLmZyb20sXG4gICAgICB0aGlzLmh5cGVybGlua01hcmtSYW5nZS5mcm9tICsgZS5sZW5ndGgsXG4gICAgICB0aGlzLnBtVmlldy5zdGF0ZS5zY2hlbWEubWFyayhcImxpbmtcIiwgeyBocmVmOiB0IH0pXG4gICAgKSwgdGhpcy5wbVZpZXcuZGlzcGF0Y2gobyksIHRoaXMucG1WaWV3LmZvY3VzKCksIChyID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiByLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gIH1cbiAgZGVsZXRlSHlwZXJsaW5rKCkge1xuICAgIHZhciB0O1xuICAgIHRoaXMucG1WaWV3LmRpc3BhdGNoKFxuICAgICAgdGhpcy5wbVZpZXcuc3RhdGUudHIucmVtb3ZlTWFyayhcbiAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UuZnJvbSxcbiAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UudG8sXG4gICAgICAgIHRoaXMuaHlwZXJsaW5rTWFyay50eXBlXG4gICAgICApLnNldE1ldGEoXCJwcmV2ZW50QXV0b2xpbmtcIiwgITApXG4gICAgKSwgdGhpcy5wbVZpZXcuZm9jdXMoKSwgKHQgPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIHQuc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKCF0aGlzLnBtVmlldy5oYXNGb2N1cygpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLmh5cGVybGlua01hcms7XG4gICAgaWYgKHRoaXMuaHlwZXJsaW5rTWFyayA9IHZvaWQgMCwgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UgPSB2b2lkIDAsIHRoaXMua2V5Ym9hcmRIb3ZlcmVkSHlwZXJsaW5rTWFyayA9IHZvaWQgMCwgdGhpcy5rZXlib2FyZEhvdmVyZWRIeXBlcmxpbmtNYXJrUmFuZ2UgPSB2b2lkIDAsIHRoaXMucG1WaWV3LnN0YXRlLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgY29uc3QgbyA9IHRoaXMucG1WaWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpO1xuICAgICAgZm9yIChjb25zdCByIG9mIG8pXG4gICAgICAgIGlmIChyLnR5cGUubmFtZSA9PT0gdGhpcy5wbVZpZXcuc3RhdGUuc2NoZW1hLm1hcmsoXCJsaW5rXCIpLnR5cGUubmFtZSkge1xuICAgICAgICAgIHRoaXMua2V5Ym9hcmRIb3ZlcmVkSHlwZXJsaW5rTWFyayA9IHIsIHRoaXMua2V5Ym9hcmRIb3ZlcmVkSHlwZXJsaW5rTWFya1JhbmdlID0geHQoXG4gICAgICAgICAgICB0aGlzLnBtVmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20sXG4gICAgICAgICAgICByLnR5cGUsXG4gICAgICAgICAgICByLmF0dHJzXG4gICAgICAgICAgKSB8fCB2b2lkIDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMubW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFyayAmJiAodGhpcy5oeXBlcmxpbmtNYXJrID0gdGhpcy5tb3VzZUhvdmVyZWRIeXBlcmxpbmtNYXJrLCB0aGlzLmh5cGVybGlua01hcmtSYW5nZSA9IHRoaXMubW91c2VIb3ZlcmVkSHlwZXJsaW5rTWFya1JhbmdlKSwgdGhpcy5rZXlib2FyZEhvdmVyZWRIeXBlcmxpbmtNYXJrICYmICh0aGlzLmh5cGVybGlua01hcmsgPSB0aGlzLmtleWJvYXJkSG92ZXJlZEh5cGVybGlua01hcmssIHRoaXMuaHlwZXJsaW5rTWFya1JhbmdlID0gdGhpcy5rZXlib2FyZEhvdmVyZWRIeXBlcmxpbmtNYXJrUmFuZ2UpLCB0aGlzLmh5cGVybGlua01hcmsgJiYgdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc2hvdzogITAsXG4gICAgICAgIHJlZmVyZW5jZVBvczogbXQoXG4gICAgICAgICAgdGhpcy5wbVZpZXcsXG4gICAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UuZnJvbSxcbiAgICAgICAgICB0aGlzLmh5cGVybGlua01hcmtSYW5nZS50b1xuICAgICAgICApLFxuICAgICAgICB1cmw6IHRoaXMuaHlwZXJsaW5rTWFyay5hdHRycy5ocmVmLFxuICAgICAgICB0ZXh0OiB0aGlzLnBtVmlldy5zdGF0ZS5kb2MudGV4dEJldHdlZW4oXG4gICAgICAgICAgdGhpcy5oeXBlcmxpbmtNYXJrUmFuZ2UuZnJvbSxcbiAgICAgICAgICB0aGlzLmh5cGVybGlua01hcmtSYW5nZS50b1xuICAgICAgICApXG4gICAgICB9LCB0aGlzLmVtaXRVcGRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChlID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBlLnNob3cgJiYgdCAmJiAoIXRoaXMuaHlwZXJsaW5rTWFyayB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkpIHtcbiAgICAgIHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLm1vdXNlT3ZlckhhbmRsZXIpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlciksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmNsaWNrSGFuZGxlciwgITApO1xuICB9XG59XG5jb25zdCB1byA9IG5ldyBUKFxuICBcIkh5cGVybGlua1Rvb2xiYXJQbHVnaW5cIlxuKTtcbmNsYXNzIGhvIGV4dGVuZHMgcSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICAgIGQodGhpcywgXCJ2aWV3XCIpO1xuICAgIGQodGhpcywgXCJwbHVnaW5cIik7XG4gICAgLyoqXG4gICAgICogRWRpdCB0aGUgY3VycmVudGx5IGhvdmVyZWQgaHlwZXJsaW5rLlxuICAgICAqL1xuICAgIGQodGhpcywgXCJlZGl0SHlwZXJsaW5rXCIsIChlLCBvKSA9PiB7XG4gICAgICB0aGlzLnZpZXcuZWRpdEh5cGVybGluayhlLCBvKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhlIGN1cnJlbnRseSBob3ZlcmVkIGh5cGVybGluay5cbiAgICAgKi9cbiAgICBkKHRoaXMsIFwiZGVsZXRlSHlwZXJsaW5rXCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlldy5kZWxldGVIeXBlcmxpbmsoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBXaGVuIGhvdmVyaW5nIG9uL29mZiBoeXBlcmxpbmtzIHVzaW5nIHRoZSBtb3VzZSBjdXJzb3IsIHRoZSBoeXBlcmxpbmtcbiAgICAgKiB0b29sYmFyIHdpbGwgb3BlbiAmIGNsb3NlIHdpdGggYSBkZWxheS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3RhcnRzIHRoZSBkZWxheSB0aW1lciwgYW5kIHNob3VsZCBiZSB1c2VkIGZvciB3aGVuIHRoZSBtb3VzZSBjdXJzb3IgZW50ZXJzIHRoZSBoeXBlcmxpbmsgdG9vbGJhci5cbiAgICAgKi9cbiAgICBkKHRoaXMsIFwic3RhcnRIaWRlVGltZXJcIiwgKCkgPT4ge1xuICAgICAgdGhpcy52aWV3LnN0YXJ0TWVudVVwZGF0ZVRpbWVyKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogV2hlbiBob3ZlcmluZyBvbi9vZmYgaHlwZXJsaW5rcyB1c2luZyB0aGUgbW91c2UgY3Vyc29yLCB0aGUgaHlwZXJsaW5rXG4gICAgICogdG9vbGJhciB3aWxsIG9wZW4gJiBjbG9zZSB3aXRoIGEgZGVsYXkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN0b3BzIHRoZSBkZWxheSB0aW1lciwgYW5kIHNob3VsZCBiZSB1c2VkIGZvciB3aGVuIHRoZSBtb3VzZSBjdXJzb3IgZXhpdHMgdGhlIGh5cGVybGluayB0b29sYmFyLlxuICAgICAqL1xuICAgIGQodGhpcywgXCJzdG9wSGlkZVRpbWVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMudmlldy5zdG9wTWVudVVwZGF0ZVRpbWVyKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wbHVnaW4gPSBuZXcgdih7XG4gICAgICBrZXk6IHVvLFxuICAgICAgdmlldzogKG8pID0+ICh0aGlzLnZpZXcgPSBuZXcgcG8oZSwgbywgKHIpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwidXBkYXRlXCIsIHIpO1xuICAgICAgfSksIHRoaXMudmlldylcbiAgICB9KTtcbiAgfVxuICBvblVwZGF0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMub24oXCJ1cGRhdGVcIiwgZSk7XG4gIH1cbn1cbmNsYXNzIG1vIHtcbiAgY29uc3RydWN0b3IodCwgZSwgbykge1xuICAgIGQodGhpcywgXCJzdGF0ZVwiKTtcbiAgICBkKHRoaXMsIFwiZW1pdFVwZGF0ZVwiKTtcbiAgICBkKHRoaXMsIFwicHJldldhc0VkaXRhYmxlXCIsIG51bGwpO1xuICAgIGQodGhpcywgXCJtb3VzZURvd25IYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgKHQgPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIHQuc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgICB9KTtcbiAgICAvLyBGb3IgZHJhZ2dpbmcgdGhlIHdob2xlIGVkaXRvci5cbiAgICBkKHRoaXMsIFwiZHJhZ3N0YXJ0SGFuZGxlclwiLCAoKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgICh0ID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiB0LnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUoKSk7XG4gICAgfSk7XG4gICAgZCh0aGlzLCBcImJsdXJIYW5kbGVyXCIsICh0KSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIGNvbnN0IGUgPSB0aGlzLnBtVmlldy5kb20ucGFyZW50RWxlbWVudDtcbiAgICAgIC8vIEFuIGVsZW1lbnQgaXMgY2xpY2tlZC5cbiAgICAgIHQgJiYgdC5yZWxhdGVkVGFyZ2V0ICYmIC8vIEVsZW1lbnQgaXMgaW5zaWRlIHRoZSBlZGl0b3IuXG4gICAgICAoZSA9PT0gdC5yZWxhdGVkVGFyZ2V0IHx8IGUuY29udGFpbnModC5yZWxhdGVkVGFyZ2V0KSkgfHwgKG8gPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIG8uc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgICB9KTtcbiAgICBkKHRoaXMsIFwic2Nyb2xsSGFuZGxlclwiLCAoKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIGlmICgodCA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgdC5zaG93KSB7XG4gICAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGBbZGF0YS1ub2RlLXR5cGU9XCJibG9ja0NvbnRhaW5lclwiXVtkYXRhLWlkPVwiJHt0aGlzLnN0YXRlLmJsb2NrLmlkfVwiXWBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3MgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0aGlzLmVtaXRVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBsdWdpbktleSA9IHQsIHRoaXMucG1WaWV3ID0gZSwgdGhpcy5lbWl0VXBkYXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHVwZGF0ZSB1bmluaXRpYWxpemVkIGltYWdlIHRvb2xiYXJcIik7XG4gICAgICBvKHRoaXMuc3RhdGUpO1xuICAgIH0sIGUuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5tb3VzZURvd25IYW5kbGVyKSwgZS5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpLCBlLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXJIYW5kbGVyKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuICB9XG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgdmFyIHIsIGk7XG4gICAgY29uc3QgbyA9IHRoaXMucGx1Z2luS2V5LmdldFN0YXRlKHQuc3RhdGUpO1xuICAgIGlmICghKChyID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiByLnNob3cpICYmIG8uYmxvY2spIHtcbiAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBgW2RhdGEtbm9kZS10eXBlPVwiYmxvY2tDb250YWluZXJcIl1bZGF0YS1pZD1cIiR7by5ibG9jay5pZH1cIl1gXG4gICAgICApO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc2hvdzogITAsXG4gICAgICAgIHJlZmVyZW5jZVBvczogcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgYmxvY2s6IG8uYmxvY2tcbiAgICAgIH0sIHRoaXMuZW1pdFVwZGF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoIXQuc3RhdGUuc2VsZWN0aW9uLmVxKGUuc2VsZWN0aW9uKSB8fCAhdC5zdGF0ZS5kb2MuZXEoZS5kb2MpKSAmJiAoaSA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgaS5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKCkpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5tb3VzZURvd25IYW5kbGVyKSwgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKSwgdGhpcy5wbVZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuYmx1ckhhbmRsZXIpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gIH1cbn1cbmNvbnN0IHV0ID0gbmV3IFQoXCJJbWFnZVRvb2xiYXJQbHVnaW5cIik7XG5jbGFzcyBmbyBleHRlbmRzIHEge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBkKHRoaXMsIFwidmlld1wiKTtcbiAgICBkKHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIHRoaXMucGx1Z2luID0gbmV3IHYoe1xuICAgICAga2V5OiB1dCxcbiAgICAgIHZpZXc6IChvKSA9PiAodGhpcy52aWV3ID0gbmV3IG1vKFxuICAgICAgICAvLyBlZGl0b3IsXG4gICAgICAgIHV0LFxuICAgICAgICBvLFxuICAgICAgICAocikgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCByKTtcbiAgICAgICAgfVxuICAgICAgKSwgdGhpcy52aWV3KSxcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIGluaXQ6ICgpID0+ICh7XG4gICAgICAgICAgYmxvY2s6IHZvaWQgMFxuICAgICAgICB9KSxcbiAgICAgICAgYXBwbHk6IChvKSA9PiB7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2NrOiAoaSA9IG8uZ2V0TWV0YSh1dCkpID09IG51bGwgPyB2b2lkIDAgOiBpLmJsb2NrXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uVXBkYXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5vbihcInVwZGF0ZVwiLCBlKTtcbiAgfVxufVxuY29uc3QgZ28gPSBUZSgobikgPT4gbi50eXBlLm5hbWUgPT09IFwiYmxvY2tDb250YWluZXJcIik7XG5jbGFzcyBibyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBkKHRoaXMsIFwic3RhdGVcIik7XG4gICAgZCh0aGlzLCBcImVtaXRVcGRhdGVcIik7XG4gICAgZCh0aGlzLCBcInBsdWdpblN0YXRlXCIpO1xuICAgIGQodGhpcywgXCJoYW5kbGVTY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgdmFyIHQ7XG4gICAgICBpZiAoKHQgPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIHQuc2hvdykge1xuICAgICAgICBjb25zdCBlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBgW2RhdGEtZGVjb3JhdGlvbi1pZD1cIiR7dGhpcy5wbHVnaW5TdGF0ZS5kZWNvcmF0aW9uSWR9XCJdYFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXRlLnJlZmVyZW5jZVBvcyA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRoaXMuZW1pdFVwZGF0ZSh0aGlzLnBsdWdpblN0YXRlLnRyaWdnZXJDaGFyYWN0ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGQodGhpcywgXCJjbG9zZU1lbnVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci52aWV3LmRpc3BhdGNoKFxuICAgICAgICB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLnZpZXcuc3RhdGUudHIuc2V0TWV0YShcbiAgICAgICAgICBVLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBkKHRoaXMsIFwiY2xlYXJRdWVyeVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnBsdWdpblN0YXRlICE9PSB2b2lkIDAgJiYgdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5jaGFpbigpLmZvY3VzKCkuZGVsZXRlUmFuZ2Uoe1xuICAgICAgICBmcm9tOiB0aGlzLnBsdWdpblN0YXRlLnF1ZXJ5U3RhcnRQb3MgLSAodGhpcy5wbHVnaW5TdGF0ZS5mcm9tVXNlcklucHV0ID8gdGhpcy5wbHVnaW5TdGF0ZS50cmlnZ2VyQ2hhcmFjdGVyLmxlbmd0aCA6IDApLFxuICAgICAgICB0bzogdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbVxuICAgICAgfSkucnVuKCk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSB0LCB0aGlzLnBsdWdpblN0YXRlID0gdm9pZCAwLCB0aGlzLmVtaXRVcGRhdGUgPSAobykgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHVwZGF0ZSB1bmluaXRpYWxpemVkIHN1Z2dlc3Rpb25zIG1lbnVcIik7XG4gICAgICBlKG8sIHRoaXMuc3RhdGUpO1xuICAgIH0sIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwpO1xuICB9XG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgY29uc3QgbyA9IFUuZ2V0U3RhdGUoZSksIHIgPSBVLmdldFN0YXRlKFxuICAgICAgdC5zdGF0ZVxuICAgICksIGkgPSBvID09PSB2b2lkIDAgJiYgciAhPT0gdm9pZCAwLCBzID0gbyAhPT0gdm9pZCAwICYmIHIgPT09IHZvaWQgMDtcbiAgICBpZiAoIWkgJiYgIShvICE9PSB2b2lkIDAgJiYgciAhPT0gdm9pZCAwKSAmJiAhcylcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5wbHVnaW5TdGF0ZSA9IHMgPyBvIDogciwgcyB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSh0aGlzLnBsdWdpblN0YXRlLnRyaWdnZXJDaGFyYWN0ZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgIGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHt0aGlzLnBsdWdpblN0YXRlLmRlY29yYXRpb25JZH1cIl1gXG4gICAgKTtcbiAgICB0aGlzLmVkaXRvci5pc0VkaXRhYmxlICYmICh0aGlzLnN0YXRlID0ge1xuICAgICAgc2hvdzogITAsXG4gICAgICByZWZlcmVuY2VQb3M6IGwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBxdWVyeTogdGhpcy5wbHVnaW5TdGF0ZS5xdWVyeVxuICAgIH0sIHRoaXMuZW1pdFVwZGF0ZSh0aGlzLnBsdWdpblN0YXRlLnRyaWdnZXJDaGFyYWN0ZXIpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5oYW5kbGVTY3JvbGwpO1xuICB9XG59XG5jb25zdCBVID0gbmV3IFQoXCJTdWdnZXN0aW9uTWVudVBsdWdpblwiKTtcbmNsYXNzIHlvIGV4dGVuZHMgcSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICAgIGQodGhpcywgXCJ2aWV3XCIpO1xuICAgIGQodGhpcywgXCJwbHVnaW5cIik7XG4gICAgZCh0aGlzLCBcInRyaWdnZXJDaGFyYWN0ZXJzXCIsIFtdKTtcbiAgICBkKHRoaXMsIFwiYWRkVHJpZ2dlckNoYXJhY3RlclwiLCAoZSkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyQ2hhcmFjdGVycy5wdXNoKGUpO1xuICAgIH0pO1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gbGlzdGVuZXJzIGFyZSByZW1vdmVkP1xuICAgIGQodGhpcywgXCJyZW1vdmVUcmlnZ2VyQ2hhcmFjdGVyXCIsIChlKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFyYWN0ZXJzID0gdGhpcy50cmlnZ2VyQ2hhcmFjdGVycy5maWx0ZXIoXG4gICAgICAgIChvKSA9PiBvICE9PSBlXG4gICAgICApO1xuICAgIH0pO1xuICAgIGQodGhpcywgXCJjbG9zZU1lbnVcIiwgKCkgPT4gdGhpcy52aWV3LmNsb3NlTWVudSgpKTtcbiAgICBkKHRoaXMsIFwiY2xlYXJRdWVyeVwiLCAoKSA9PiB0aGlzLnZpZXcuY2xlYXJRdWVyeSgpKTtcbiAgICBjb25zdCBvID0gdGhpcy50cmlnZ2VyQ2hhcmFjdGVycztcbiAgICB0aGlzLnBsdWdpbiA9IG5ldyB2KHtcbiAgICAgIGtleTogVSxcbiAgICAgIHZpZXc6ICgpID0+ICh0aGlzLnZpZXcgPSBuZXcgYm8oXG4gICAgICAgIGUsXG4gICAgICAgIChyLCBpKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KGB1cGRhdGUgJHtyfWAsIGkpO1xuICAgICAgICB9XG4gICAgICApLCB0aGlzLnZpZXcpLFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGx1Z2luJ3MgaW50ZXJuYWwgc3RhdGUuXG4gICAgICAgIGluaXQoKSB7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFwcGx5IGNoYW5nZXMgdG8gdGhlIHBsdWdpbiBzdGF0ZSBmcm9tIGFuIGVkaXRvciB0cmFuc2FjdGlvbi5cbiAgICAgICAgYXBwbHkociwgaSwgcywgYSkge1xuICAgICAgICAgIGlmIChyLmdldE1ldGEoXCJvcmRlcmVkTGlzdEluZGV4aW5nXCIpICE9PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICBjb25zdCBsID0gci5nZXRNZXRhKFUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbCA9PSBcIm9iamVjdFwiICYmIGwgIT09IG51bGwgJiYgaSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHJpZ2dlckNoYXJhY3RlcjogbC50cmlnZ2VyQ2hhcmFjdGVyLFxuICAgICAgICAgICAgICBmcm9tVXNlcklucHV0OiBsLmZyb21Vc2VySW5wdXQgIT09ICExLFxuICAgICAgICAgICAgICBxdWVyeVN0YXJ0UG9zOiBhLnNlbGVjdGlvbi5mcm9tLFxuICAgICAgICAgICAgICBxdWVyeTogXCJcIixcbiAgICAgICAgICAgICAgZGVjb3JhdGlvbklkOiBgaWRfJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1KX1gXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBIaWdobGlnaHRpbmcgdGV4dCBzaG91bGQgaGlkZSB0aGUgbWVudS5cbiAgICAgICAgICAgIGEuc2VsZWN0aW9uLmZyb20gIT09IGEuc2VsZWN0aW9uLnRvIHx8IC8vIFRyYW5zYWN0aW9ucyB3aXRoIHBsdWdpbiBtZXRhZGF0YSBzaG91bGQgaGlkZSB0aGUgbWVudS5cbiAgICAgICAgICAgIGwgPT09IG51bGwgfHwgLy8gQ2VydGFpbiBtb3VzZSBldmVudHMgc2hvdWxkIGhpZGUgdGhlIG1lbnUuXG4gICAgICAgICAgICAvLyBUT0RPOiBDaGFuZ2UgdG8gZ2xvYmFsIG1vdXNlZG93biBsaXN0ZW5lci5cbiAgICAgICAgICAgIHIuZ2V0TWV0YShcImZvY3VzXCIpIHx8IHIuZ2V0TWV0YShcImJsdXJcIikgfHwgci5nZXRNZXRhKFwicG9pbnRlclwiKSB8fCAvLyBNb3ZpbmcgdGhlIGNhcmV0IGJlZm9yZSB0aGUgY2hhcmFjdGVyIHdoaWNoIHRyaWdnZXJlZCB0aGUgbWVudSBzaG91bGQgaGlkZSBpdC5cbiAgICAgICAgICAgIGkudHJpZ2dlckNoYXJhY3RlciAhPT0gdm9pZCAwICYmIGEuc2VsZWN0aW9uLmZyb20gPCBpLnF1ZXJ5U3RhcnRQb3NcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgYyA9IHsgLi4uaSB9O1xuICAgICAgICAgIHJldHVybiBjLnF1ZXJ5ID0gYS5kb2MudGV4dEJldHdlZW4oXG4gICAgICAgICAgICBpLnF1ZXJ5U3RhcnRQb3MsXG4gICAgICAgICAgICBhLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgKSwgYztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGhhbmRsZUtleURvd24ociwgaSkge1xuICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLmdldFN0YXRlKHIuc3RhdGUpO1xuICAgICAgICAgIHJldHVybiBvLmluY2x1ZGVzKGkua2V5KSAmJiBzID09PSB2b2lkIDAgPyAoaS5wcmV2ZW50RGVmYXVsdCgpLCByLmRpc3BhdGNoKFxuICAgICAgICAgICAgci5zdGF0ZS50ci5pbnNlcnRUZXh0KGkua2V5KS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoVSwge1xuICAgICAgICAgICAgICB0cmlnZ2VyQ2hhcmFjdGVyOiBpLmtleVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLCAhMCkgOiAhMTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2V0dXAgZGVjb3JhdG9yIG9uIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN1Z2dlc3Rpb24uXG4gICAgICAgIGRlY29yYXRpb25zKHIpIHtcbiAgICAgICAgICBjb25zdCBpID0gdGhpcy5nZXRTdGF0ZShyKTtcbiAgICAgICAgICBpZiAoaSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKCFpLmZyb21Vc2VySW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBnbyhyLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAocylcbiAgICAgICAgICAgICAgcmV0dXJuICQuY3JlYXRlKHIuZG9jLCBbXG4gICAgICAgICAgICAgICAgRy5ub2RlKFxuICAgICAgICAgICAgICAgICAgcy5wb3MsXG4gICAgICAgICAgICAgICAgICBzLnBvcyArIHMubm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJibi1zdWdnZXN0aW9uLWRlY29yYXRvclwiLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGEtZGVjb3JhdGlvbi1pZFwiOiBpLmRlY29yYXRpb25JZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAkLmNyZWF0ZShyLmRvYywgW1xuICAgICAgICAgICAgRy5pbmxpbmUoXG4gICAgICAgICAgICAgIGkucXVlcnlTdGFydFBvcyAtIGkudHJpZ2dlckNoYXJhY3Rlci5sZW5ndGgsXG4gICAgICAgICAgICAgIGkucXVlcnlTdGFydFBvcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICBjbGFzczogXCJibi1zdWdnZXN0aW9uLWRlY29yYXRvclwiLFxuICAgICAgICAgICAgICAgIFwiZGF0YS1kZWNvcmF0aW9uLWlkXCI6IGkuZGVjb3JhdGlvbklkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uVXBkYXRlKGUsIG8pIHtcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyQ2hhcmFjdGVycy5pbmNsdWRlcyhlKSB8fCB0aGlzLmFkZFRyaWdnZXJDaGFyYWN0ZXIoZSksIHRoaXMub24oYHVwZGF0ZSAke2V9YCwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFZyKG4sIHQpIHtcbiAgbi5zdWdnZXN0aW9uTWVudXMuYWRkVHJpZ2dlckNoYXJhY3Rlcih0KTtcbn1cbmNsYXNzIEYgZXh0ZW5kcyBkdCB7XG4gIGNvbnN0cnVjdG9yKGUsIG8pIHtcbiAgICBzdXBlcihlLCBvKTtcbiAgICBkKHRoaXMsIFwibm9kZXNcIik7XG4gICAgY29uc3QgciA9IGUubm9kZSgpO1xuICAgIHRoaXMubm9kZXMgPSBbXSwgZS5kb2Mubm9kZXNCZXR3ZWVuKGUucG9zLCBvLnBvcywgKGksIHMsIGEpID0+IHtcbiAgICAgIGlmIChhICE9PSBudWxsICYmIGEuZXEocikpXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnB1c2goaSksICExO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoZSwgbywgciA9IG8pIHtcbiAgICByZXR1cm4gbmV3IEYoZS5yZXNvbHZlKG8pLCBlLnJlc29sdmUocikpO1xuICB9XG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBfKHguZnJvbSh0aGlzLm5vZGVzKSwgMCwgMCk7XG4gIH1cbiAgZXEoZSkge1xuICAgIGlmICghKGUgaW5zdGFuY2VvZiBGKSB8fCB0aGlzLm5vZGVzLmxlbmd0aCAhPT0gZS5ub2Rlcy5sZW5ndGggfHwgdGhpcy5mcm9tICE9PSBlLmZyb20gfHwgdGhpcy50byAhPT0gZS50bylcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHRoaXMubm9kZXMubGVuZ3RoOyBvKyspXG4gICAgICBpZiAoIXRoaXMubm9kZXNbb10uZXEoZS5ub2Rlc1tvXSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgbWFwKGUsIG8pIHtcbiAgICBjb25zdCByID0gby5tYXBSZXN1bHQodGhpcy5mcm9tKSwgaSA9IG8ubWFwUmVzdWx0KHRoaXMudG8pO1xuICAgIHJldHVybiBpLmRlbGV0ZWQgPyBkdC5uZWFyKGUucmVzb2x2ZShyLnBvcykpIDogci5kZWxldGVkID8gZHQubmVhcihlLnJlc29sdmUoaS5wb3MpKSA6IG5ldyBGKFxuICAgICAgZS5yZXNvbHZlKHIucG9zKSxcbiAgICAgIGUucmVzb2x2ZShpLnBvcylcbiAgICApO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIm5vZGVcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gIH1cbn1cbmxldCBIO1xuZnVuY3Rpb24gQ3QobiwgdCkge1xuICB2YXIgcjtcbiAgaWYgKCF0LmRvbS5pc0Nvbm5lY3RlZClcbiAgICByZXR1cm47XG4gIGNvbnN0IGUgPSB0LnBvc0F0Q29vcmRzKG4pO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuO1xuICBsZXQgbyA9IHQuZG9tQXRQb3MoZS5wb3MpLm5vZGU7XG4gIGlmIChvICE9PSB0LmRvbSkge1xuICAgIGZvciAoOyBvICYmIG8ucGFyZW50Tm9kZSAmJiBvLnBhcmVudE5vZGUgIT09IHQuZG9tICYmICEoKHIgPSBvLmhhc0F0dHJpYnV0ZSkgIT0gbnVsbCAmJiByLmNhbGwobywgXCJkYXRhLWlkXCIpKTsgKVxuICAgICAgbyA9IG8ucGFyZW50Tm9kZTtcbiAgICBpZiAobylcbiAgICAgIHJldHVybiB7IG5vZGU6IG8sIGlkOiBvLmdldEF0dHJpYnV0ZShcImRhdGEtaWRcIikgfTtcbiAgfVxufVxuZnVuY3Rpb24ga28obiwgdCkge1xuICBjb25zdCBlID0gQ3QobiwgdCk7XG4gIGlmIChlICYmIGUubm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IG8gPSB0LmRvY1ZpZXcsIHIgPSBvLm5lYXJlc3REZXNjKGUubm9kZSwgITApO1xuICAgIHJldHVybiAhciB8fCByID09PSBvID8gbnVsbCA6IHIucG9zQmVmb3JlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gd28obiwgdCkge1xuICBsZXQgZSwgbztcbiAgY29uc3QgciA9IHQucmVzb2x2ZShuLmZyb20pLm5vZGUoKS50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tDb250ZW50XCIsIGkgPSB0LnJlc29sdmUobi50bykubm9kZSgpLnR5cGUuc3BlYy5ncm91cCA9PT0gXCJibG9ja0NvbnRlbnRcIiwgcyA9IE1hdGgubWluKG4uJGFuY2hvci5kZXB0aCwgbi4kaGVhZC5kZXB0aCk7XG4gIGlmIChyICYmIGkpIHtcbiAgICBjb25zdCBhID0gbi4kZnJvbS5zdGFydChzIC0gMSksIGwgPSBuLiR0by5lbmQocyAtIDEpO1xuICAgIGUgPSB0LnJlc29sdmUoYSAtIDEpLnBvcywgbyA9IHQucmVzb2x2ZShsICsgMSkucG9zO1xuICB9IGVsc2VcbiAgICBlID0gbi5mcm9tLCBvID0gbi50bztcbiAgcmV0dXJuIHsgZnJvbTogZSwgdG86IG8gfTtcbn1cbmZ1bmN0aW9uIER0KG4sIHQsIGUgPSB0KSB7XG4gIHQgPT09IGUgJiYgKGUgKz0gbi5zdGF0ZS5kb2MucmVzb2x2ZSh0ICsgMSkubm9kZSgpLm5vZGVTaXplKTtcbiAgY29uc3QgbyA9IG4uZG9tQXRQb3ModCkubm9kZS5jbG9uZU5vZGUoITApLCByID0gbi5kb21BdFBvcyh0KS5ub2RlLCBpID0gKHAsIHUpID0+IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocC5jaGlsZHJlbiwgdSksIHMgPSBpKFxuICAgIHIsXG4gICAgLy8gRXhwZWN0cyBmcm9tIHBvc2l0aW9uIHRvIGJlIGp1c3QgYmVmb3JlIHRoZSBmaXJzdCBzZWxlY3RlZCBibG9jay5cbiAgICBuLmRvbUF0UG9zKHQgKyAxKS5ub2RlLnBhcmVudEVsZW1lbnRcbiAgKSwgYSA9IGkoXG4gICAgcixcbiAgICAvLyBFeHBlY3RzIHRvIHBvc2l0aW9uIHRvIGJlIGp1c3QgYWZ0ZXIgdGhlIGxhc3Qgc2VsZWN0ZWQgYmxvY2suXG4gICAgbi5kb21BdFBvcyhlIC0gMSkubm9kZS5wYXJlbnRFbGVtZW50XG4gICk7XG4gIGZvciAobGV0IHAgPSByLmNoaWxkRWxlbWVudENvdW50IC0gMTsgcCA+PSAwOyBwLS0pXG4gICAgKHAgPiBhIHx8IHAgPCBzKSAmJiBvLnJlbW92ZUNoaWxkKG8uY2hpbGRyZW5bcF0pO1xuICBjZSgpLCBIID0gbztcbiAgY29uc3QgYyA9IG4uZG9tLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuZmlsdGVyKFxuICAgIChwKSA9PiBwICE9PSBcIlByb3NlTWlycm9yXCIgJiYgcCAhPT0gXCJibi1yb290XCIgJiYgcCAhPT0gXCJibi1lZGl0b3JcIlxuICApLmpvaW4oXCIgXCIpO1xuICBILmNsYXNzTmFtZSA9IEguY2xhc3NOYW1lICsgXCIgYm4tZHJhZy1wcmV2aWV3IFwiICsgYywgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChIKTtcbn1cbmZ1bmN0aW9uIGNlKCkge1xuICBIICE9PSB2b2lkIDAgJiYgKGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoSCksIEggPSB2b2lkIDApO1xufVxuZnVuY3Rpb24gdm8obiwgdCkge1xuICBpZiAoIW4uZGF0YVRyYW5zZmVyKVxuICAgIHJldHVybjtcbiAgY29uc3QgZSA9IHQucHJvc2VtaXJyb3JWaWV3LCBvID0gZS5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHIgPSB7XG4gICAgbGVmdDogby5sZWZ0ICsgby53aWR0aCAvIDIsXG4gICAgLy8gdGFrZSBtaWRkbGUgb2YgZWRpdG9yXG4gICAgdG9wOiBuLmNsaWVudFlcbiAgfSwgaSA9IGtvKHIsIGUpO1xuICBpZiAoaSAhPSBudWxsKSB7XG4gICAgY29uc3QgcyA9IGUuc3RhdGUuc2VsZWN0aW9uLCBhID0gZS5zdGF0ZS5kb2MsIHsgZnJvbTogbCwgdG86IGMgfSA9IHdvKHMsIGEpLCBwID0gbCA8PSBpICYmIGkgPCBjLCB1ID0gcy4kYW5jaG9yLm5vZGUoKSAhPT0gcy4kaGVhZC5ub2RlKCkgfHwgcyBpbnN0YW5jZW9mIEY7XG4gICAgcCAmJiB1ID8gKGUuZGlzcGF0Y2goXG4gICAgICBlLnN0YXRlLnRyLnNldFNlbGVjdGlvbihGLmNyZWF0ZShhLCBsLCBjKSlcbiAgICApLCBEdChlLCBsLCBjKSkgOiAoZS5kaXNwYXRjaChcbiAgICAgIGUuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHJ0LmNyZWF0ZShlLnN0YXRlLmRvYywgaSkpXG4gICAgKSwgRHQoZSwgaSkpO1xuICAgIGNvbnN0IG0gPSBlLnN0YXRlLnNlbGVjdGlvbi5jb250ZW50KCksIGggPSB0Ll90aXB0YXBFZGl0b3Iuc2NoZW1hLCB5ID0gSnQoaCwgdCkuc2VyaWFsaXplUHJvc2VNaXJyb3JGcmFnbWVudChcbiAgICAgIG0uY29udGVudFxuICAgICksIEIgPSBhdChoLCB0KS5leHBvcnRQcm9zZU1pcnJvckZyYWdtZW50KFxuICAgICAgbS5jb250ZW50XG4gICAgKSwgRSA9IFN0KEIpO1xuICAgIG4uZGF0YVRyYW5zZmVyLmNsZWFyRGF0YSgpLCBuLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiYmxvY2tub3RlL2h0bWxcIiwgeSksIG4uZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L2h0bWxcIiwgQiksIG4uZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIEUpLCBuLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXCJtb3ZlXCIsIG4uZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShILCAwLCAwKSwgZS5kcmFnZ2luZyA9IHsgc2xpY2U6IG0sIG1vdmU6ICEwIH07XG4gIH1cbn1cbmNsYXNzIEVvIHtcbiAgY29uc3RydWN0b3IodCwgZSwgbykge1xuICAgIGQodGhpcywgXCJzdGF0ZVwiKTtcbiAgICBkKHRoaXMsIFwiZW1pdFVwZGF0ZVwiKTtcbiAgICAvLyBXaGVuIHRydWUsIHRoZSBkcmFnIGhhbmRsZSB3aXRoIGJlIGFuY2hvcmVkIGF0IHRoZSBzYW1lIGxldmVsIGFzIHJvb3QgZWxlbWVudHNcbiAgICAvLyBXaGVuIGZhbHNlLCB0aGUgZHJhZyBoYW5kbGUgd2l0aCBiZSBqdXN0IHRvIHRoZSBsZWZ0IG9mIHRoZSBlbGVtZW50XG4gICAgLy8gVE9ETzogSXMgdGhlcmUgYW55IGNhc2Ugd2hlcmUgd2Ugd2FudCB0aGlzIHRvIGJlIGZhbHNlP1xuICAgIGQodGhpcywgXCJob3Jpem9udGFsUG9zQW5jaG9yZWRBdFJvb3RcIik7XG4gICAgZCh0aGlzLCBcImhvcml6b250YWxQb3NBbmNob3JcIik7XG4gICAgZCh0aGlzLCBcImhvdmVyZWRCbG9ja1wiKTtcbiAgICAvLyBVc2VkIHRvIGNoZWNrIGlmIGN1cnJlbnRseSBkcmFnZ2VkIGNvbnRlbnQgY29tZXMgZnJvbSB0aGlzIGVkaXRvciBpbnN0YW5jZS5cbiAgICBkKHRoaXMsIFwiaXNEcmFnZ2luZ1wiLCAhMSk7XG4gICAgZCh0aGlzLCBcIm1lbnVGcm96ZW5cIiwgITEpO1xuICAgIC8qKlxuICAgICAqIFNldHMgaXNEcmFnZ2luZyB3aGVuIGRyYWdnaW5nIHRleHQuXG4gICAgICovXG4gICAgZCh0aGlzLCBcIm9uRHJhZ1N0YXJ0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9ICEwO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBldmVudCBpcyBvdXRzaWRlIHRoZSBlZGl0b3IgY29udGVudHMsXG4gICAgICogd2UgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50LCBzbyB0aGF0IHdlIGNhbiBzdGlsbCBkcm9wIHRoZSBjb250ZW50XG4gICAgICogd2hlbiBkcmFnZ2luZyAvIGRyb3BwaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICBkKHRoaXMsIFwib25Ecm9wXCIsICh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5ibHVyKCksIHQuc3ludGhldGljIHx8ICF0aGlzLmlzRHJhZ2dpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLnBtVmlldy5wb3NBdENvb3Jkcyh7XG4gICAgICAgIGxlZnQ6IHQuY2xpZW50WCxcbiAgICAgICAgdG9wOiB0LmNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZyA9ICExLCAhZSB8fCBlLmluc2lkZSA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgbyA9IG5ldyBFdmVudChcImRyb3BcIiwgdCksIHIgPSB0aGlzLnBtVmlldy5kb20uZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgby5jbGllbnRYID0gci5sZWZ0ICsgci53aWR0aCAvIDIsIG8uY2xpZW50WSA9IHQuY2xpZW50WSwgby5kYXRhVHJhbnNmZXIgPSB0LmRhdGFUcmFuc2Zlciwgby5wcmV2ZW50RGVmYXVsdCA9ICgpID0+IHQucHJldmVudERlZmF1bHQoKSwgby5zeW50aGV0aWMgPSAhMCwgdGhpcy5wbVZpZXcuZG9tLmRpc3BhdGNoRXZlbnQobyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIG91dHNpZGUgdGhlIGVkaXRvciBjb250ZW50cyxcbiAgICAgKiB3ZSBkaXNwYXRjaCBhIGZha2UgZXZlbnQsIHNvIHRoYXQgd2UgY2FuIHN0aWxsIGRyb3AgdGhlIGNvbnRlbnRcbiAgICAgKiB3aGVuIGRyYWdnaW5nIC8gZHJvcHBpbmcgdG8gdGhlIHNpZGUgb2YgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIGQodGhpcywgXCJvbkRyYWdPdmVyXCIsICh0KSA9PiB7XG4gICAgICBpZiAodC5zeW50aGV0aWMgfHwgIXRoaXMuaXNEcmFnZ2luZylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZSA9IHRoaXMucG1WaWV3LnBvc0F0Q29vcmRzKHtcbiAgICAgICAgbGVmdDogdC5jbGllbnRYLFxuICAgICAgICB0b3A6IHQuY2xpZW50WVxuICAgICAgfSk7XG4gICAgICBpZiAoIWUgfHwgZS5pbnNpZGUgPT09IC0xKSB7XG4gICAgICAgIGNvbnN0IG8gPSBuZXcgRXZlbnQoXCJkcmFnb3ZlclwiLCB0KSwgciA9IHRoaXMucG1WaWV3LmRvbS5maXJzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBvLmNsaWVudFggPSByLmxlZnQgKyByLndpZHRoIC8gMiwgby5jbGllbnRZID0gdC5jbGllbnRZLCBvLmRhdGFUcmFuc2ZlciA9IHQuZGF0YVRyYW5zZmVyLCBvLnByZXZlbnREZWZhdWx0ID0gKCkgPT4gdC5wcmV2ZW50RGVmYXVsdCgpLCBvLnN5bnRoZXRpYyA9ICEwLCB0aGlzLnBtVmlldy5kb20uZGlzcGF0Y2hFdmVudChvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkKHRoaXMsIFwib25LZXlEb3duXCIsICh0KSA9PiB7XG4gICAgICB2YXIgZTtcbiAgICAgIChlID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBlLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUodGhpcy5zdGF0ZSkpLCB0aGlzLm1lbnVGcm96ZW4gPSAhMTtcbiAgICB9KTtcbiAgICBkKHRoaXMsIFwib25Nb3VzZURvd25cIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgJiYgIXRoaXMuc3RhdGUuc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITAsIHRoaXMuZW1pdFVwZGF0ZSh0aGlzLnN0YXRlKSksIHRoaXMubWVudUZyb3plbiA9ICExO1xuICAgIH0pO1xuICAgIGQodGhpcywgXCJvbk1vdXNlTW92ZVwiLCAodCkgPT4ge1xuICAgICAgdmFyIGMsIHAsIHUsIG0sIGg7XG4gICAgICBpZiAodGhpcy5tZW51RnJvemVuKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBlID0gdGhpcy5wbVZpZXcuZG9tLmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB0aGlzLnBtVmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHIgPSB0LmNsaWVudFggPj0gby5sZWZ0ICYmIHQuY2xpZW50WCA8PSBvLnJpZ2h0ICYmIHQuY2xpZW50WSA+PSBvLnRvcCAmJiB0LmNsaWVudFkgPD0gby5ib3R0b20sIGkgPSB0aGlzLnBtVmlldy5kb20ucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gQ3Vyc29yIGlzIHdpdGhpbiB0aGUgZWRpdG9yIGFyZWFcbiAgICAgICAgciAmJiAvLyBBbiBlbGVtZW50IGlzIGhvdmVyZWRcbiAgICAgICAgdCAmJiB0LnRhcmdldCAmJiAvLyBFbGVtZW50IGlzIG91dHNpZGUgdGhlIGVkaXRvclxuICAgICAgICAhKGkgPT09IHQudGFyZ2V0IHx8IGkuY29udGFpbnModC50YXJnZXQpKVxuICAgICAgKSB7XG4gICAgICAgIChjID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBjLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUodGhpcy5zdGF0ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhvcml6b250YWxQb3NBbmNob3IgPSBlLng7XG4gICAgICBjb25zdCBzID0ge1xuICAgICAgICBsZWZ0OiBlLmxlZnQgKyBlLndpZHRoIC8gMixcbiAgICAgICAgLy8gdGFrZSBtaWRkbGUgb2YgZWRpdG9yXG4gICAgICAgIHRvcDogdC5jbGllbnRZXG4gICAgICB9LCBhID0gQ3QocywgdGhpcy5wbVZpZXcpO1xuICAgICAgaWYgKCFhIHx8ICF0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgIChwID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiBwLnNob3cgJiYgKHRoaXMuc3RhdGUuc2hvdyA9ICExLCB0aGlzLmVtaXRVcGRhdGUodGhpcy5zdGF0ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKHUgPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIHUuc2hvdyAmJiAoKG0gPSB0aGlzLmhvdmVyZWRCbG9jaykgIT0gbnVsbCAmJiBtLmhhc0F0dHJpYnV0ZShcImRhdGEtaWRcIikpICYmICgoaCA9IHRoaXMuaG92ZXJlZEJsb2NrKSA9PSBudWxsID8gdm9pZCAwIDogaC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpKSA9PT0gYS5pZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5ob3ZlcmVkQmxvY2sgPSBhLm5vZGU7XG4gICAgICBjb25zdCBsID0gYS5ub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAobCAmJiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IGYgPSBsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgIHNob3c6ICEwLFxuICAgICAgICAgIHJlZmVyZW5jZVBvczogbmV3IERPTVJlY3QoXG4gICAgICAgICAgICB0aGlzLmhvcml6b250YWxQb3NBbmNob3JlZEF0Um9vdCA/IHRoaXMuaG9yaXpvbnRhbFBvc0FuY2hvciA6IGYueCxcbiAgICAgICAgICAgIGYueSxcbiAgICAgICAgICAgIGYud2lkdGgsXG4gICAgICAgICAgICBmLmhlaWdodFxuICAgICAgICAgICksXG4gICAgICAgICAgYmxvY2s6IHRoaXMuZWRpdG9yLmdldEJsb2NrKFxuICAgICAgICAgICAgdGhpcy5ob3ZlcmVkQmxvY2suZ2V0QXR0cmlidXRlKFwiZGF0YS1pZFwiKVxuICAgICAgICAgIClcbiAgICAgICAgfSwgdGhpcy5lbWl0VXBkYXRlKHRoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGQodGhpcywgXCJvblNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIGlmICgodCA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgdC5zaG93KSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmhvdmVyZWRCbG9jay5maXJzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnN0YXRlLnJlZmVyZW5jZVBvcyA9IG5ldyBET01SZWN0KFxuICAgICAgICAgIHRoaXMuaG9yaXpvbnRhbFBvc0FuY2hvcmVkQXRSb290ID8gdGhpcy5ob3Jpem9udGFsUG9zQW5jaG9yIDogby54LFxuICAgICAgICAgIG8ueSxcbiAgICAgICAgICBvLndpZHRoLFxuICAgICAgICAgIG8uaGVpZ2h0XG4gICAgICAgICksIHRoaXMuZW1pdFVwZGF0ZSh0aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvciA9IHQsIHRoaXMucG1WaWV3ID0gZSwgdGhpcy5lbWl0VXBkYXRlID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0YXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0aW5nIHRvIHVwZGF0ZSB1bmluaXRpYWxpemVkIHNpZGUgbWVudVwiKTtcbiAgICAgIG8odGhpcy5zdGF0ZSk7XG4gICAgfSwgdGhpcy5ob3Jpem9udGFsUG9zQW5jaG9yZWRBdFJvb3QgPSAhMCwgdGhpcy5ob3Jpem9udGFsUG9zQW5jaG9yID0gdGhpcy5wbVZpZXcuZG9tLmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCwgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLm9uRHJvcCwgITApLCBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLm9uRHJhZ092ZXIpLCB0aGlzLnBtVmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCB0aGlzLm9uRHJhZ1N0YXJ0KSwgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZU1vdmUsICEwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKSwgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZURvd24sICEwKSwgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5RG93biwgITApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIHQ7XG4gICAgKHQgPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIHQuc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSh0aGlzLnN0YXRlKSksIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlLCAhMCksIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMub25EcmFnT3ZlciksIHRoaXMucG1WaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIHRoaXMub25EcmFnU3RhcnQpLCBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMub25Ecm9wLCAhMCksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCksIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLCAhMCksIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleURvd24sICEwKTtcbiAgfVxuICBhZGRCbG9jaygpIHtcbiAgICB2YXIgbDtcbiAgICAobCA9IHRoaXMuc3RhdGUpICE9IG51bGwgJiYgbC5zaG93ICYmICh0aGlzLnN0YXRlLnNob3cgPSAhMSwgdGhpcy5lbWl0VXBkYXRlKHRoaXMuc3RhdGUpKSwgdGhpcy5tZW51RnJvemVuID0gITA7XG4gICAgY29uc3QgZSA9IHRoaXMuaG92ZXJlZEJsb2NrLmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB0aGlzLnBtVmlldy5wb3NBdENvb3Jkcyh7XG4gICAgICBsZWZ0OiBlLmxlZnQgKyBlLndpZHRoIC8gMixcbiAgICAgIHRvcDogZS50b3AgKyBlLmhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IGIoXG4gICAgICB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYyxcbiAgICAgIG8ucG9zXG4gICAgKTtcbiAgICBpZiAociA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgY29udGVudE5vZGU6IGksIHN0YXJ0UG9zOiBzLCBlbmRQb3M6IGEgfSA9IHI7XG4gICAgaWYgKGkudHlwZS5zcGVjLmNvbnRlbnQgIT09IFwiaW5saW5lKlwiIHx8IGkudGV4dENvbnRlbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBjID0gYSArIDEsIHAgPSBjICsgMjtcbiAgICAgIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3IuY2hhaW4oKS5CTkNyZWF0ZUJsb2NrKGMpLnNldFRleHRTZWxlY3Rpb24ocCkucnVuKCk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24ocyArIDEpO1xuICAgIHRoaXMucG1WaWV3LmZvY3VzKCksIHRoaXMucG1WaWV3LmRpc3BhdGNoKFxuICAgICAgdGhpcy5wbVZpZXcuc3RhdGUudHIuc2Nyb2xsSW50b1ZpZXcoKS5zZXRNZXRhKFUsIHtcbiAgICAgICAgdHJpZ2dlckNoYXJhY3RlcjogXCIvXCIsXG4gICAgICAgIGZyb21Vc2VySW5wdXQ6ICExXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IFNvID0gbmV3IFQoXCJTaWRlTWVudVBsdWdpblwiKTtcbmNsYXNzIENvIGV4dGVuZHMgcSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpO1xuICAgIGQodGhpcywgXCJ2aWV3XCIpO1xuICAgIGQodGhpcywgXCJwbHVnaW5cIik7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGJsb2NrIGlzIGVtcHR5LCBvcGVucyB0aGUgc2xhc2ggbWVudS4gSWYgdGhlIGJsb2NrIGhhcyBjb250ZW50LFxuICAgICAqIGNyZWF0ZXMgYSBuZXcgYmxvY2sgYmVsb3cgYW5kIG9wZW5zIHRoZSBzbGFzaCBtZW51IGluIGl0LlxuICAgICAqL1xuICAgIGQodGhpcywgXCJhZGRCbG9ja1wiLCAoKSA9PiB0aGlzLnZpZXcuYWRkQmxvY2soKSk7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBkcmFnICYgZHJvcCBldmVudHMgZm9yIGJsb2Nrcy5cbiAgICAgKi9cbiAgICBkKHRoaXMsIFwiYmxvY2tEcmFnU3RhcnRcIiwgKGUpID0+IHtcbiAgICAgIHRoaXMudmlldy5pc0RyYWdnaW5nID0gITAsIHZvKGUsIHRoaXMuZWRpdG9yKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGRyYWcgJiBkcm9wIGV2ZW50cyBmb3IgYmxvY2tzLlxuICAgICAqL1xuICAgIGQodGhpcywgXCJibG9ja0RyYWdFbmRcIiwgKCkgPT4gY2UoKSk7XG4gICAgLyoqXG4gICAgICogRnJlZXplcyB0aGUgc2lkZSBtZW51LiBXaGVuIGZyb3plbiwgdGhlIHNpZGUgbWVudSB3aWxsIHN0YXlcbiAgICAgKiBhdHRhY2hlZCB0byB0aGUgc2FtZSBibG9jayByZWdhcmRsZXNzIG9mIHdoaWNoIGJsb2NrIGlzIGhvdmVyZWQgYnkgdGhlXG4gICAgICogbW91c2UgY3Vyc29yLlxuICAgICAqL1xuICAgIGQodGhpcywgXCJmcmVlemVNZW51XCIsICgpID0+IHRoaXMudmlldy5tZW51RnJvemVuID0gITApO1xuICAgIC8qKlxuICAgICAqIFVuZnJlZXplcyB0aGUgc2lkZSBtZW51LiBXaGVuIGZyb3plbiwgdGhlIHNpZGUgbWVudSB3aWxsIHN0YXlcbiAgICAgKiBhdHRhY2hlZCB0byB0aGUgc2FtZSBibG9jayByZWdhcmRsZXNzIG9mIHdoaWNoIGJsb2NrIGlzIGhvdmVyZWQgYnkgdGhlXG4gICAgICogbW91c2UgY3Vyc29yLlxuICAgICAqL1xuICAgIGQodGhpcywgXCJ1bmZyZWV6ZU1lbnVcIiwgKCkgPT4gdGhpcy52aWV3Lm1lbnVGcm96ZW4gPSAhMSk7XG4gICAgdGhpcy5lZGl0b3IgPSBlLCB0aGlzLnBsdWdpbiA9IG5ldyB2KHtcbiAgICAgIGtleTogU28sXG4gICAgICB2aWV3OiAobykgPT4gKHRoaXMudmlldyA9IG5ldyBFbyhlLCBvLCAocikgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgcik7XG4gICAgICB9KSwgdGhpcy52aWV3KVxuICAgIH0pO1xuICB9XG4gIG9uVXBkYXRlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5vbihcInVwZGF0ZVwiLCBlKTtcbiAgfVxufVxubGV0IEM7XG5mdW5jdGlvbiBPdCgpIHtcbiAgQyB8fCAoQyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIEMuaW5uZXJIVE1MID0gXCJfXCIsIEMuc3R5bGUub3BhY2l0eSA9IFwiMFwiLCBDLnN0eWxlLmhlaWdodCA9IFwiMXB4XCIsIEMuc3R5bGUud2lkdGggPSBcIjFweFwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKEMpKTtcbn1cbmZ1bmN0aW9uIFRvKCkge1xuICBDICYmIChkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKEMpLCBDID0gdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIG90KG4pIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobi5wYXJlbnRFbGVtZW50LmNoaWxkTm9kZXMsIG4pO1xufVxuZnVuY3Rpb24geG8obikge1xuICBmb3IgKDsgbiAmJiBuLm5vZGVOYW1lICE9PSBcIlREXCIgJiYgbi5ub2RlTmFtZSAhPT0gXCJUSFwiOyApXG4gICAgbiA9IG4uY2xhc3NMaXN0ICYmIG4uY2xhc3NMaXN0LmNvbnRhaW5zKFwiUHJvc2VNaXJyb3JcIikgPyBudWxsIDogbi5wYXJlbnROb2RlO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIE1vKG4pIHtcbiAgbi5mb3JFYWNoKCh0KSA9PiB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUodCk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBlLmxlbmd0aDsgbysrKVxuICAgICAgZVtvXS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgfSk7XG59XG5jbGFzcyBCbyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIG8pIHtcbiAgICBkKHRoaXMsIFwic3RhdGVcIik7XG4gICAgZCh0aGlzLCBcImVtaXRVcGRhdGVcIik7XG4gICAgZCh0aGlzLCBcInRhYmxlSWRcIik7XG4gICAgZCh0aGlzLCBcInRhYmxlUG9zXCIpO1xuICAgIGQodGhpcywgXCJtZW51RnJvemVuXCIsICExKTtcbiAgICBkKHRoaXMsIFwicHJldldhc0VkaXRhYmxlXCIsIG51bGwpO1xuICAgIGQodGhpcywgXCJtb3VzZU1vdmVIYW5kbGVyXCIsICh0KSA9PiB7XG4gICAgICB2YXIgYztcbiAgICAgIGlmICh0aGlzLm1lbnVGcm96ZW4pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGUgPSB4byh0LnRhcmdldCk7XG4gICAgICBpZiAoIWUgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgICAgKGMgPSB0aGlzLnN0YXRlKSAhPSBudWxsICYmIGMuc2hvdyAmJiAodGhpcy5zdGF0ZS5zaG93ID0gITEsIHRoaXMuZW1pdFVwZGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbyA9IG90KGUpLCByID0gb3QoZS5wYXJlbnRFbGVtZW50KSwgaSA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHMgPSBlLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYSA9IEN0KGksIHRoaXMucG1WaWV3KTtcbiAgICAgIGlmICghYSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiRm91bmQgdGFibGUgY2VsbCBlbGVtZW50LCBidXQgY291bGQgbm90IGZpbmQgc3Vycm91bmRpbmcgYmxvY2tDb250ZW50IGVsZW1lbnQuXCJcbiAgICAgICAgKTtcbiAgICAgIGlmICh0aGlzLnRhYmxlSWQgPSBhLmlkLCB0aGlzLnN0YXRlICE9PSB2b2lkIDAgJiYgdGhpcy5zdGF0ZS5zaG93ICYmIHRoaXMudGFibGVJZCA9PT0gYS5pZCAmJiB0aGlzLnN0YXRlLnJvd0luZGV4ID09PSByICYmIHRoaXMuc3RhdGUuY29sSW5kZXggPT09IG8pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBsO1xuICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLmRlc2NlbmRhbnRzKChwLCB1KSA9PiB0eXBlb2YgbCA8IFwidVwiID8gITEgOiBwLnR5cGUubmFtZSAhPT0gXCJibG9ja0NvbnRhaW5lclwiIHx8IHAuYXR0cnMuaWQgIT09IGEuaWQgPyAhMCA6IChsID0gayhcbiAgICAgICAgcCxcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgICB0aGlzLmVkaXRvci5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgICB0aGlzLmVkaXRvci5ibG9ja0NhY2hlXG4gICAgICApLCB0aGlzLnRhYmxlUG9zID0gdSArIDEsICExKSksIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIHNob3c6ICEwLFxuICAgICAgICByZWZlcmVuY2VQb3NDZWxsOiBpLFxuICAgICAgICByZWZlcmVuY2VQb3NUYWJsZTogcyxcbiAgICAgICAgYmxvY2s6IGwsXG4gICAgICAgIGNvbEluZGV4OiBvLFxuICAgICAgICByb3dJbmRleDogcixcbiAgICAgICAgZHJhZ2dpbmdTdGF0ZTogdm9pZCAwXG4gICAgICB9LCB0aGlzLmVtaXRVcGRhdGUoKSwgITE7XG4gICAgfSk7XG4gICAgZCh0aGlzLCBcImRyYWdPdmVySGFuZGxlclwiLCAodCkgPT4ge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAoKChtID0gdGhpcy5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG0uZHJhZ2dpbmdTdGF0ZSkgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJtb3ZlXCIsIE1vKFtcbiAgICAgICAgXCJjb2x1bW4tcmVzaXplLWhhbmRsZVwiLFxuICAgICAgICBcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItYmxvY2tcIixcbiAgICAgICAgXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yLWlubGluZVwiXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgubWluKFxuICAgICAgICAgIE1hdGgubWF4KHQuY2xpZW50WCwgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3NUYWJsZS5sZWZ0ICsgMSksXG4gICAgICAgICAgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3NUYWJsZS5yaWdodCAtIDFcbiAgICAgICAgKSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihcbiAgICAgICAgICBNYXRoLm1heCh0LmNsaWVudFksIHRoaXMuc3RhdGUucmVmZXJlbmNlUG9zVGFibGUudG9wICsgMSksXG4gICAgICAgICAgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3NUYWJsZS5ib3R0b20gLSAxXG4gICAgICAgIClcbiAgICAgIH0sIG8gPSBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludChlLmxlZnQsIGUudG9wKS5maWx0ZXIoXG4gICAgICAgIChoKSA9PiBoLnRhZ05hbWUgPT09IFwiVERcIiB8fCBoLnRhZ05hbWUgPT09IFwiVEhcIlxuICAgICAgKTtcbiAgICAgIGlmIChvLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQ291bGQgbm90IGZpbmQgdGFibGUgY2VsbCBlbGVtZW50IHRoYXQgdGhlIG1vdXNlIGN1cnNvciBpcyBob3ZlcmluZyBvdmVyLlwiXG4gICAgICAgICk7XG4gICAgICBjb25zdCByID0gb1swXTtcbiAgICAgIGxldCBpID0gITE7XG4gICAgICBjb25zdCBzID0gb3Qoci5wYXJlbnRFbGVtZW50KSwgYSA9IG90KHIpLCBsID0gdGhpcy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLmRyYWdnZWRDZWxsT3JpZW50YXRpb24gPT09IFwicm93XCIgPyB0aGlzLnN0YXRlLnJvd0luZGV4IDogdGhpcy5zdGF0ZS5jb2xJbmRleCwgcCA9ICh0aGlzLnN0YXRlLmRyYWdnaW5nU3RhdGUuZHJhZ2dlZENlbGxPcmllbnRhdGlvbiA9PT0gXCJyb3dcIiA/IHMgOiBhKSAhPT0gbDtcbiAgICAgICh0aGlzLnN0YXRlLnJvd0luZGV4ICE9PSBzIHx8IHRoaXMuc3RhdGUuY29sSW5kZXggIT09IGEpICYmICh0aGlzLnN0YXRlLnJvd0luZGV4ID0gcywgdGhpcy5zdGF0ZS5jb2xJbmRleCA9IGEsIHRoaXMuc3RhdGUucmVmZXJlbmNlUG9zQ2VsbCA9IHIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGkgPSAhMCk7XG4gICAgICBjb25zdCB1ID0gdGhpcy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLmRyYWdnZWRDZWxsT3JpZW50YXRpb24gPT09IFwicm93XCIgPyBlLnRvcCA6IGUubGVmdDtcbiAgICAgIHRoaXMuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5tb3VzZVBvcyAhPT0gdSAmJiAodGhpcy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLm1vdXNlUG9zID0gdSwgaSA9ICEwKSwgaSAmJiB0aGlzLmVtaXRVcGRhdGUoKSwgcCAmJiB0aGlzLnBtVmlldy5kaXNwYXRjaChcbiAgICAgICAgdGhpcy5wbVZpZXcuc3RhdGUudHIuc2V0TWV0YShYLCAhMClcbiAgICAgICk7XG4gICAgfSk7XG4gICAgZCh0aGlzLCBcImRyb3BIYW5kbGVyXCIsICh0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdm9pZCAwIHx8IHRoaXMuc3RhdGUuZHJhZ2dpbmdTdGF0ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBlID0gdGhpcy5zdGF0ZS5ibG9jay5jb250ZW50LnJvd3M7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLmRyYWdnZWRDZWxsT3JpZW50YXRpb24gPT09IFwicm93XCIpIHtcbiAgICAgICAgY29uc3QgbyA9IGVbdGhpcy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLm9yaWdpbmFsSW5kZXhdO1xuICAgICAgICBlLnNwbGljZSh0aGlzLnN0YXRlLmRyYWdnaW5nU3RhdGUub3JpZ2luYWxJbmRleCwgMSksIGUuc3BsaWNlKHRoaXMuc3RhdGUucm93SW5kZXgsIDAsIG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbyA9IGUubWFwKFxuICAgICAgICAgIChyKSA9PiByLmNlbGxzW3RoaXMuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5vcmlnaW5hbEluZGV4XVxuICAgICAgICApO1xuICAgICAgICBlLmZvckVhY2goKHIsIGkpID0+IHtcbiAgICAgICAgICByLmNlbGxzLnNwbGljZSh0aGlzLnN0YXRlLmRyYWdnaW5nU3RhdGUub3JpZ2luYWxJbmRleCwgMSksIHIuY2VsbHMuc3BsaWNlKHRoaXMuc3RhdGUuY29sSW5kZXgsIDAsIG9baV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWRpdG9yLnVwZGF0ZUJsb2NrKHRoaXMuc3RhdGUuYmxvY2ssIHtcbiAgICAgICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJ0YWJsZUNvbnRlbnRcIixcbiAgICAgICAgICByb3dzOiBlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGQodGhpcywgXCJzY3JvbGxIYW5kbGVyXCIsICgpID0+IHtcbiAgICAgIHZhciB0O1xuICAgICAgaWYgKCh0ID0gdGhpcy5zdGF0ZSkgIT0gbnVsbCAmJiB0LnNob3cpIHtcbiAgICAgICAgY29uc3QgZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYFtkYXRhLW5vZGUtdHlwZT1cImJsb2NrQ29udGFpbmVyXCJdW2RhdGEtaWQ9XCIke3RoaXMudGFibGVJZH1cIl0gdGFibGVgXG4gICAgICAgICksIG8gPSBlLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYHRyOm50aC1jaGlsZCgke3RoaXMuc3RhdGUucm93SW5kZXggKyAxfSkgPiB0ZDpudGgtY2hpbGQoJHt0aGlzLnN0YXRlLmNvbEluZGV4ICsgMX0pYFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnN0YXRlLnJlZmVyZW5jZVBvc1RhYmxlID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5zdGF0ZS5yZWZlcmVuY2VQb3NDZWxsID0gby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5lbWl0VXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IgPSB0LCB0aGlzLnBtVmlldyA9IGUsIHRoaXMuZW1pdFVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdGF0ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGluZyB0byB1cGRhdGUgdW5pbml0aWFsaXplZCBpbWFnZSB0b29sYmFyXCIpO1xuICAgICAgbyh0aGlzLnN0YXRlKTtcbiAgICB9LCBlLmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2VNb3ZlSGFuZGxlciksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLmRyYWdPdmVySGFuZGxlciksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuZHJvcEhhbmRsZXIpLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBtVmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5kcmFnT3ZlckhhbmRsZXIpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLmRyb3BIYW5kbGVyKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuICB9XG59XG5jb25zdCBYID0gbmV3IFQoXCJUYWJsZUhhbmRsZXNQbHVnaW5cIik7XG5jbGFzcyBJbyBleHRlbmRzIHEge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBkKHRoaXMsIFwidmlld1wiKTtcbiAgICBkKHRoaXMsIFwicGx1Z2luXCIpO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgYGRyYWdTdGFydGAgZXZlbnQgZm9yIHdoaWNoZXZlciBlbGVtZW50XG4gICAgICogaXMgdXNlZCBhcyB0aGUgY29sdW1uIGRyYWcgaGFuZGxlLlxuICAgICAqL1xuICAgIGQodGhpcywgXCJjb2xEcmFnU3RhcnRcIiwgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQXR0ZW1wdGVkIHRvIGRyYWcgdGFibGUgY29sdW1uLCBidXQgbm8gdGFibGUgYmxvY2sgd2FzIGhvdmVyZWQgcHJpb3IuXCJcbiAgICAgICAgKTtcbiAgICAgIHRoaXMudmlldy5zdGF0ZS5kcmFnZ2luZ1N0YXRlID0ge1xuICAgICAgICBkcmFnZ2VkQ2VsbE9yaWVudGF0aW9uOiBcImNvbFwiLFxuICAgICAgICBvcmlnaW5hbEluZGV4OiB0aGlzLnZpZXcuc3RhdGUuY29sSW5kZXgsXG4gICAgICAgIG1vdXNlUG9zOiBlLmNsaWVudFhcbiAgICAgIH0sIHRoaXMudmlldy5lbWl0VXBkYXRlKCksIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3Iudmlldy5kaXNwYXRjaChcbiAgICAgICAgdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFgsIHtcbiAgICAgICAgICBkcmFnZ2VkQ2VsbE9yaWVudGF0aW9uOiB0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5kcmFnZ2VkQ2VsbE9yaWVudGF0aW9uLFxuICAgICAgICAgIG9yaWdpbmFsSW5kZXg6IHRoaXMudmlldy5zdGF0ZS5jb2xJbmRleCxcbiAgICAgICAgICBuZXdJbmRleDogdGhpcy52aWV3LnN0YXRlLmNvbEluZGV4LFxuICAgICAgICAgIHRhYmxlUG9zOiB0aGlzLnZpZXcudGFibGVQb3NcbiAgICAgICAgfSlcbiAgICAgICksIE90KCksIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShDLCAwLCAwKSwgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwibW92ZVwiO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgYGRyYWdTdGFydGAgZXZlbnQgZm9yIHdoaWNoZXZlciBlbGVtZW50XG4gICAgICogaXMgdXNlZCBhcyB0aGUgcm93IGRyYWcgaGFuZGxlLlxuICAgICAqL1xuICAgIGQodGhpcywgXCJyb3dEcmFnU3RhcnRcIiwgKGUpID0+IHtcbiAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQXR0ZW1wdGVkIHRvIGRyYWcgdGFibGUgcm93LCBidXQgbm8gdGFibGUgYmxvY2sgd2FzIGhvdmVyZWQgcHJpb3IuXCJcbiAgICAgICAgKTtcbiAgICAgIHRoaXMudmlldy5zdGF0ZS5kcmFnZ2luZ1N0YXRlID0ge1xuICAgICAgICBkcmFnZ2VkQ2VsbE9yaWVudGF0aW9uOiBcInJvd1wiLFxuICAgICAgICBvcmlnaW5hbEluZGV4OiB0aGlzLnZpZXcuc3RhdGUucm93SW5kZXgsXG4gICAgICAgIG1vdXNlUG9zOiBlLmNsaWVudFlcbiAgICAgIH0sIHRoaXMudmlldy5lbWl0VXBkYXRlKCksIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3Iudmlldy5kaXNwYXRjaChcbiAgICAgICAgdGhpcy5lZGl0b3IuX3RpcHRhcEVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKFgsIHtcbiAgICAgICAgICBkcmFnZ2VkQ2VsbE9yaWVudGF0aW9uOiB0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5kcmFnZ2VkQ2VsbE9yaWVudGF0aW9uLFxuICAgICAgICAgIG9yaWdpbmFsSW5kZXg6IHRoaXMudmlldy5zdGF0ZS5yb3dJbmRleCxcbiAgICAgICAgICBuZXdJbmRleDogdGhpcy52aWV3LnN0YXRlLnJvd0luZGV4LFxuICAgICAgICAgIHRhYmxlUG9zOiB0aGlzLnZpZXcudGFibGVQb3NcbiAgICAgICAgfSlcbiAgICAgICksIE90KCksIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShDLCAwLCAwKSwgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGBkcmFnRW5kYCBldmVudCBmb3IgYm90aCB0aGUgZWxlbWVudFxuICAgICAqIHVzZWQgYXMgdGhlIHJvdyBkcmFnIGhhbmRsZSwgYW5kIHRoZSBvbmUgdXNlZCBhcyB0aGUgY29sdW1uIGRyYWcgaGFuZGxlLlxuICAgICAqL1xuICAgIGQodGhpcywgXCJkcmFnRW5kXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT09IHZvaWQgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQXR0ZW1wdGVkIHRvIGRyYWcgdGFibGUgcm93LCBidXQgbm8gdGFibGUgYmxvY2sgd2FzIGhvdmVyZWQgcHJpb3IuXCJcbiAgICAgICAgKTtcbiAgICAgIHRoaXMudmlldy5zdGF0ZS5kcmFnZ2luZ1N0YXRlID0gdm9pZCAwLCB0aGlzLnZpZXcuZW1pdFVwZGF0ZSgpLCB0aGlzLmVkaXRvci5fdGlwdGFwRWRpdG9yLnZpZXcuZGlzcGF0Y2goXG4gICAgICAgIHRoaXMuZWRpdG9yLl90aXB0YXBFZGl0b3Iuc3RhdGUudHIuc2V0TWV0YShYLCBudWxsKVxuICAgICAgKSwgVG8oKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGcmVlemVzIHRoZSBkcmFnIGhhbmRsZXMuIFdoZW4gZnJvemVuLCB0aGV5IHdpbGwgc3RheSBhdHRhY2hlZCB0byB0aGUgc2FtZVxuICAgICAqIGNlbGwgcmVnYXJkbGVzcyBvZiB3aGljaCBjZWxsIGlzIGhvdmVyZWQgYnkgdGhlIG1vdXNlIGN1cnNvci5cbiAgICAgKi9cbiAgICBkKHRoaXMsIFwiZnJlZXplSGFuZGxlc1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnZpZXcubWVudUZyb3plbiA9ICEwO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVuZnJlZXplcyB0aGUgZHJhZyBoYW5kbGVzLiBXaGVuIGZyb3plbiwgdGhleSB3aWxsIHN0YXkgYXR0YWNoZWQgdG8gdGhlXG4gICAgICogc2FtZSBjZWxsIHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggY2VsbCBpcyBob3ZlcmVkIGJ5IHRoZSBtb3VzZSBjdXJzb3IuXG4gICAgICovXG4gICAgZCh0aGlzLCBcInVuZnJlZXplSGFuZGxlc1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLnZpZXcubWVudUZyb3plbiA9ICExO1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yID0gZSwgdGhpcy5wbHVnaW4gPSBuZXcgdih7XG4gICAgICBrZXk6IFgsXG4gICAgICB2aWV3OiAobykgPT4gKHRoaXMudmlldyA9IG5ldyBCbyhlLCBvLCAocikgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgcik7XG4gICAgICB9KSwgdGhpcy52aWV3KSxcbiAgICAgIC8vIFdlIHVzZSBkZWNvcmF0aW9ucyB0byByZW5kZXIgdGhlIGRyb3AgY3Vyc29yIHdoZW4gZHJhZ2dpbmcgYSB0YWJsZSByb3dcbiAgICAgIC8vIG9yIGNvbHVtbi4gVGhlIGRlY29yYXRpb25zIGFyZSB1cGRhdGVkIGluIHRoZSBgZHJhZ092ZXJIYW5kbGVyYCBtZXRob2QuXG4gICAgICBwcm9wczoge1xuICAgICAgICBkZWNvcmF0aW9uczogKG8pID0+IHtcbiAgICAgICAgICBpZiAodGhpcy52aWV3ID09PSB2b2lkIDAgfHwgdGhpcy52aWV3LnN0YXRlID09PSB2b2lkIDAgfHwgdGhpcy52aWV3LnN0YXRlLmRyYWdnaW5nU3RhdGUgPT09IHZvaWQgMCB8fCB0aGlzLnZpZXcudGFibGVQb3MgPT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjb25zdCByID0gdGhpcy52aWV3LnN0YXRlLmRyYWdnaW5nU3RhdGUuZHJhZ2dlZENlbGxPcmllbnRhdGlvbiA9PT0gXCJyb3dcIiA/IHRoaXMudmlldy5zdGF0ZS5yb3dJbmRleCA6IHRoaXMudmlldy5zdGF0ZS5jb2xJbmRleCwgaSA9IFtdO1xuICAgICAgICAgIGlmIChyID09PSB0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5vcmlnaW5hbEluZGV4KVxuICAgICAgICAgICAgcmV0dXJuICQuY3JlYXRlKG8uZG9jLCBpKTtcbiAgICAgICAgICBjb25zdCBzID0gby5kb2MucmVzb2x2ZSh0aGlzLnZpZXcudGFibGVQb3MgKyAxKSwgYSA9IHMubm9kZSgpO1xuICAgICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5kcmFnZ2VkQ2VsbE9yaWVudGF0aW9uID09PSBcInJvd1wiKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gby5kb2MucmVzb2x2ZShcbiAgICAgICAgICAgICAgcy5wb3NBdEluZGV4KHIpICsgMVxuICAgICAgICAgICAgKSwgYyA9IGwubm9kZSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBjLmNoaWxkQ291bnQ7IHArKykge1xuICAgICAgICAgICAgICBjb25zdCB1ID0gby5kb2MucmVzb2x2ZShcbiAgICAgICAgICAgICAgICBsLnBvc0F0SW5kZXgocCkgKyAxXG4gICAgICAgICAgICAgICksIG0gPSB1Lm5vZGUoKSwgaCA9IHUucG9zICsgKHIgPiB0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5vcmlnaW5hbEluZGV4ID8gbS5ub2RlU2l6ZSAtIDIgOiAwKTtcbiAgICAgICAgICAgICAgaS5wdXNoKFxuICAgICAgICAgICAgICAgIC8vIFRoZSB3aWRnZXQgaXMgYSBzbWFsbCBiYXIgd2hpY2ggc3BhbnMgdGhlIHdpZHRoIG9mIHRoZSBjZWxsLlxuICAgICAgICAgICAgICAgIEcud2lkZ2V0KGgsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGYuY2xhc3NOYW1lID0gXCJibi10YWJsZS1kcm9wLWN1cnNvclwiLCBmLnN0eWxlLmxlZnQgPSBcIjBcIiwgZi5zdHlsZS5yaWdodCA9IFwiMFwiLCByID4gdGhpcy52aWV3LnN0YXRlLmRyYWdnaW5nU3RhdGUub3JpZ2luYWxJbmRleCA/IGYuc3R5bGUuYm90dG9tID0gXCItMnB4XCIgOiBmLnN0eWxlLnRvcCA9IFwiLTNweFwiLCBmLnN0eWxlLmhlaWdodCA9IFwiNHB4XCIsIGY7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgYS5jaGlsZENvdW50OyBsKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgYyA9IG8uZG9jLnJlc29sdmUoXG4gICAgICAgICAgICAgICAgcy5wb3NBdEluZGV4KGwpICsgMVxuICAgICAgICAgICAgICApLCBwID0gby5kb2MucmVzb2x2ZShcbiAgICAgICAgICAgICAgICBjLnBvc0F0SW5kZXgocikgKyAxXG4gICAgICAgICAgICAgICksIHUgPSBwLm5vZGUoKSwgbSA9IHAucG9zICsgKHIgPiB0aGlzLnZpZXcuc3RhdGUuZHJhZ2dpbmdTdGF0ZS5vcmlnaW5hbEluZGV4ID8gdS5ub2RlU2l6ZSAtIDIgOiAwKTtcbiAgICAgICAgICAgICAgaS5wdXNoKFxuICAgICAgICAgICAgICAgIC8vIFRoZSB3aWRnZXQgaXMgYSBzbWFsbCBiYXIgd2hpY2ggc3BhbnMgdGhlIGhlaWdodCBvZiB0aGUgY2VsbC5cbiAgICAgICAgICAgICAgICBHLndpZGdldChtLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBoLmNsYXNzTmFtZSA9IFwiYm4tdGFibGUtZHJvcC1jdXJzb3JcIiwgaC5zdHlsZS50b3AgPSBcIjBcIiwgaC5zdHlsZS5ib3R0b20gPSBcIjBcIiwgciA+IHRoaXMudmlldy5zdGF0ZS5kcmFnZ2luZ1N0YXRlLm9yaWdpbmFsSW5kZXggPyBoLnN0eWxlLnJpZ2h0ID0gXCItMnB4XCIgOiBoLnN0eWxlLmxlZnQgPSBcIi0zcHhcIiwgaC5zdHlsZS53aWR0aCA9IFwiNHB4XCIsIGg7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJC5jcmVhdGUoby5kb2MsIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25VcGRhdGUoZSkge1xuICAgIHJldHVybiB0aGlzLm9uKFwidXBkYXRlXCIsIGUpO1xuICB9XG59XG5mdW5jdGlvbiBfdChuLCB0KSB7XG4gIGNvbnN0IGUgPSBuLnN0YXRlLnNlbGVjdGlvbi5jb250ZW50KCkuY29udGVudCwgciA9IEp0KFxuICAgIG4uc3RhdGUuc2NoZW1hLFxuICAgIHRcbiAgKS5zZXJpYWxpemVQcm9zZU1pcnJvckZyYWdtZW50KGUpLCBzID0gYXQoXG4gICAgbi5zdGF0ZS5zY2hlbWEsXG4gICAgdFxuICApLmV4cG9ydFByb3NlTWlycm9yRnJhZ21lbnQoZSksIGEgPSBTdChzKTtcbiAgcmV0dXJuIHsgaW50ZXJuYWxIVE1MOiByLCBleHRlcm5hbEhUTUw6IHMsIHBsYWluVGV4dDogYSB9O1xufVxuY29uc3QgTG8gPSAobikgPT4gTS5jcmVhdGUoe1xuICBuYW1lOiBcImNvcHlUb0NsaXBib2FyZFwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyB2KHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgIGNvcHkodCwgZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKSwgXCJub2RlXCIgaW4gdC5zdGF0ZS5zZWxlY3Rpb24gJiYgdC5zdGF0ZS5zZWxlY3Rpb24ubm9kZS50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tDb250ZW50XCIgJiYgdC5kaXNwYXRjaChcbiAgICAgICAgICAgICAgICB0LnN0YXRlLnRyLnNldFNlbGVjdGlvbihcbiAgICAgICAgICAgICAgICAgIG5ldyBydChcbiAgICAgICAgICAgICAgICAgICAgdC5zdGF0ZS5kb2MucmVzb2x2ZSh0LnN0YXRlLnNlbGVjdGlvbi5mcm9tIC0gMSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGNvbnN0IHsgaW50ZXJuYWxIVE1MOiBvLCBleHRlcm5hbEhUTUw6IHIsIHBsYWluVGV4dDogaSB9ID0gX3QodCwgbik7XG4gICAgICAgICAgICAgIHJldHVybiBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcImJsb2Nrbm90ZS9odG1sXCIsIG8pLCBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCByKSwgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGkpLCAhMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGZvciB0aGUgdXNlLWNhc2UgaW4gd2hpY2ggb25seSBhIGJsb2NrIHdpdGhvdXQgY29udGVudFxuICAgICAgICAgICAgLy8gaXMgc2VsZWN0ZWQsIGUuZy4gYW4gaW1hZ2UgYmxvY2ssIGFuZCBkcmFnZ2VkIChub3QgdXNpbmcgdGhlXG4gICAgICAgICAgICAvLyBkcmFnIGhhbmRsZSkuXG4gICAgICAgICAgICBkcmFnc3RhcnQodCwgZSkge1xuICAgICAgICAgICAgICBpZiAoIShcIm5vZGVcIiBpbiB0LnN0YXRlLnNlbGVjdGlvbikgfHwgdC5zdGF0ZS5zZWxlY3Rpb24ubm9kZS50eXBlLnNwZWMuZ3JvdXAgIT09IFwiYmxvY2tDb250ZW50XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB0LmRpc3BhdGNoKFxuICAgICAgICAgICAgICAgIHQuc3RhdGUudHIuc2V0U2VsZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgbmV3IHJ0KFxuICAgICAgICAgICAgICAgICAgICB0LnN0YXRlLmRvYy5yZXNvbHZlKHQuc3RhdGUuc2VsZWN0aW9uLmZyb20gLSAxKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSwgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLmRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcbiAgICAgICAgICAgICAgY29uc3QgeyBpbnRlcm5hbEhUTUw6IG8sIGV4dGVybmFsSFRNTDogciwgcGxhaW5UZXh0OiBpIH0gPSBfdCh0LCBuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJibG9ja25vdGUvaHRtbFwiLCBvKSwgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvaHRtbFwiLCByKSwgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgaSksICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG59KSwgTm8gPSBbXG4gIFwiYmxvY2tub3RlL2h0bWxcIixcbiAgXCJ0ZXh0L2h0bWxcIixcbiAgXCJ0ZXh0L3BsYWluXCJcbl0sIEFvID0gKG4pID0+IE0uY3JlYXRlKHtcbiAgbmFtZTogXCJwYXN0ZUZyb21DbGlwYm9hcmRcIixcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgdih7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICBwYXN0ZSh0LCBlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgbGV0IG8gPSBudWxsO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHIgb2YgTm8pXG4gICAgICAgICAgICAgICAgaWYgKGUuY2xpcGJvYXJkRGF0YS50eXBlcy5pbmNsdWRlcyhyKSkge1xuICAgICAgICAgICAgICAgICAgbyA9IHI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHIgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShvKTtcbiAgICAgICAgICAgICAgICBvID09PSBcInRleHQvaHRtbFwiICYmIChyID0gYWUoXG4gICAgICAgICAgICAgICAgICByLnRyaW0oKVxuICAgICAgICAgICAgICAgICkuaW5uZXJIVE1MKSwgbi5fdGlwdGFwRWRpdG9yLnZpZXcucGFzdGVIVE1MKHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSksIEhvID0gTS5jcmVhdGUoe1xuICBuYW1lOiBcImJsb2NrQmFja2dyb3VuZENvbG9yXCIsXG4gIGFkZEdsb2JhbEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdHlwZXM6IFtcImJsb2NrQ29udGFpbmVyXCJdLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB3LmJhY2tncm91bmRDb2xvci5kZWZhdWx0LFxuICAgICAgICAgICAgcGFyc2VIVE1MOiAobikgPT4gbi5oYXNBdHRyaWJ1dGUoXCJkYXRhLWJhY2tncm91bmQtY29sb3JcIikgPyBuLmdldEF0dHJpYnV0ZShcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiKSA6IHcuYmFja2dyb3VuZENvbG9yLmRlZmF1bHQsXG4gICAgICAgICAgICByZW5kZXJIVE1MOiAobikgPT4gbi5iYWNrZ3JvdW5kQ29sb3IgIT09IHcuYmFja2dyb3VuZENvbG9yLmRlZmF1bHQgJiYge1xuICAgICAgICAgICAgICBcImRhdGEtYmFja2dyb3VuZC1jb2xvclwiOiBuLmJhY2tncm91bmRDb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH1cbn0pLCBQbyA9IG5ldyBUKFwiYmxvY2tub3RlLXBsYWNlaG9sZGVyXCIpLCBEbyA9IE0uY3JlYXRlKHtcbiAgbmFtZTogXCJwbGFjZWhvbGRlclwiLFxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwbGFjZWhvbGRlcnM6IHtcbiAgICAgICAgZGVmYXVsdDogXCJFbnRlciB0ZXh0IG9yIHR5cGUgJy8nIGZvciBjb21tYW5kc1wiLFxuICAgICAgICBoZWFkaW5nOiBcIkhlYWRpbmdcIixcbiAgICAgICAgYnVsbGV0TGlzdEl0ZW06IFwiTGlzdFwiLFxuICAgICAgICBudW1iZXJlZExpc3RJdGVtOiBcIkxpc3RcIlxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCBuID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVycztcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IHYoe1xuICAgICAgICBrZXk6IFBvLFxuICAgICAgICB2aWV3OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHQpO1xuICAgICAgICAgIGNvbnN0IGUgPSB0LnNoZWV0LCBvID0gKGkgPSBcIlwiKSA9PiBgLmJuLWJsb2NrLWNvbnRlbnQke2l9IC5ibi1pbmxpbmUtY29udGVudDpoYXMoPiAuUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVhayk6YmVmb3JlYCwgciA9IChpLCBzID0gITApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBzID8gXCJbZGF0YS1pcy1lbXB0eS1hbmQtZm9jdXNlZF1cIiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAoaSA9PT0gXCJkZWZhdWx0XCIpXG4gICAgICAgICAgICAgIHJldHVybiBvKGEpO1xuICAgICAgICAgICAgY29uc3QgbCA9IGBbZGF0YS1jb250ZW50LXR5cGU9XCIke2l9XCJdYDtcbiAgICAgICAgICAgIHJldHVybiBvKGEgKyBsKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZvciAoY29uc3QgW2ksIHNdIG9mIE9iamVjdC5lbnRyaWVzKG4pKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gaSA9PT0gXCJkZWZhdWx0XCI7XG4gICAgICAgICAgICBlLmluc2VydFJ1bGUoXG4gICAgICAgICAgICAgIGAke3IoXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICAgICl9eyBjb250ZW50OiAke0pTT04uc3RyaW5naWZ5KHMpfTsgfWBcbiAgICAgICAgICAgICksIGEgfHwgZS5pbnNlcnRSdWxlKFxuICAgICAgICAgICAgICBgJHtyKGksICEwKX17IGNvbnRlbnQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgc1xuICAgICAgICAgICAgICApfTsgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAvLyBUT0RPOiBtYXliZSBhbHNvIGFkZCBwbGFjZWhvbGRlciBmb3IgZW1wdHkgZG9jdW1lbnQgKFwiZS5nLjogc3RhcnQgd3JpdGluZy4uXCIpXG4gICAgICAgICAgZGVjb3JhdGlvbnM6ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRvYzogZSwgc2VsZWN0aW9uOiBvIH0gPSB0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5pc0VkaXRhYmxlIHx8ICFvLmVtcHR5KVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBpID0gby4kYW5jaG9yLCBzID0gaS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocy5jb250ZW50LnNpemUgPiAwKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBpLmJlZm9yZSgpLCBsID0gRy5ub2RlKGEsIGEgKyBzLm5vZGVTaXplLCB7XG4gICAgICAgICAgICAgIFwiZGF0YS1pcy1lbXB0eS1hbmQtZm9jdXNlZFwiOiBcInRydWVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gJC5jcmVhdGUoZSwgW2xdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSksIE9vID0gTS5jcmVhdGUoe1xuICBuYW1lOiBcInRleHRBbGlnbm1lbnRcIixcbiAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICAvLyBBdHRyaWJ1dGUgaXMgYXBwbGllZCB0byBibG9jayBjb250ZW50IGluc3RlYWQgb2YgY29udGFpbmVyIHNvIHRoYXQgY2hpbGQgYmxvY2tzIGRvbid0IGluaGVyaXQgdGhlIHRleHRcbiAgICAgICAgLy8gYWxpZ25tZW50IHN0eWxpbmcuXG4gICAgICAgIHR5cGVzOiBbXCJwYXJhZ3JhcGhcIiwgXCJoZWFkaW5nXCIsIFwiYnVsbGV0TGlzdEl0ZW1cIiwgXCJudW1iZXJlZExpc3RJdGVtXCJdLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgdGV4dEFsaWdubWVudDoge1xuICAgICAgICAgICAgZGVmYXVsdDogXCJsZWZ0XCIsXG4gICAgICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmdldEF0dHJpYnV0ZShcImRhdGEtdGV4dC1hbGlnbm1lbnRcIiksXG4gICAgICAgICAgICByZW5kZXJIVE1MOiAobikgPT4gbi50ZXh0QWxpZ25tZW50ICE9PSBcImxlZnRcIiAmJiB7XG4gICAgICAgICAgICAgIFwiZGF0YS10ZXh0LWFsaWdubWVudFwiOiBuLnRleHRBbGlnbm1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9XG59KSwgX28gPSBNLmNyZWF0ZSh7XG4gIG5hbWU6IFwiYmxvY2tUZXh0Q29sb3JcIixcbiAgYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0eXBlczogW1wiYmxvY2tDb250YWluZXJcIl0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB0ZXh0Q29sb3I6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHcudGV4dENvbG9yLmRlZmF1bHQsXG4gICAgICAgICAgICBwYXJzZUhUTUw6IChuKSA9PiBuLmhhc0F0dHJpYnV0ZShcImRhdGEtdGV4dC1jb2xvclwiKSA/IG4uZ2V0QXR0cmlidXRlKFwiZGF0YS10ZXh0LWNvbG9yXCIpIDogdy50ZXh0Q29sb3IuZGVmYXVsdCxcbiAgICAgICAgICAgIHJlbmRlckhUTUw6IChuKSA9PiBuLnRleHRDb2xvciAhPT0gdy50ZXh0Q29sb3IuZGVmYXVsdCAmJiB7XG4gICAgICAgICAgICAgIFwiZGF0YS10ZXh0LWNvbG9yXCI6IG4udGV4dENvbG9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfVxufSksIFVvID0gTS5jcmVhdGUoe1xuICBuYW1lOiBcInRyYWlsaW5nTm9kZVwiLFxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgbiA9IG5ldyBUKHRoaXMubmFtZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyB2KHtcbiAgICAgICAga2V5OiBuLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHQsIGUsIG8pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRvYzogciwgdHI6IGksIHNjaGVtYTogcyB9ID0gbywgYSA9IG4uZ2V0U3RhdGUobyksIGwgPSByLmNvbnRlbnQuc2l6ZSAtIDIsIGMgPSBzLm5vZGVzLmJsb2NrQ29udGFpbmVyLCBwID0gcy5ub2Rlcy5wYXJhZ3JhcGg7XG4gICAgICAgICAgaWYgKGEpXG4gICAgICAgICAgICByZXR1cm4gaS5pbnNlcnQoXG4gICAgICAgICAgICAgIGwsXG4gICAgICAgICAgICAgIGMuY3JlYXRlKHZvaWQgMCwgcC5jcmVhdGUoKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgaW5pdDogKHQsIGUpID0+IHtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFwcGx5OiAodCwgZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0LmRvY0NoYW5nZWQpXG4gICAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICAgICAgbGV0IG8gPSB0LmRvYy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIW8gfHwgby50eXBlLm5hbWUgIT09IFwiYmxvY2tHcm91cFwiKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBibG9ja0dyb3VwXCIpO1xuICAgICAgICAgICAgaWYgKG8gPSBvLmxhc3RDaGlsZCwgIW8gfHwgby50eXBlLm5hbWUgIT09IFwiYmxvY2tDb250YWluZXJcIilcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYmxvY2tDb250YWluZXJcIik7XG4gICAgICAgICAgICBjb25zdCByID0gby5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKCFyKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBibG9ja0NvbnRlbnRcIik7XG4gICAgICAgICAgICByZXR1cm4gby5ub2RlU2l6ZSA+IDQgfHwgci50eXBlLnNwZWMuY29udGVudCAhPT0gXCJpbmxpbmUqXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIF07XG4gIH1cbn0pLCBSbyA9IG5ldyBUKFwibm9uLWVkaXRhYmxlLWJsb2NrXCIpLCB6byA9ICgpID0+IG5ldyB2KHtcbiAga2V5OiBSbyxcbiAgcHJvcHM6IHtcbiAgICBoYW5kbGVLZXlEb3duOiAobiwgdCkgPT4ge1xuICAgICAgXCJub2RlXCIgaW4gbi5zdGF0ZS5zZWxlY3Rpb24gJiYgdC5rZXkubGVuZ3RoID09PSAxICYmICF0LmN0cmxLZXkgJiYgIXQuYWx0S2V5ICYmICF0Lm1ldGFLZXkgJiYgIXQuc2hpZnRLZXkgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufSksIFV0ID0gbmV3IFQoXCJwcmV2aW91cy1ibG9ja3NcIiksIFZvID0ge1xuICAvLyBOdW1iZXJlZCBMaXN0IEl0ZW1zXG4gIGluZGV4OiBcImluZGV4XCIsXG4gIC8vIEhlYWRpbmdzXG4gIGxldmVsOiBcImxldmVsXCIsXG4gIC8vIEFsbCBCbG9ja3NcbiAgdHlwZTogXCJ0eXBlXCIsXG4gIGRlcHRoOiBcImRlcHRoXCIsXG4gIFwiZGVwdGgtY2hhbmdlXCI6IFwiZGVwdGgtY2hhbmdlXCJcbn0sIEZvID0gKCkgPT4ge1xuICBsZXQgbjtcbiAgcmV0dXJuIG5ldyB2KHtcbiAgICBrZXk6IFV0LFxuICAgIHZpZXcodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlOiBhc3luYyAoZSwgbykgPT4ge1xuICAgICAgICAgIHZhciByO1xuICAgICAgICAgICgociA9IHRoaXMua2V5KSA9PSBudWxsID8gdm9pZCAwIDogci5nZXRTdGF0ZShlLnN0YXRlKS51cGRhdGVkQmxvY2tzLnNpemUpID4gMCAmJiAobiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZS5kaXNwYXRjaChcbiAgICAgICAgICAgICAgZS5zdGF0ZS50ci5zZXRNZXRhKFV0LCB7IGNsZWFyVXBkYXRlOiAhMCB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LCAwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICBuICYmIGNsZWFyVGltZW91dChuKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8vIEJsb2NrIGF0dHJpYnV0ZXMsIGJ5IGJsb2NrIElELCBmcm9tIGp1c3QgYmVmb3JlIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICBwcmV2VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzOiB7fSxcbiAgICAgICAgICAvLyBCbG9jayBhdHRyaWJ1dGVzLCBieSBibG9jayBJRCwgZnJvbSBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCB0cmFuc2FjdGlvbi5cbiAgICAgICAgICBjdXJyZW50VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzOiB7fSxcbiAgICAgICAgICAvLyBTZXQgb2YgSURzIG9mIGJsb2NrcyB3aG9zZSBhdHRyaWJ1dGVzIGNoYW5nZWQgZnJvbSB0aGUgY3VycmVudCB0cmFuc2FjdGlvbi5cbiAgICAgICAgICB1cGRhdGVkQmxvY2tzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYXBwbHkodCwgZSwgbywgcikge1xuICAgICAgICBpZiAoZS5jdXJyZW50VHJhbnNhY3Rpb25PbGRCbG9ja0F0dHJzID0ge30sIGUudXBkYXRlZEJsb2Nrcy5jbGVhcigpLCAhdC5kb2NDaGFuZ2VkIHx8IG8uZG9jLmVxKHIuZG9jKSlcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgY29uc3QgaSA9IHt9LCBzID0gTXQoby5kb2MsIChjKSA9PiBjLmF0dHJzLmlkKSwgYSA9IG5ldyBNYXAoXG4gICAgICAgICAgcy5tYXAoKGMpID0+IFtjLm5vZGUuYXR0cnMuaWQsIGNdKVxuICAgICAgICApLCBsID0gTXQoci5kb2MsIChjKSA9PiBjLmF0dHJzLmlkKTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGwpIHtcbiAgICAgICAgICBjb25zdCBwID0gYS5nZXQoYy5ub2RlLmF0dHJzLmlkKSwgdSA9IHAgPT0gbnVsbCA/IHZvaWQgMCA6IHAubm9kZS5maXJzdENoaWxkLCBtID0gYy5ub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgaWYgKHAgJiYgdSAmJiBtKSB7XG4gICAgICAgICAgICBjb25zdCBoID0ge1xuICAgICAgICAgICAgICBpbmRleDogbS5hdHRycy5pbmRleCxcbiAgICAgICAgICAgICAgbGV2ZWw6IG0uYXR0cnMubGV2ZWwsXG4gICAgICAgICAgICAgIHR5cGU6IG0udHlwZS5uYW1lLFxuICAgICAgICAgICAgICBkZXB0aDogci5kb2MucmVzb2x2ZShjLnBvcykuZGVwdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgZiA9IHtcbiAgICAgICAgICAgICAgaW5kZXg6IHUuYXR0cnMuaW5kZXgsXG4gICAgICAgICAgICAgIGxldmVsOiB1LmF0dHJzLmxldmVsLFxuICAgICAgICAgICAgICB0eXBlOiB1LnR5cGUubmFtZSxcbiAgICAgICAgICAgICAgZGVwdGg6IG8uZG9jLnJlc29sdmUocC5wb3MpLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaVtjLm5vZGUuYXR0cnMuaWRdID0gZiwgdC5nZXRNZXRhKFwibnVtYmVyZWRMaXN0SW5kZXhpbmdcIikgJiYgKGMubm9kZS5hdHRycy5pZCBpbiBlLnByZXZUcmFuc2FjdGlvbk9sZEJsb2NrQXR0cnMgJiYgKGYgPSBlLnByZXZUcmFuc2FjdGlvbk9sZEJsb2NrQXR0cnNbYy5ub2RlLmF0dHJzLmlkXSksIGgudHlwZSA9PT0gXCJudW1iZXJlZExpc3RJdGVtXCIgJiYgKGYuaW5kZXggPSBoLmluZGV4KSksIGUuY3VycmVudFRyYW5zYWN0aW9uT2xkQmxvY2tBdHRyc1tjLm5vZGUuYXR0cnMuaWRdID0gZiwgSlNPTi5zdHJpbmdpZnkoZikgIT09IEpTT04uc3RyaW5naWZ5KGgpICYmIChmW1wiZGVwdGgtY2hhbmdlXCJdID0gZi5kZXB0aCAtIGguZGVwdGgsIGUudXBkYXRlZEJsb2Nrcy5hZGQoYy5ub2RlLmF0dHJzLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlLnByZXZUcmFuc2FjdGlvbk9sZEJsb2NrQXR0cnMgPSBpLCBlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGRlY29yYXRpb25zKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuZ2V0U3RhdGUodCk7XG4gICAgICAgIGlmIChlLnVwZGF0ZWRCbG9ja3Muc2l6ZSA9PT0gMClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG8gPSBbXTtcbiAgICAgICAgcmV0dXJuIHQuZG9jLmRlc2NlbmRhbnRzKChyLCBpKSA9PiB7XG4gICAgICAgICAgaWYgKCFyLmF0dHJzLmlkIHx8ICFlLnVwZGF0ZWRCbG9ja3MuaGFzKHIuYXR0cnMuaWQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHMgPSBlLmN1cnJlbnRUcmFuc2FjdGlvbk9sZEJsb2NrQXR0cnNbci5hdHRycy5pZF0sIGEgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtjLCBwXSBvZiBPYmplY3QuZW50cmllcyhzKSlcbiAgICAgICAgICAgIGFbXCJkYXRhLXByZXYtXCIgKyBWb1tjXV0gPSBwIHx8IFwibm9uZVwiO1xuICAgICAgICAgIGNvbnN0IGwgPSBHLm5vZGUoaSwgaSArIHIubm9kZVNpemUsIHtcbiAgICAgICAgICAgIC4uLmFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvLnB1c2gobCk7XG4gICAgICAgIH0pLCAkLmNyZWF0ZSh0LmRvYywgbyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0sICRvID0ge1xuICBibG9ja0NvbG9yOiBcImRhdGEtYmxvY2stY29sb3JcIixcbiAgYmxvY2tTdHlsZTogXCJkYXRhLWJsb2NrLXN0eWxlXCIsXG4gIGlkOiBcImRhdGEtaWRcIixcbiAgZGVwdGg6IFwiZGF0YS1kZXB0aFwiLFxuICBkZXB0aENoYW5nZTogXCJkYXRhLWRlcHRoLWNoYW5nZVwiXG59LCBHbyA9IGouY3JlYXRlKHtcbiAgbmFtZTogXCJibG9ja0NvbnRhaW5lclwiLFxuICBncm91cDogXCJibG9ja0NvbnRhaW5lclwiLFxuICAvLyBBIGJsb2NrIGFsd2F5cyBjb250YWlucyBjb250ZW50LCBhbmQgb3B0aW9uYWxseSBhIGJsb2NrR3JvdXAgd2hpY2ggY29udGFpbnMgbmVzdGVkIGJsb2Nrc1xuICBjb250ZW50OiBcImJsb2NrQ29udGVudCBibG9ja0dyb3VwP1wiLFxuICAvLyBFbnN1cmVzIGNvbnRlbnQtc3BlY2lmaWMga2V5Ym9hcmQgaGFuZGxlcnMgdHJpZ2dlciBmaXJzdC5cbiAgcHJpb3JpdHk6IDUwLFxuICBkZWZpbmluZzogITAsXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IFwiZGl2XCIsXG4gICAgICAgIGdldEF0dHJzOiAobikgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtlLCBvXSBvZiBPYmplY3QuZW50cmllcygkbykpXG4gICAgICAgICAgICBuLmdldEF0dHJpYnV0ZShvKSAmJiAodFtlXSA9IG4uZ2V0QXR0cmlidXRlKG8pKTtcbiAgICAgICAgICByZXR1cm4gbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdHlwZVwiKSA9PT0gXCJibG9ja0NvbnRhaW5lclwiID8gdCA6ICExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBuIH0pIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0LmNsYXNzTmFtZSA9IFwiYm4tYmxvY2stb3V0ZXJcIiwgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLW5vZGUtdHlwZVwiLCBcImJsb2NrT3V0ZXJcIik7XG4gICAgZm9yIChjb25zdCBbaSwgc10gb2YgT2JqZWN0LmVudHJpZXMobikpXG4gICAgICBpICE9PSBcImNsYXNzXCIgJiYgdC5zZXRBdHRyaWJ1dGUoaSwgcyk7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLigociA9IHRoaXMub3B0aW9ucy5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogci5ibG9jaykgfHwge30sXG4gICAgICAuLi5uXG4gICAgfSwgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgby5jbGFzc05hbWUgPSBSKFwiYm4tYmxvY2tcIiwgZS5jbGFzcyksIG8uc2V0QXR0cmlidXRlKFwiZGF0YS1ub2RlLXR5cGVcIiwgdGhpcy5uYW1lKTtcbiAgICBmb3IgKGNvbnN0IFtpLCBzXSBvZiBPYmplY3QuZW50cmllcyhlKSlcbiAgICAgIGkgIT09IFwiY2xhc3NcIiAmJiBvLnNldEF0dHJpYnV0ZShpLCBzKTtcbiAgICByZXR1cm4gdC5hcHBlbmRDaGlsZChvKSwge1xuICAgICAgZG9tOiB0LFxuICAgICAgY29udGVudERPTTogb1xuICAgIH07XG4gIH0sXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBDcmVhdGVzIGEgbmV3IHRleHQgYmxvY2sgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgIEJOQ3JlYXRlQmxvY2s6IChuKSA9PiAoeyBzdGF0ZTogdCwgZGlzcGF0Y2g6IGUgfSkgPT4ge1xuICAgICAgICBjb25zdCBvID0gdC5zY2hlbWEubm9kZXMuYmxvY2tDb250YWluZXIuY3JlYXRlQW5kRmlsbCgpO1xuICAgICAgICByZXR1cm4gZSAmJiB0LnRyLmluc2VydChuLCBvKSwgITA7XG4gICAgICB9LFxuICAgICAgLy8gRGVsZXRlcyBhIGJsb2NrIGF0IGEgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICBCTkRlbGV0ZUJsb2NrOiAobikgPT4gKHsgc3RhdGU6IHQsIGRpc3BhdGNoOiBlIH0pID0+IHtcbiAgICAgICAgY29uc3QgbyA9IGIodC5kb2MsIG4pO1xuICAgICAgICBpZiAobyA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgeyBzdGFydFBvczogciwgZW5kUG9zOiBpIH0gPSBvO1xuICAgICAgICByZXR1cm4gZSAmJiB0LnRyLmRlbGV0ZVJhbmdlKHIsIGkpLCAhMDtcbiAgICAgIH0sXG4gICAgICAvLyBVcGRhdGVzIGEgYmxvY2sgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgIEJOVXBkYXRlQmxvY2s6IChuLCB0KSA9PiAoeyBzdGF0ZTogZSwgZGlzcGF0Y2g6IG8gfSkgPT4ge1xuICAgICAgICBjb25zdCByID0gYihlLmRvYywgbik7XG4gICAgICAgIGlmIChyID09PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBjb25zdCB7IHN0YXJ0UG9zOiBpLCBlbmRQb3M6IHMsIG5vZGU6IGEsIGNvbnRlbnROb2RlOiBsIH0gPSByO1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgIGlmICh0LmNoaWxkcmVuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaCBvZiB0LmNoaWxkcmVuKVxuICAgICAgICAgICAgICBtLnB1c2goXG4gICAgICAgICAgICAgICAgUChcbiAgICAgICAgICAgICAgICAgIGgsXG4gICAgICAgICAgICAgICAgICBlLnNjaGVtYSxcbiAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lZGl0b3Iuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYS5jaGlsZENvdW50ID09PSAyID8gZS50ci5yZXBsYWNlKFxuICAgICAgICAgICAgICBpICsgbC5ub2RlU2l6ZSArIDEsXG4gICAgICAgICAgICAgIHMgLSAxLFxuICAgICAgICAgICAgICBuZXcgXyh4LmZyb20obSksIDAsIDApXG4gICAgICAgICAgICApIDogZS50ci5pbnNlcnQoXG4gICAgICAgICAgICAgIGkgKyBsLm5vZGVTaXplLFxuICAgICAgICAgICAgICBlLnNjaGVtYS5ub2Rlcy5ibG9ja0dyb3VwLmNyZWF0ZSh7fSwgbSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGMgPSBsLnR5cGUubmFtZSwgcCA9IHQudHlwZSB8fCBjO1xuICAgICAgICAgIGxldCB1ID0gXCJrZWVwXCI7XG4gICAgICAgICAgaWYgKHQuY29udGVudClcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdC5jb250ZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIHUgPSBbZS5zY2hlbWEudGV4dCh0LmNvbnRlbnQpXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodC5jb250ZW50KSlcbiAgICAgICAgICAgICAgdSA9IHN0KFxuICAgICAgICAgICAgICAgIHQuY29udGVudCxcbiAgICAgICAgICAgICAgICBlLnNjaGVtYSxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdG9yLnNjaGVtYS5zdHlsZVNjaGVtYVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSBpZiAodC5jb250ZW50LnR5cGUgPT09IFwidGFibGVDb250ZW50XCIpXG4gICAgICAgICAgICAgIHUgPSBHdChcbiAgICAgICAgICAgICAgICB0LmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgZS5zY2hlbWEsXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVkaXRvci5zY2hlbWEuc3R5bGVTY2hlbWFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE4odC5jb250ZW50LnR5cGUpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbSA9IGUuc2NoZW1hLm5vZGVzW2NdLnNwZWMuY29udGVudCwgaCA9IGUuc2NoZW1hLm5vZGVzW3BdLnNwZWMuY29udGVudDtcbiAgICAgICAgICAgIG0gPT09IFwiXCIgfHwgaCAhPT0gbSAmJiAodSA9IFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdSA9PT0gXCJrZWVwXCIgPyBlLnRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdC50eXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnNjaGVtYS5ub2Rlc1t0LnR5cGVdLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5sLmF0dHJzLFxuICAgICAgICAgICAgICAuLi50LnByb3BzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSA6IGUudHIucmVwbGFjZVdpdGgoXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIGUuc2NoZW1hLm5vZGVzW3BdLmNyZWF0ZShcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmwuYXR0cnMsXG4gICAgICAgICAgICAgICAgLi4udC5wcm9wc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB1XG4gICAgICAgICAgICApXG4gICAgICAgICAgKS5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgICBlLnNjaGVtYS5ub2Rlc1twXS5zcGVjLmNvbnRlbnQgPT09IFwiXCIgPyBuZXcgcnQoZS50ci5kb2MucmVzb2x2ZShpKSkgOiBlLnNjaGVtYS5ub2Rlc1twXS5zcGVjLmNvbnRlbnQgPT09IFwiaW5saW5lKlwiID8gbmV3IG50KGUudHIuZG9jLnJlc29sdmUoaSkpIDogKFxuICAgICAgICAgICAgICAvLyBOZWVkIHRvIG9mZnNldCB0aGUgcG9zaXRpb24gYXMgd2UgaGF2ZSB0byBnZXQgdGhyb3VnaCB0aGVcbiAgICAgICAgICAgICAgLy8gYHRhYmxlUm93YCBhbmQgYHRhYmxlQ2VsbGAgbm9kZXMgdG8gZ2V0IHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgdGFibGVQYXJhZ3JhcGhgIG5vZGUgd2Ugd2FudCB0byBzZXQgdGhlIHNlbGVjdGlvbiBpbi5cbiAgICAgICAgICAgICAgbmV3IG50KGUudHIuZG9jLnJlc29sdmUoaSArIDQpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksIGUudHIuc2V0Tm9kZU1hcmt1cChpIC0gMSwgdm9pZCAwLCB7XG4gICAgICAgICAgICAuLi5hLmF0dHJzLFxuICAgICAgICAgICAgLi4udC5wcm9wc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH0sXG4gICAgICAvLyBBcHBlbmRzIHRoZSB0ZXh0IGNvbnRlbnRzIG9mIGEgYmxvY2sgdG8gdGhlIG5lYXJlc3QgcHJldmlvdXMgYmxvY2ssIGdpdmVuIGEgcG9zaXRpb24gYmV0d2VlbiB0aGVtLiBDaGlsZHJlbiBvZlxuICAgICAgLy8gdGhlIG1lcmdlZCBibG9jayBhcmUgbW92ZWQgb3V0IG9mIGl0IGZpcnN0LCByYXRoZXIgdGhhbiBhbHNvIGJlaW5nIG1lcmdlZC5cbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgZXhhbXBsZSBiZWxvdywgdGhlIHBvc2l0aW9uIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvbiBpcyBiZXR3ZWVuIEJsb2NrMSBhbmQgQmxvY2syLlxuICAgICAgLy9cbiAgICAgIC8vIEJsb2NrMVxuICAgICAgLy8gICAgQmxvY2syXG4gICAgICAvLyBCbG9jazNcbiAgICAgIC8vICAgIEJsb2NrNFxuICAgICAgLy8gICAgICAgIEJsb2NrNVxuICAgICAgLy9cbiAgICAgIC8vIEJlY29tZXM6XG4gICAgICAvL1xuICAgICAgLy8gQmxvY2sxXG4gICAgICAvLyAgICBCbG9jazJCbG9jazNcbiAgICAgIC8vIEJsb2NrNFxuICAgICAgLy8gICAgIEJsb2NrNVxuICAgICAgQk5NZXJnZUJsb2NrczogKG4pID0+ICh7IHN0YXRlOiB0LCBkaXNwYXRjaDogZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSB0LmRvYy5yZXNvbHZlKG4gKyAxKS5ub2RlKCkudHlwZS5uYW1lID09PSBcImJsb2NrQ29udGFpbmVyXCIsIHIgPSB0LmRvYy5yZXNvbHZlKG4gLSAxKS5ub2RlKCkudHlwZS5uYW1lID09PSBcImJsb2NrQ29udGFpbmVyXCI7XG4gICAgICAgIGlmICghbyB8fCAhcilcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IGkgPSBiKFxuICAgICAgICAgIHQuZG9jLFxuICAgICAgICAgIG4gKyAxXG4gICAgICAgICksIHsgbm9kZTogcywgY29udGVudE5vZGU6IGEsIHN0YXJ0UG9zOiBsLCBlbmRQb3M6IGMsIGRlcHRoOiBwIH0gPSBpO1xuICAgICAgICBpZiAocy5jaGlsZENvdW50ID09PSAyKSB7XG4gICAgICAgICAgY29uc3QgaCA9IHQuZG9jLnJlc29sdmUoXG4gICAgICAgICAgICBsICsgYS5ub2RlU2l6ZSArIDFcbiAgICAgICAgICApLCBmID0gdC5kb2MucmVzb2x2ZShjIC0gMSksIHkgPSBoLmJsb2NrUmFuZ2UoZik7XG4gICAgICAgICAgZSAmJiB0LnRyLmxpZnQoeSwgcCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1ID0gbiAtIDEsIG0gPSBiKHQuZG9jLCB1KTtcbiAgICAgICAgZm9yICg7IG0ubnVtQ2hpbGRCbG9ja3MgPiAwOyApXG4gICAgICAgICAgaWYgKHUtLSwgbSA9IGIodC5kb2MsIHUpLCBtID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIHJldHVybiBlICYmIChlKFxuICAgICAgICAgIHQudHIuZGVsZXRlUmFuZ2UobCwgbCArIGEubm9kZVNpemUpLnJlcGxhY2UoXG4gICAgICAgICAgICB1IC0gMSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBuZXcgXyhhLmNvbnRlbnQsIDAsIDApXG4gICAgICAgICAgKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgICksIHQudHIuc2V0U2VsZWN0aW9uKFxuICAgICAgICAgIG5ldyBudCh0LmRvYy5yZXNvbHZlKHUgLSAxKSlcbiAgICAgICAgKSksICEwO1xuICAgICAgfSxcbiAgICAgIC8vIFNwbGl0cyBhIGJsb2NrIGF0IGEgZ2l2ZW4gcG9zaXRpb24uIENvbnRlbnQgYWZ0ZXIgdGhlIHBvc2l0aW9uIGlzIG1vdmVkIHRvIGEgbmV3IGJsb2NrIGJlbG93LCBhdCB0aGUgc2FtZVxuICAgICAgLy8gbmVzdGluZyBsZXZlbC5cbiAgICAgIEJOU3BsaXRCbG9jazogKG4sIHQpID0+ICh7IHN0YXRlOiBlLCBkaXNwYXRjaDogbyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSBiKGUuZG9jLCBuKTtcbiAgICAgICAgaWYgKHIgPT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IHsgY29udGVudE5vZGU6IGksIGNvbnRlbnRUeXBlOiBzLCBzdGFydFBvczogYSwgZW5kUG9zOiBsLCBkZXB0aDogYyB9ID0gciwgcCA9IGUuZG9jLmN1dChhICsgMSwgbiksIHUgPSBlLmRvYy5jdXQobiwgbCAtIDEpLCBtID0gZS5zY2hlbWEubm9kZXMuYmxvY2tDb250YWluZXIuY3JlYXRlQW5kRmlsbCgpLCBoID0gbCArIDEsIGYgPSBoICsgMjtcbiAgICAgICAgcmV0dXJuIG8gJiYgKGUudHIuaW5zZXJ0KGgsIG0pLCBlLnRyLnJlcGxhY2UoXG4gICAgICAgICAgZixcbiAgICAgICAgICBmICsgMSxcbiAgICAgICAgICB1LmNvbnRlbnQuc2l6ZSA+IDAgPyBuZXcgXyhcbiAgICAgICAgICAgIHguZnJvbSh1KSxcbiAgICAgICAgICAgIGMgKyAyLFxuICAgICAgICAgICAgYyArIDJcbiAgICAgICAgICApIDogdm9pZCAwXG4gICAgICAgICksIHQgJiYgZS50ci5zZXRCbG9ja1R5cGUoXG4gICAgICAgICAgZixcbiAgICAgICAgICBmLFxuICAgICAgICAgIGUuc2NoZW1hLm5vZGUocykudHlwZSxcbiAgICAgICAgICBpLmF0dHJzXG4gICAgICAgICksIGUudHIuc2V0U2VsZWN0aW9uKFxuICAgICAgICAgIG5ldyBudChlLmRvYy5yZXNvbHZlKGYpKVxuICAgICAgICApLCBlLnRyLnJlcGxhY2UoXG4gICAgICAgICAgYSArIDEsXG4gICAgICAgICAgbCAtIDEsXG4gICAgICAgICAgcC5jb250ZW50LnNpemUgPiAwID8gbmV3IF8oXG4gICAgICAgICAgICB4LmZyb20ocCksXG4gICAgICAgICAgICBjICsgMixcbiAgICAgICAgICAgIGMgKyAyXG4gICAgICAgICAgKSA6IHZvaWQgMFxuICAgICAgICApKSwgITA7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbRm8oKSwgem8oKV07XG4gIH0sXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBCYWNrc3BhY2U6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzOiBvIH0pID0+IFtcbiAgICAgICAgLy8gRGVsZXRlcyB0aGUgc2VsZWN0aW9uIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAgICAoKSA9PiBvLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAvLyBVbmRvZXMgYW4gaW5wdXQgcnVsZSBpZiBvbmUgd2FzIHRyaWdnZXJlZCBpbiB0aGUgbGFzdCBlZGl0b3Igc3RhdGUgY2hhbmdlLlxuICAgICAgICAoKSA9PiBvLnVuZG9JbnB1dFJ1bGUoKSxcbiAgICAgICAgLy8gUmV2ZXJ0cyBibG9jayBjb250ZW50IHR5cGUgdG8gYSBwYXJhZ3JhcGggaWYgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGJsb2NrLlxuICAgICAgICAoKSA9PiBvLmNvbW1hbmQoKHsgc3RhdGU6IHIgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgY29udGVudFR5cGU6IGksIHN0YXJ0UG9zOiBzIH0gPSBiKFxuICAgICAgICAgICAgci5kb2MsXG4gICAgICAgICAgICByLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgKSwgYSA9IHIuc2VsZWN0aW9uLmZyb20gPT09IHMgKyAxLCBsID0gaS5uYW1lID09PSBcInBhcmFncmFwaFwiO1xuICAgICAgICAgIHJldHVybiBhICYmICFsID8gby5CTlVwZGF0ZUJsb2NrKHIuc2VsZWN0aW9uLmZyb20sIHtcbiAgICAgICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgICAgICBwcm9wczoge31cbiAgICAgICAgICB9KSA6ICExO1xuICAgICAgICB9KSxcbiAgICAgICAgLy8gUmVtb3ZlcyBhIGxldmVsIG9mIG5lc3RpbmcgaWYgdGhlIGJsb2NrIGlzIGluZGVudGVkIGlmIHRoZSBzZWxlY3Rpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBibG9jay5cbiAgICAgICAgKCkgPT4gby5jb21tYW5kKCh7IHN0YXRlOiByIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IHN0YXJ0UG9zOiBpIH0gPSBiKFxuICAgICAgICAgICAgci5kb2MsXG4gICAgICAgICAgICByLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gci5zZWxlY3Rpb24uZnJvbSA9PT0gaSArIDEgPyBvLmxpZnRMaXN0SXRlbShcImJsb2NrQ29udGFpbmVyXCIpIDogITE7XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBNZXJnZXMgYmxvY2sgd2l0aCB0aGUgcHJldmlvdXMgb25lIGlmIGl0IGlzbid0IGluZGVudGVkLCBpc24ndCB0aGUgZmlyc3QgYmxvY2sgaW4gdGhlIGRvYywgYW5kIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgLy8gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBibG9jay5cbiAgICAgICAgKCkgPT4gby5jb21tYW5kKCh7IHN0YXRlOiByIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRlcHRoOiBpLCBzdGFydFBvczogcyB9ID0gYihcbiAgICAgICAgICAgIHIuZG9jLFxuICAgICAgICAgICAgci5zZWxlY3Rpb24uZnJvbVxuICAgICAgICAgICksIGEgPSByLnNlbGVjdGlvbi5mcm9tID09PSBzICsgMSwgbCA9IHIuc2VsZWN0aW9uLmVtcHR5LCBjID0gcyA9PT0gMiwgcCA9IHMgLSAxO1xuICAgICAgICAgIHJldHVybiAhYyAmJiBhICYmIGwgJiYgaSA9PT0gMiA/IG8uQk5NZXJnZUJsb2NrcyhwKSA6ICExO1xuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICBEZWxldGU6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzOiBvIH0pID0+IFtcbiAgICAgICAgLy8gRGVsZXRlcyB0aGUgc2VsZWN0aW9uIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAgICAoKSA9PiBvLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAvLyBNZXJnZXMgYmxvY2sgd2l0aCB0aGUgbmV4dCBvbmUgKGF0IHRoZSBzYW1lIG5lc3RpbmcgbGV2ZWwgb3IgbG93ZXIpLFxuICAgICAgICAvLyBpZiBvbmUgZXhpc3RzLCB0aGUgYmxvY2sgaGFzIG5vIGNoaWxkcmVuLCBhbmQgdGhlIHNlbGVjdGlvbiBpcyBhdCB0aGVcbiAgICAgICAgLy8gZW5kIG9mIHRoZSBibG9jay5cbiAgICAgICAgKCkgPT4gby5jb21tYW5kKCh7IHN0YXRlOiByIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IG5vZGU6IGksIGRlcHRoOiBzLCBlbmRQb3M6IGEgfSA9IGIoXG4gICAgICAgICAgICByLmRvYyxcbiAgICAgICAgICAgIHIuc2VsZWN0aW9uLmZyb21cbiAgICAgICAgICApLCBsID0gYSA9PT0gci5kb2Mubm9kZVNpemUgLSA0LCBjID0gci5zZWxlY3Rpb24uZnJvbSA9PT0gYSAtIDEsIHAgPSByLnNlbGVjdGlvbi5lbXB0eSwgdSA9IGkuY2hpbGRDb3VudCA9PT0gMjtcbiAgICAgICAgICBpZiAoIWwgJiYgYyAmJiBwICYmICF1KSB7XG4gICAgICAgICAgICBsZXQgbSA9IHMsIGggPSBhICsgMiwgZiA9IHIuZG9jLnJlc29sdmUoaCkuZGVwdGg7XG4gICAgICAgICAgICBmb3IgKDsgZiA8IG07IClcbiAgICAgICAgICAgICAgbSA9IGYsIGggKz0gMiwgZiA9IHIuZG9jLnJlc29sdmUoaCkuZGVwdGg7XG4gICAgICAgICAgICByZXR1cm4gby5CTk1lcmdlQmxvY2tzKGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHM6IG8gfSkgPT4gW1xuICAgICAgICAvLyBSZW1vdmVzIGEgbGV2ZWwgb2YgbmVzdGluZyBpZiB0aGUgYmxvY2sgaXMgZW1wdHkgJiBpbmRlbnRlZCwgd2hpbGUgdGhlIHNlbGVjdGlvbiBpcyBhbHNvIGVtcHR5ICYgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIG9mIHRoZSBibG9jay5cbiAgICAgICAgKCkgPT4gby5jb21tYW5kKCh7IHN0YXRlOiByIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IG5vZGU6IGksIGRlcHRoOiBzIH0gPSBiKFxuICAgICAgICAgICAgci5kb2MsXG4gICAgICAgICAgICByLnNlbGVjdGlvbi5mcm9tXG4gICAgICAgICAgKSwgYSA9IHIuc2VsZWN0aW9uLiRhbmNob3IucGFyZW50T2Zmc2V0ID09PSAwLCBsID0gci5zZWxlY3Rpb24uYW5jaG9yID09PSByLnNlbGVjdGlvbi5oZWFkLCBjID0gaS50ZXh0Q29udGVudC5sZW5ndGggPT09IDAsIHAgPSBzID4gMjtcbiAgICAgICAgICByZXR1cm4gYSAmJiBsICYmIGMgJiYgcCA/IG8ubGlmdExpc3RJdGVtKFwiYmxvY2tDb250YWluZXJcIikgOiAhMTtcbiAgICAgICAgfSksXG4gICAgICAgIC8vIENyZWF0ZXMgYSBuZXcgYmxvY2sgYW5kIG1vdmVzIHRoZSBzZWxlY3Rpb24gdG8gaXQgaWYgdGhlIGN1cnJlbnQgb25lIGlzIGVtcHR5LCB3aGlsZSB0aGUgc2VsZWN0aW9uIGlzIGFsc29cbiAgICAgICAgLy8gZW1wdHkgJiBhdCB0aGUgc3RhcnQgb2YgdGhlIGJsb2NrLlxuICAgICAgICAoKSA9PiBvLmNvbW1hbmQoKHsgc3RhdGU6IHIsIGNoYWluOiBpIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IG5vZGU6IHMsIGVuZFBvczogYSB9ID0gYihcbiAgICAgICAgICAgIHIuZG9jLFxuICAgICAgICAgICAgci5zZWxlY3Rpb24uZnJvbVxuICAgICAgICAgICksIGwgPSByLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudE9mZnNldCA9PT0gMCwgYyA9IHIuc2VsZWN0aW9uLmFuY2hvciA9PT0gci5zZWxlY3Rpb24uaGVhZCwgcCA9IHMudGV4dENvbnRlbnQubGVuZ3RoID09PSAwO1xuICAgICAgICAgIGlmIChsICYmIGMgJiYgcCkge1xuICAgICAgICAgICAgY29uc3QgdSA9IGEgKyAxLCBtID0gdSArIDI7XG4gICAgICAgICAgICByZXR1cm4gaSgpLkJOQ3JlYXRlQmxvY2sodSkuc2V0VGV4dFNlbGVjdGlvbihtKS5ydW4oKSwgITA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSksXG4gICAgICAgIC8vIFNwbGl0cyB0aGUgY3VycmVudCBibG9jaywgbW92aW5nIGNvbnRlbnQgaW5zaWRlIHRoYXQncyBhZnRlciB0aGUgY3Vyc29yIHRvIGEgbmV3IHRleHQgYmxvY2sgYmVsb3cuIEFsc29cbiAgICAgICAgLy8gZGVsZXRlcyB0aGUgc2VsZWN0aW9uIGJlZm9yZWhhbmQsIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAgICAoKSA9PiBvLmNvbW1hbmQoKHsgc3RhdGU6IHIsIGNoYWluOiBpIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IG5vZGU6IHMgfSA9IGIoXG4gICAgICAgICAgICByLmRvYyxcbiAgICAgICAgICAgIHIuc2VsZWN0aW9uLmZyb21cbiAgICAgICAgICApLCBhID0gci5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnRPZmZzZXQgPT09IDA7XG4gICAgICAgICAgcmV0dXJuIHMudGV4dENvbnRlbnQubGVuZ3RoID09PSAwID8gITEgOiAoaSgpLmRlbGV0ZVNlbGVjdGlvbigpLkJOU3BsaXRCbG9jayhyLnNlbGVjdGlvbi5mcm9tLCBhKS5ydW4oKSwgITApO1xuICAgICAgICB9KVxuICAgICAgXSksXG4gICAgICAvLyBBbHdheXMgcmV0dXJuaW5nIHRydWUgZm9yIHRhYiBrZXkgcHJlc3NlcyBlbnN1cmVzIHRoZXkncmUgbm90IGNhcHR1cmVkIGJ5IHRoZSBicm93c2VyLiBPdGhlcndpc2UsIHRoZXkgYmx1ciB0aGVcbiAgICAgIC8vIGVkaXRvciBzaW5jZSB0aGUgYnJvd3NlciB3aWxsIHRyeSB0byB1c2UgdGFiIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICAgICAgVGFiOiAoKSA9PiAodGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKFwiYmxvY2tDb250YWluZXJcIiksICEwKSxcbiAgICAgIFwiU2hpZnQtVGFiXCI6ICgpID0+ICh0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0oXCJibG9ja0NvbnRhaW5lclwiKSwgITApXG4gICAgfTtcbiAgfVxufSksIGpvID0gai5jcmVhdGUoe1xuICBuYW1lOiBcImJsb2NrR3JvdXBcIixcbiAgZ3JvdXA6IFwiYmxvY2tHcm91cFwiLFxuICBjb250ZW50OiBcImJsb2NrQ29udGFpbmVyK1wiLFxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiBcImRpdlwiLFxuICAgICAgICBnZXRBdHRyczogKG4pID0+IHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyAhMSA6IG4uZ2V0QXR0cmlidXRlKFwiZGF0YS1ub2RlLXR5cGVcIikgPT09IFwiYmxvY2tHcm91cFwiID8gbnVsbCA6ICExXG4gICAgICB9XG4gICAgXTtcbiAgfSxcbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzOiBuIH0pIHtcbiAgICB2YXIgbztcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4uKChvID0gdGhpcy5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBvLmJsb2NrR3JvdXApIHx8IHt9LFxuICAgICAgLi4ublxuICAgIH0sIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGUuY2xhc3NOYW1lID0gUihcbiAgICAgIFwiYm4tYmxvY2stZ3JvdXBcIixcbiAgICAgIHQuY2xhc3NcbiAgICApLCBlLnNldEF0dHJpYnV0ZShcImRhdGEtbm9kZS10eXBlXCIsIFwiYmxvY2tHcm91cFwiKTtcbiAgICBmb3IgKGNvbnN0IFtyLCBpXSBvZiBPYmplY3QuZW50cmllcyh0KSlcbiAgICAgIHIgIT09IFwiY2xhc3NcIiAmJiBlLnNldEF0dHJpYnV0ZShyLCBpKTtcbiAgICByZXR1cm4ge1xuICAgICAgZG9tOiBlLFxuICAgICAgY29udGVudERPTTogZVxuICAgIH07XG4gIH1cbn0pLCBXbyA9IGouY3JlYXRlKHtcbiAgbmFtZTogXCJkb2NcIixcbiAgdG9wTm9kZTogITAsXG4gIGNvbnRlbnQ6IFwiYmxvY2tHcm91cFwiXG59KSwgcW8gPSAobikgPT4ge1xuICB2YXIgZTtcbiAgY29uc3QgdCA9IFtcbiAgICBKLkNsaXBib2FyZFRleHRTZXJpYWxpemVyLFxuICAgIEouQ29tbWFuZHMsXG4gICAgSi5FZGl0YWJsZSxcbiAgICBKLkZvY3VzRXZlbnRzLFxuICAgIEouVGFiaW5kZXgsXG4gICAgLy8gRGV2VG9vbHMsXG4gICAgSmUsXG4gICAgLy8gRHJvcEN1cnNvcixcbiAgICBEby5jb25maWd1cmUoe1xuICAgICAgLy8gVE9ETzogVGhpcyBzaG9ydGhhbmQgaXMga2luZCBvZiB1Z2x5XG4gICAgICAuLi5uLnBsYWNlaG9sZGVycyAhPT0gdm9pZCAwID8geyBwbGFjZWhvbGRlcnM6IG4ucGxhY2Vob2xkZXJzIH0gOiB7fVxuICAgIH0pLFxuICAgIFEuY29uZmlndXJlKHtcbiAgICAgIHR5cGVzOiBbXCJibG9ja0NvbnRhaW5lclwiXVxuICAgIH0pLFxuICAgIFhlLFxuICAgIC8vIENvbW1lbnRzLFxuICAgIC8vIGJhc2ljczpcbiAgICBaZSxcbiAgICAvLyBtYXJrczpcbiAgICBRZSxcbiAgICAuLi5PYmplY3QudmFsdWVzKG4uc3R5bGVTcGVjcykubWFwKChvKSA9PiBvLmltcGxlbWVudGF0aW9uLm1hcmspLFxuICAgIF9vLFxuICAgIEhvLFxuICAgIE9vLFxuICAgIC8vIG5vZGVzXG4gICAgV28sXG4gICAgR28uY29uZmlndXJlKHtcbiAgICAgIGVkaXRvcjogbi5lZGl0b3IsXG4gICAgICBkb21BdHRyaWJ1dGVzOiBuLmRvbUF0dHJpYnV0ZXNcbiAgICB9KSxcbiAgICBqby5jb25maWd1cmUoe1xuICAgICAgZG9tQXR0cmlidXRlczogbi5kb21BdHRyaWJ1dGVzXG4gICAgfSksXG4gICAgLi4uT2JqZWN0LnZhbHVlcyhuLmlubGluZUNvbnRlbnRTcGVjcykuZmlsdGVyKChvKSA9PiBvLmNvbmZpZyAhPT0gXCJsaW5rXCIgJiYgby5jb25maWcgIT09IFwidGV4dFwiKS5tYXAoKG8pID0+IG8uaW1wbGVtZW50YXRpb24ubm9kZS5jb25maWd1cmUoe1xuICAgICAgZWRpdG9yOiBuLmVkaXRvclxuICAgIH0pKSxcbiAgICAuLi5PYmplY3QudmFsdWVzKG4uYmxvY2tTcGVjcykuZmxhdE1hcCgobykgPT4gW1xuICAgICAgLy8gZGVwZW5kZW50IG5vZGVzIChlLmcuOiB0YWJsZWNlbGwgLyByb3cpXG4gICAgICAuLi4oby5pbXBsZW1lbnRhdGlvbi5yZXF1aXJlZEV4dGVuc2lvbnMgfHwgW10pLm1hcChcbiAgICAgICAgKHIpID0+IHIuY29uZmlndXJlKHtcbiAgICAgICAgICBlZGl0b3I6IG4uZWRpdG9yLFxuICAgICAgICAgIGRvbUF0dHJpYnV0ZXM6IG4uZG9tQXR0cmlidXRlc1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIC8vIHRoZSBhY3R1YWwgbm9kZSBpdHNlbGZcbiAgICAgIG8uaW1wbGVtZW50YXRpb24ubm9kZS5jb25maWd1cmUoe1xuICAgICAgICBlZGl0b3I6IG4uZWRpdG9yLFxuICAgICAgICBkb21BdHRyaWJ1dGVzOiBuLmRvbUF0dHJpYnV0ZXNcbiAgICAgIH0pXG4gICAgXSksXG4gICAgTG8obi5lZGl0b3IpLFxuICAgIEFvKG4uZWRpdG9yKSxcbiAgICBLZS5jb25maWd1cmUoeyB3aWR0aDogNSwgY29sb3I6IFwiI2RkZWVmZlwiIH0pLFxuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGxpc3QsIGJlY2F1c2UgS2V5IGV2ZW50cyAoc3VjaCBhcyBlbnRlciwgd2hlbiBzZWxlY3RpbmcgYSAvY29tbWFuZCksXG4gICAgLy8gc2hvdWxkIGJlIGhhbmRsZWQgYmVmb3JlIEVudGVyIGhhbmRsZXJzIGluIG90aGVyIGNvbXBvbmVudHMgbGlrZSBzcGxpdExpc3RJdGVtXG4gICAgVW9cbiAgXTtcbiAgaWYgKG4uY29sbGFib3JhdGlvbikge1xuICAgIGlmICh0LnB1c2goXG4gICAgICBXZS5jb25maWd1cmUoe1xuICAgICAgICBmcmFnbWVudDogbi5jb2xsYWJvcmF0aW9uLmZyYWdtZW50XG4gICAgICB9KVxuICAgICksIChlID0gbi5jb2xsYWJvcmF0aW9uLnByb3ZpZGVyKSAhPSBudWxsICYmIGUuYXdhcmVuZXNzKSB7XG4gICAgICBjb25zdCBvID0gKHIpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBpLmNsYXNzTGlzdC5hZGQoXCJjb2xsYWJvcmF0aW9uLWN1cnNvcl9fY2FyZXRcIiksIGkuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJvcmRlci1jb2xvcjogJHtyLmNvbG9yfWApO1xuICAgICAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHMuY2xhc3NMaXN0LmFkZChcImNvbGxhYm9yYXRpb24tY3Vyc29yX19sYWJlbFwiKSwgcy5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYmFja2dyb3VuZC1jb2xvcjogJHtyLmNvbG9yfWApLCBzLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyLm5hbWUpLCBudWxsKTtcbiAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwi4oGgXCIpLCBsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCLigaBcIik7XG4gICAgICAgIHJldHVybiBpLmluc2VydEJlZm9yZShhLCBudWxsKSwgaS5pbnNlcnRCZWZvcmUocywgbnVsbCksIGkuaW5zZXJ0QmVmb3JlKGwsIG51bGwpLCBpO1xuICAgICAgfTtcbiAgICAgIHQucHVzaChcbiAgICAgICAgcWUuY29uZmlndXJlKHtcbiAgICAgICAgICB1c2VyOiBuLmNvbGxhYm9yYXRpb24udXNlcixcbiAgICAgICAgICByZW5kZXI6IG4uY29sbGFib3JhdGlvbi5yZW5kZXJDdXJzb3IgfHwgbyxcbiAgICAgICAgICBwcm92aWRlcjogbi5jb2xsYWJvcmF0aW9uLnByb3ZpZGVyXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgdC5wdXNoKFllKTtcbiAgcmV0dXJuIHQ7XG59O1xuZnVuY3Rpb24gS28obiwgdCkge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiBuLmZvckVhY2goKG8sIHIsIGkpID0+IHtcbiAgICBpICE9PSB0ICYmIGUucHVzaChvKTtcbiAgfSksIHguZnJvbShlKTtcbn1cbmZ1bmN0aW9uIEpvKG4sIHQpIHtcbiAgbGV0IGUgPSB4LmZyb20obi5jb250ZW50KTtcbiAgZm9yIChsZXQgbyA9IDA7IG8gPCBlLmNoaWxkQ291bnQ7IG8rKylcbiAgICBpZiAoZS5jaGlsZChvKS50eXBlLnNwZWMuZ3JvdXAgPT09IFwiYmxvY2tDb250ZW50XCIpIHtcbiAgICAgIGNvbnN0IHIgPSBbZS5jaGlsZChvKV07XG4gICAgICBpZiAobyArIDEgPCBlLmNoaWxkQ291bnQgJiYgZS5jaGlsZChvICsgMSkudHlwZS5zcGVjLmdyb3VwID09PSBcImJsb2NrR3JvdXBcIikge1xuICAgICAgICBjb25zdCBzID0gZS5jaGlsZChvICsgMSkuY2hpbGQoMCkuY2hpbGQoMCk7XG4gICAgICAgIChzLnR5cGUubmFtZSA9PT0gXCJidWxsZXRMaXN0SXRlbVwiIHx8IHMudHlwZS5uYW1lID09PSBcIm51bWJlcmVkTGlzdEl0ZW1cIikgJiYgKHIucHVzaChlLmNoaWxkKG8gKyAxKSksIGUgPSBLbyhlLCBvICsgMSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgaSA9IHQuc3RhdGUuc2NoZW1hLm5vZGVzLmJsb2NrQ29udGFpbmVyLmNyZWF0ZShcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICByXG4gICAgICApO1xuICAgICAgZSA9IGUucmVwbGFjZUNoaWxkKG8sIGkpO1xuICAgIH1cbiAgcmV0dXJuIG5ldyBfKGUsIG4ub3BlblN0YXJ0LCBuLm9wZW5FbmQpO1xufVxuY2xhc3MgVHQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgZCh0aGlzLCBcImJsb2NrU3BlY3NcIik7XG4gICAgZCh0aGlzLCBcImlubGluZUNvbnRlbnRTcGVjc1wiKTtcbiAgICBkKHRoaXMsIFwic3R5bGVTcGVjc1wiKTtcbiAgICBkKHRoaXMsIFwiYmxvY2tTY2hlbWFcIik7XG4gICAgZCh0aGlzLCBcImlubGluZUNvbnRlbnRTY2hlbWFcIik7XG4gICAgZCh0aGlzLCBcInN0eWxlU2NoZW1hXCIpO1xuICAgIC8vIEhlbHBlciBzbyB0aGF0IHlvdSBjYW4gdXNlIHR5cGVvZiBzY2hlbWEuQmxvY2tOb3RlRWRpdG9yXG4gICAgZCh0aGlzLCBcIkJsb2NrTm90ZUVkaXRvclwiLCBcIm9ubHkgZm9yIHR5cGVzXCIpO1xuICAgIGQodGhpcywgXCJCbG9ja1wiLCBcIm9ubHkgZm9yIHR5cGVzXCIpO1xuICAgIGQodGhpcywgXCJQYXJ0aWFsQmxvY2tcIiwgXCJvbmx5IGZvciB0eXBlc1wiKTtcbiAgICB0aGlzLmJsb2NrU3BlY3MgPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC5ibG9ja1NwZWNzKSB8fCBvZSwgdGhpcy5pbmxpbmVDb250ZW50U3BlY3MgPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC5pbmxpbmVDb250ZW50U3BlY3MpIHx8IGllLCB0aGlzLnN0eWxlU3BlY3MgPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC5zdHlsZVNwZWNzKSB8fCByZSwgdGhpcy5ibG9ja1NjaGVtYSA9IFp0KHRoaXMuYmxvY2tTcGVjcyksIHRoaXMuaW5saW5lQ29udGVudFNjaGVtYSA9IHRlKFxuICAgICAgdGhpcy5pbmxpbmVDb250ZW50U3BlY3NcbiAgICApLCB0aGlzLnN0eWxlU2NoZW1hID0gbmUodGhpcy5zdHlsZVNwZWNzKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKHQpIHtcbiAgICByZXR1cm4gbmV3IFR0KHQpO1xuICB9XG59XG5jbGFzcyBYbyBleHRlbmRzIHhlIHtcbiAgY29uc3RydWN0b3IoZSwgbykge1xuICAgIHN1cGVyKHsgLi4uZSwgY29udGVudDogdm9pZCAwIH0pO1xuICAgIGQodGhpcywgXCJfc3RhdGVcIik7XG4gICAgLyoqXG4gICAgICogTW91bnRzIC8gdW5tb3VudHMgdGhlIGVkaXRvciB0byBhIGRvbSBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBET00gZWxlbWVudCB0byBtb3VudCB0bywgdXIgbnVsbCAvIHVuZGVmaW5lZCB0byBkZXN0cm95XG4gICAgICovXG4gICAgZCh0aGlzLCBcIm1vdW50XCIsIChlKSA9PiB7XG4gICAgICBlID8gKHRoaXMub3B0aW9ucy5lbGVtZW50ID0gZSwgdGhpcy5jcmVhdGVWaWV3QWx0ZXJuYXRpdmUoKSkgOiB0aGlzLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBjb25zdCByID0gdGhpcy5zY2hlbWE7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgcyA9IHIubm9kZXMuZG9jLmNyZWF0ZUFuZEZpbGw7XG4gICAgci5ub2Rlcy5kb2MuY3JlYXRlQW5kRmlsbCA9ICguLi5sKSA9PiB7XG4gICAgICBpZiAoaSlcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICBjb25zdCBjID0gcy5hcHBseShyLm5vZGVzLmRvYywgbCksIHAgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMudG9KU09OKCkpKTtcbiAgICAgIHJldHVybiBwLmNvbnRlbnRbMF0uY29udGVudFswXS5hdHRycy5pZCA9IFwiaW5pdGlhbEJsb2NrSWRcIiwgaSA9IGdlLmZyb21KU09OKHIsIHApLCBpO1xuICAgIH07XG4gICAgbGV0IGE7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGwgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmNvbnRlbnQubWFwKFxuICAgICAgICAoYykgPT4gUChjLCB0aGlzLnNjaGVtYSwgbykudG9KU09OKClcbiAgICAgICk7XG4gICAgICBhID0gTWUoXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImRvY1wiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJibG9ja0dyb3VwXCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuc2NoZW1hLFxuICAgICAgICB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiRXJyb3IgY3JlYXRpbmcgZG9jdW1lbnQgZnJvbSBibG9ja3MgcGFzc2VkIGFzIGBpbml0aWFsQ29udGVudGAuIENhdXNlZCBieSBleGNlcHRpb246IFwiLFxuICAgICAgICBsXG4gICAgICApLCBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXJyb3IgY3JlYXRpbmcgZG9jdW1lbnQgZnJvbSBibG9ja3MgcGFzc2VkIGFzIGBpbml0aWFsQ29udGVudGA6XFxuXCIgKyArSlNPTi5zdHJpbmdpZnkoZS5jb250ZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhdGUgPSBCZS5jcmVhdGUoe1xuICAgICAgZG9jOiBhLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYVxuICAgICAgLy8gc2VsZWN0aW9uOiBzZWxlY3Rpb24gfHwgdW5kZWZpbmVkLFxuICAgIH0pO1xuICB9XG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3ICYmICh0aGlzLl9zdGF0ZSA9IHRoaXMudmlldy5zdGF0ZSksIHRoaXMuX3N0YXRlO1xuICB9XG4gIGNyZWF0ZVZpZXcoKSB7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGRlZmF1bHQgYGNyZWF0ZVZpZXdgIG1ldGhvZCB3aXRoIGEgY3VzdG9tIG9uZSAtIHdoaWNoIHdlIGNhbGwgb24gbW91bnRcbiAgICovXG4gIGNyZWF0ZVZpZXdBbHRlcm5hdGl2ZSgpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICB0aGlzLnZpZXcgPSBuZXcgamUodGhpcy5vcHRpb25zLmVsZW1lbnQsIHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzLFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICAgIHBsdWdpbnM6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5wbHVnaW5zXG4gICAgICB9KTtcbiAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShlKSwgdGhpcy5jcmVhdGVOb2RlVmlld3MoKTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgWW8gPSB7XG4gIGVuYWJsZUlucHV0UnVsZXM6ICEwLFxuICBlbmFibGVQYXN0ZVJ1bGVzOiAhMCxcbiAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6ICExXG59O1xuY2xhc3MgZGUge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgZCh0aGlzLCBcIl90aXB0YXBFZGl0b3JcIik7XG4gICAgZCh0aGlzLCBcImJsb2NrQ2FjaGVcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgIGQodGhpcywgXCJzY2hlbWFcIik7XG4gICAgZCh0aGlzLCBcImJsb2NrSW1wbGVtZW50YXRpb25zXCIpO1xuICAgIGQodGhpcywgXCJpbmxpbmVDb250ZW50SW1wbGVtZW50YXRpb25zXCIpO1xuICAgIGQodGhpcywgXCJzdHlsZUltcGxlbWVudGF0aW9uc1wiKTtcbiAgICBkKHRoaXMsIFwiZm9ybWF0dGluZ1Rvb2xiYXJcIik7XG4gICAgZCh0aGlzLCBcImh5cGVybGlua1Rvb2xiYXJcIik7XG4gICAgZCh0aGlzLCBcInNpZGVNZW51XCIpO1xuICAgIGQodGhpcywgXCJzdWdnZXN0aW9uTWVudXNcIik7XG4gICAgZCh0aGlzLCBcImltYWdlVG9vbGJhclwiKTtcbiAgICBkKHRoaXMsIFwidGFibGVIYW5kbGVzXCIpO1xuICAgIGQodGhpcywgXCJ1cGxvYWRGaWxlXCIpO1xuICAgIHZhciBsLCBjLCBwLCB1LCBtLCBoLCBmLCB5O1xuICAgIHRoaXMub3B0aW9ucyA9IHQ7XG4gICAgY29uc3QgZSA9IHQ7XG4gICAgaWYgKGUub25FZGl0b3JDb250ZW50Q2hhbmdlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIm9uRWRpdG9yQ29udGVudENoYW5nZSBpbml0aWFsaXphdGlvbiBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIDxCbG9ja05vdGVWaWV3IG9uQ2hhbmdlPXsuLi59IC8+LCB0aGUgdXNlRWRpdG9yQ2hhbmdlKC4uLikgaG9vaywgb3IgZWRpdG9yLm9uQ2hhbmdlKC4uLilcIlxuICAgICAgKTtcbiAgICBpZiAoZS5vblRleHRDdXJzb3JQb3NpdGlvbkNoYW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJvblRleHRDdXJzb3JQb3NpdGlvbkNoYW5nZSBpbml0aWFsaXphdGlvbiBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIDxCbG9ja05vdGVWaWV3IG9uU2VsZWN0aW9uQ2hhbmdlPXsuLi59IC8+LCB0aGUgdXNlRWRpdG9yU2VsZWN0aW9uQ2hhbmdlKC4uLikgaG9vaywgb3IgZWRpdG9yLm9uU2VsZWN0aW9uQ2hhbmdlKC4uLilcIlxuICAgICAgKTtcbiAgICBpZiAoZS5vbkVkaXRvclJlYWR5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIm9uRWRpdG9yUmVhZHkgaXMgZGVwcmVjYXRlZC4gRWRpdG9yIGlzIGltbWVkaWF0ZWx5IHJlYWR5IGZvciB1c2UgYWZ0ZXIgY3JlYXRpb24uXCJcbiAgICAgICk7XG4gICAgaWYgKGUuZWRpdGFibGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiZWRpdGFibGUgaW5pdGlhbGl6YXRpb24gb3B0aW9uIGlzIGRlcHJlY2F0ZWQsIHVzZSA8QmxvY2tOb3RlVmlldyBlZGl0YWJsZT17dHJ1ZS9mYWxzZX0gLz4sIG9yIGFsdGVybmF0aXZlbHkgZWRpdG9yLmlzRWRpdGFibGUgPSB0cnVlL2ZhbHNlXCJcbiAgICAgICk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIGRlZmF1bHRTdHlsZXM6ICEwLFxuICAgICAgc2NoZW1hOiB0LnNjaGVtYSB8fCBUdC5jcmVhdGUoKSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHRoaXMuc2NoZW1hID0gby5zY2hlbWEsIHRoaXMuYmxvY2tJbXBsZW1lbnRhdGlvbnMgPSBvLnNjaGVtYS5ibG9ja1NwZWNzLCB0aGlzLmlubGluZUNvbnRlbnRJbXBsZW1lbnRhdGlvbnMgPSBvLnNjaGVtYS5pbmxpbmVDb250ZW50U3BlY3MsIHRoaXMuc3R5bGVJbXBsZW1lbnRhdGlvbnMgPSBvLnNjaGVtYS5zdHlsZVNwZWNzLCB0aGlzLmZvcm1hdHRpbmdUb29sYmFyID0gbmV3IGNvKHRoaXMpLCB0aGlzLmh5cGVybGlua1Rvb2xiYXIgPSBuZXcgaG8odGhpcyksIHRoaXMuc2lkZU1lbnUgPSBuZXcgQ28odGhpcyksIHRoaXMuc3VnZ2VzdGlvbk1lbnVzID0gbmV3IHlvKHRoaXMpLCBMKFwiaW1hZ2VcIiwgdGhpcykgJiYgKHRoaXMuaW1hZ2VUb29sYmFyID0gbmV3IGZvKHRoaXMpKSwgTChcInRhYmxlXCIsIHRoaXMpICYmICh0aGlzLnRhYmxlSGFuZGxlcyA9IG5ldyBJbyh0aGlzKSk7XG4gICAgY29uc3QgciA9IHFvKHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHBsYWNlaG9sZGVyczogby5wbGFjZWhvbGRlcnMsXG4gICAgICBkb21BdHRyaWJ1dGVzOiBvLmRvbUF0dHJpYnV0ZXMgfHwge30sXG4gICAgICBibG9ja1NjaGVtYTogdGhpcy5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICBibG9ja1NwZWNzOiB0aGlzLnNjaGVtYS5ibG9ja1NwZWNzLFxuICAgICAgc3R5bGVTcGVjczogdGhpcy5zY2hlbWEuc3R5bGVTcGVjcyxcbiAgICAgIGlubGluZUNvbnRlbnRTcGVjczogdGhpcy5zY2hlbWEuaW5saW5lQ29udGVudFNwZWNzLFxuICAgICAgY29sbGFib3JhdGlvbjogby5jb2xsYWJvcmF0aW9uXG4gICAgfSksIGkgPSBNLmNyZWF0ZSh7XG4gICAgICBuYW1lOiBcIkJsb2NrTm90ZVVJRXh0ZW5zaW9uXCIsXG4gICAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnM6ICgpID0+IFtcbiAgICAgICAgdGhpcy5mb3JtYXR0aW5nVG9vbGJhci5wbHVnaW4sXG4gICAgICAgIHRoaXMuaHlwZXJsaW5rVG9vbGJhci5wbHVnaW4sXG4gICAgICAgIHRoaXMuc2lkZU1lbnUucGx1Z2luLFxuICAgICAgICB0aGlzLnN1Z2dlc3Rpb25NZW51cy5wbHVnaW4sXG4gICAgICAgIC4uLnRoaXMuaW1hZ2VUb29sYmFyID8gW3RoaXMuaW1hZ2VUb29sYmFyLnBsdWdpbl0gOiBbXSxcbiAgICAgICAgLi4udGhpcy50YWJsZUhhbmRsZXMgPyBbdGhpcy50YWJsZUhhbmRsZXMucGx1Z2luXSA6IFtdXG4gICAgICBdXG4gICAgfSk7XG4gICAgci5wdXNoKGkpLCB0aGlzLnVwbG9hZEZpbGUgPSBvLnVwbG9hZEZpbGUsIG8uY29sbGFib3JhdGlvbiAmJiBvLmluaXRpYWxDb250ZW50ICYmIGNvbnNvbGUud2FybihcbiAgICAgIFwiV2hlbiB1c2luZyBDb2xsYWJvcmF0aW9uLCBpbml0aWFsQ29udGVudCBtaWdodCBjYXVzZSBjb25mbGljdHMsIGJlY2F1c2UgY2hhbmdlcyBzaG91bGQgY29tZSBmcm9tIHRoZSBjb2xsYWJvcmF0aW9uIHByb3ZpZGVyXCJcbiAgICApO1xuICAgIGNvbnN0IHMgPSBvLmluaXRpYWxDb250ZW50IHx8ICh0LmNvbGxhYm9yYXRpb24gPyBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgIGlkOiBcImluaXRpYWxCbG9ja0lkXCJcbiAgICAgIH1cbiAgICBdIDogW1xuICAgICAge1xuICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICBpZDogUS5vcHRpb25zLmdlbmVyYXRlSUQoKVxuICAgICAgfVxuICAgIF0pO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzKSB8fCBzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJpbml0aWFsQ29udGVudCBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5IG9mIGJsb2NrcywgcmVjZWl2ZWQ6IFwiICsgc1xuICAgICAgKTtcbiAgICBjb25zdCBhID0ge1xuICAgICAgLi4uWW8sXG4gICAgICAuLi5vLl90aXB0YXBPcHRpb25zLFxuICAgICAgY29udGVudDogcyxcbiAgICAgIGV4dGVuc2lvbnM6IG8uZW5hYmxlQmxvY2tOb3RlRXh0ZW5zaW9ucyA9PT0gITEgPyAoKGwgPSBvLl90aXB0YXBPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogbC5leHRlbnNpb25zKSB8fCBbXSA6IFsuLi4oKGMgPSBvLl90aXB0YXBPcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogYy5leHRlbnNpb25zKSB8fCBbXSwgLi4ucl0sXG4gICAgICBlZGl0b3JQcm9wczoge1xuICAgICAgICAuLi4ocCA9IG8uX3RpcHRhcE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBwLmVkaXRvclByb3BzLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgLi4uKG0gPSAodSA9IG8uX3RpcHRhcE9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiB1LmVkaXRvclByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogbS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIC4uLihoID0gby5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogaC5lZGl0b3IsXG4gICAgICAgICAgY2xhc3M6IFIoXG4gICAgICAgICAgICBcImJuLWVkaXRvclwiLFxuICAgICAgICAgICAgby5kZWZhdWx0U3R5bGVzID8gXCJibi1kZWZhdWx0LXN0eWxlc1wiIDogXCJcIixcbiAgICAgICAgICAgICgoeSA9IChmID0gby5kb21BdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogZi5lZGl0b3IpID09IG51bGwgPyB2b2lkIDAgOiB5LmNsYXNzKSB8fCBcIlwiXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1QYXN0ZWQ6IEpvXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3IgPSBuZXcgWG8oXG4gICAgICBhLFxuICAgICAgdGhpcy5zY2hlbWEuc3R5bGVTY2hlbWFcbiAgICApO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUodCA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBkZSh0KTtcbiAgfVxuICAvKipcbiAgICogTW91bnQgdGhlIGVkaXRvciB0byBhIHBhcmVudCBET00gZWxlbWVudC4gQ2FsbCBtb3VudCh1bmRlZmluZWQpIHRvIGNsZWFuIHVwXG4gICAqXG4gICAqIEB3YXJuaW5nIE5vdCBuZWVkZWQgZm9yIFJlYWN0LCB1c2UgQmxvY2tOb3RlVmlldyB0byB0YWtlIGNhcmUgb2YgdGhpc1xuICAgKi9cbiAgbW91bnQodCkge1xuICAgIHRoaXMuX3RpcHRhcEVkaXRvci5tb3VudCh0KTtcbiAgfVxuICBnZXQgcHJvc2VtaXJyb3JWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLl90aXB0YXBFZGl0b3IudmlldztcbiAgfVxuICBnZXQgZG9tRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuZG9tO1xuICB9XG4gIGlzRm9jdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuaGFzRm9jdXMoKTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3Iudmlldy5mb2N1cygpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCwgdXNlIGBlZGl0b3IuZG9jdW1lbnRgIGluc3RlYWRcbiAgICovXG4gIGdldCB0b3BMZXZlbEJsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy50b3BMZXZlbEJsb2NrcztcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHNuYXBzaG90IG9mIGFsbCB0b3AtbGV2ZWwgKG5vbi1uZXN0ZWQpIGJsb2NrcyBpbiB0aGUgZWRpdG9yLlxuICAgKiBAcmV0dXJucyBBIHNuYXBzaG90IG9mIGFsbCB0b3AtbGV2ZWwgKG5vbi1uZXN0ZWQpIGJsb2NrcyBpbiB0aGUgZWRpdG9yLlxuICAgKi9cbiAgZ2V0IGRvY3VtZW50KCkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5maXJzdENoaWxkLmRlc2NlbmRhbnRzKChlKSA9PiAodC5wdXNoKFxuICAgICAgayhcbiAgICAgICAgZSxcbiAgICAgICAgdGhpcy5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICAgIHRoaXMuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICAgIHRoaXMuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgICB0aGlzLmJsb2NrQ2FjaGVcbiAgICAgIClcbiAgICApLCAhMSkpLCB0O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgc25hcHNob3Qgb2YgYW4gZXhpc3RpbmcgYmxvY2sgZnJvbSB0aGUgZWRpdG9yLlxuICAgKiBAcGFyYW0gYmxvY2tJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIGJsb2NrIHRoYXQgc2hvdWxkIGJlIHJldHJpZXZlZC5cbiAgICogQHJldHVybnMgVGhlIGJsb2NrIHRoYXQgbWF0Y2hlcyB0aGUgaWRlbnRpZmllciwgb3IgYHVuZGVmaW5lZGAgaWYgbm8gbWF0Y2hpbmcgYmxvY2sgd2FzIGZvdW5kLlxuICAgKi9cbiAgZ2V0QmxvY2sodCkge1xuICAgIGNvbnN0IGUgPSB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IHQuaWQ7XG4gICAgbGV0IG87XG4gICAgcmV0dXJuIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MuZmlyc3RDaGlsZC5kZXNjZW5kYW50cygocikgPT4gdHlwZW9mIG8gPCBcInVcIiA/ICExIDogci50eXBlLm5hbWUgIT09IFwiYmxvY2tDb250YWluZXJcIiB8fCByLmF0dHJzLmlkICE9PSBlID8gITAgOiAobyA9IGsoXG4gICAgICByLFxuICAgICAgdGhpcy5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICB0aGlzLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgdGhpcy5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICB0aGlzLmJsb2NrQ2FjaGVcbiAgICApLCAhMSkpLCBvO1xuICB9XG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgYWxsIGJsb2NrcyBpbiB0aGUgZWRpdG9yIGRlcHRoLWZpcnN0LCBhbmQgZXhlY3V0ZXMgYSBjYWxsYmFjayBmb3IgZWFjaC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGZvciBlYWNoIGJsb2NrLiBSZXR1cm5pbmcgYGZhbHNlYCBzdG9wcyB0aGUgdHJhdmVyc2FsLlxuICAgKiBAcGFyYW0gcmV2ZXJzZSBXaGV0aGVyIHRoZSBibG9ja3Mgc2hvdWxkIGJlIHRyYXZlcnNlZCBpbiByZXZlcnNlIG9yZGVyLlxuICAgKi9cbiAgZm9yRWFjaEJsb2NrKHQsIGUgPSAhMSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmRvY3VtZW50LnNsaWNlKCk7XG4gICAgZSAmJiBvLnJldmVyc2UoKTtcbiAgICBmdW5jdGlvbiByKGkpIHtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBpKSB7XG4gICAgICAgIGlmICghdChzKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGNvbnN0IGEgPSBlID8gcy5jaGlsZHJlbi5zbGljZSgpLnJldmVyc2UoKSA6IHMuY2hpbGRyZW47XG4gICAgICAgIGlmICghcihhKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHIobyk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgd2hlbmV2ZXIgdGhlIGVkaXRvcidzIGNvbnRlbnRzIGNoYW5nZS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLlxuICAgKi9cbiAgb25FZGl0b3JDb250ZW50Q2hhbmdlKHQpIHtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3Iub24oXCJ1cGRhdGVcIiwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgd2hlbmV2ZXIgdGhlIGVkaXRvcidzIHNlbGVjdGlvbiBjaGFuZ2VzLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUuXG4gICAqL1xuICBvbkVkaXRvclNlbGVjdGlvbkNoYW5nZSh0KSB7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIHQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgdGV4dCBjdXJzb3IgcG9zaXRpb24uXG4gICAqIEByZXR1cm5zIEEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgdGV4dCBjdXJzb3IgcG9zaXRpb24uXG4gICAqL1xuICBnZXRUZXh0Q3Vyc29yUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBub2RlOiB0LCBkZXB0aDogZSwgc3RhcnRQb3M6IG8sIGVuZFBvczogciB9ID0gYihcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MsXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb21cbiAgICApLCBpID0gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKHIpLmluZGV4KGUgLSAxKSwgcyA9IHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShyICsgMSkubm9kZSgpLmNoaWxkQ291bnQ7XG4gICAgbGV0IGE7XG4gICAgaSA+IDAgJiYgKGEgPSB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUobyAtIDIpLm5vZGUoKSk7XG4gICAgbGV0IGw7XG4gICAgcmV0dXJuIGkgPCBzIC0gMSAmJiAobCA9IHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZShyICsgMikubm9kZSgpKSwge1xuICAgICAgYmxvY2s6IGsoXG4gICAgICAgIHQsXG4gICAgICAgIHRoaXMuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgICB0aGlzLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgICB0aGlzLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgICAgdGhpcy5ibG9ja0NhY2hlXG4gICAgICApLFxuICAgICAgcHJldkJsb2NrOiBhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBrKFxuICAgICAgICBhLFxuICAgICAgICB0aGlzLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgICAgdGhpcy5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgdGhpcy5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgIHRoaXMuYmxvY2tDYWNoZVxuICAgICAgKSxcbiAgICAgIG5leHRCbG9jazogbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogayhcbiAgICAgICAgbCxcbiAgICAgICAgdGhpcy5zY2hlbWEuYmxvY2tTY2hlbWEsXG4gICAgICAgIHRoaXMuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICAgIHRoaXMuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgICB0aGlzLmJsb2NrQ2FjaGVcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGN1cnNvciBwb3NpdGlvbiB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIGFuIGV4aXN0aW5nIGJsb2NrLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHRhcmdldCBibG9jayBjb3VsZFxuICAgKiBub3QgYmUgZm91bmQuXG4gICAqIEBwYXJhbSB0YXJnZXRCbG9jayBUaGUgaWRlbnRpZmllciBvZiBhbiBleGlzdGluZyBibG9jayB0aGF0IHRoZSB0ZXh0IGN1cnNvciBzaG91bGQgYmUgbW92ZWQgdG8uXG4gICAqIEBwYXJhbSBwbGFjZW1lbnQgV2hldGhlciB0aGUgdGV4dCBjdXJzb3Igc2hvdWxkIGJlIHBsYWNlZCBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBibG9jay5cbiAgICovXG4gIHNldFRleHRDdXJzb3JQb3NpdGlvbih0LCBlID0gXCJzdGFydFwiKSB7XG4gICAgY29uc3QgbyA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0IDogdC5pZCwgeyBwb3NCZWZvcmVOb2RlOiByIH0gPSBFdChvLCB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jKSwgeyBzdGFydFBvczogaSwgY29udGVudE5vZGU6IHMgfSA9IGIoXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLFxuICAgICAgciArIDJcbiAgICApLCBhID0gdGhpcy5zY2hlbWEuYmxvY2tTY2hlbWFbcy50eXBlLm5hbWVdLmNvbnRlbnQ7XG4gICAgaWYgKGEgPT09IFwibm9uZVwiKSB7XG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuc2V0Tm9kZVNlbGVjdGlvbihpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGEgPT09IFwiaW5saW5lXCIpXG4gICAgICBlID09PSBcInN0YXJ0XCIgPyB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuc2V0VGV4dFNlbGVjdGlvbihpICsgMSkgOiB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuc2V0VGV4dFNlbGVjdGlvbihcbiAgICAgICAgaSArIHMubm9kZVNpemUgLSAxXG4gICAgICApO1xuICAgIGVsc2UgaWYgKGEgPT09IFwidGFibGVcIilcbiAgICAgIGUgPT09IFwic3RhcnRcIiA/IHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKGkgKyA0KSA6IHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRUZXh0U2VsZWN0aW9uKFxuICAgICAgICBpICsgcy5ub2RlU2l6ZSAtIDRcbiAgICAgICk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IE4oYSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBzbmFwc2hvdCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAqL1xuICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA9PT0gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi50byB8fCBcIm5vZGVcIiBpbiB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5kZXNjZW5kYW50cygoZSwgbykgPT4gZS50eXBlLnNwZWMuZ3JvdXAgIT09IFwiYmxvY2tDb250ZW50XCIgfHwgbyArIGUubm9kZVNpemUgPCB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb20gfHwgbyA+IHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24udG8gPyAhMCA6ICh0LnB1c2goXG4gICAgICBrKFxuICAgICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUobykubm9kZSgpLFxuICAgICAgICB0aGlzLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgICAgdGhpcy5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgdGhpcy5zY2hlbWEuc3R5bGVTY2hlbWEsXG4gICAgICAgIHRoaXMuYmxvY2tDYWNoZVxuICAgICAgKVxuICAgICksICExKSksIHsgYmxvY2tzOiB0IH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZWRpdG9yIGlzIGN1cnJlbnRseSBlZGl0YWJsZSwgb3IgaWYgaXQncyBsb2NrZWQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGVkaXRvciBpcyBlZGl0YWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZ2V0IGlzRWRpdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpcHRhcEVkaXRvci5pc0VkaXRhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyB0aGUgZWRpdG9yIGVkaXRhYmxlIG9yIGxvY2tzIGl0LCBkZXBlbmRpbmcgb24gdGhlIGFyZ3VtZW50IHBhc3NlZC5cbiAgICogQHBhcmFtIGVkaXRhYmxlIFRydWUgdG8gbWFrZSB0aGUgZWRpdG9yIGVkaXRhYmxlLCBvciBmYWxzZSB0byBsb2NrIGl0LlxuICAgKi9cbiAgc2V0IGlzRWRpdGFibGUodCkge1xuICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zZXRFZGl0YWJsZSh0KTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgYmxvY2tzIGludG8gdGhlIGVkaXRvci4gSWYgYSBibG9jaydzIGBpZGAgaXMgdW5kZWZpbmVkLCBCbG9ja05vdGUgZ2VuZXJhdGVzIG9uZSBhdXRvbWF0aWNhbGx5LiBUaHJvd3MgYW5cbiAgICogZXJyb3IgaWYgdGhlIHJlZmVyZW5jZSBibG9jayBjb3VsZCBub3QgYmUgZm91bmQuXG4gICAqIEBwYXJhbSBibG9ja3NUb0luc2VydCBBbiBhcnJheSBvZiBwYXJ0aWFsIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICogQHBhcmFtIHJlZmVyZW5jZUJsb2NrIEFuIGlkZW50aWZpZXIgZm9yIGFuIGV4aXN0aW5nIGJsb2NrLCBhdCB3aGljaCB0aGUgbmV3IGJsb2NrcyBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAqIEBwYXJhbSBwbGFjZW1lbnQgV2hldGhlciB0aGUgYmxvY2tzIHNob3VsZCBiZSBpbnNlcnRlZCBqdXN0IGJlZm9yZSwganVzdCBhZnRlciwgb3IgbmVzdGVkIGluc2lkZSB0aGVcbiAgICogYHJlZmVyZW5jZUJsb2NrYC4gSW5zZXJ0cyB0aGUgYmxvY2tzIGF0IHRoZSBzdGFydCBvZiB0aGUgZXhpc3RpbmcgYmxvY2sncyBjaGlsZHJlbiBpZiBcIm5lc3RlZFwiIGlzIHVzZWQuXG4gICAqL1xuICBpbnNlcnRCbG9ja3ModCwgZSwgbyA9IFwiYmVmb3JlXCIpIHtcbiAgICByZXR1cm4gcW4odCwgZSwgbywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgYmxvY2sgaW4gdGhlIGVkaXRvci4gU2luY2UgdXBkYXRlZEJsb2NrIGlzIGEgUGFydGlhbEJsb2NrIG9iamVjdCwgc29tZSBmaWVsZHMgbWlnaHQgbm90IGJlXG4gICAqIGRlZmluZWQuIFRoZXNlIHVuZGVmaW5lZCBmaWVsZHMgYXJlIGtlcHQgYXMtaXMgZnJvbSB0aGUgZXhpc3RpbmcgYmxvY2suIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYmxvY2sgdG8gdXBkYXRlIGNvdWxkXG4gICAqIG5vdCBiZSBmb3VuZC5cbiAgICogQHBhcmFtIGJsb2NrVG9VcGRhdGUgVGhlIGJsb2NrIHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB1cGRhdGUgQSBwYXJ0aWFsIGJsb2NrIHdoaWNoIGRlZmluZXMgaG93IHRoZSBleGlzdGluZyBibG9jayBzaG91bGQgYmUgY2hhbmdlZC5cbiAgICovXG4gIHVwZGF0ZUJsb2NrKHQsIGUpIHtcbiAgICByZXR1cm4gS24odCwgZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgZXhpc3RpbmcgYmxvY2tzIGZyb20gdGhlIGVkaXRvci4gVGhyb3dzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgYmxvY2tzIGNvdWxkIG5vdCBiZSBmb3VuZC5cbiAgICogQHBhcmFtIGJsb2Nrc1RvUmVtb3ZlIEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIGZvciBleGlzdGluZyBibG9ja3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUJsb2Nrcyh0KSB7XG4gICAgcmV0dXJuIEpuKHQsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyBleGlzdGluZyBibG9ja3MgaW4gdGhlIGVkaXRvciB3aXRoIG5ldyBibG9ja3MuIElmIHRoZSBibG9ja3MgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCBhcmUgbm90IGFkamFjZW50IG9yXG4gICAqIGFyZSBhdCBkaWZmZXJlbnQgbmVzdGluZyBsZXZlbHMsIGBibG9ja3NUb0luc2VydGAgd2lsbCBiZSBpbnNlcnRlZCBhdCB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGJsb2NrIGluXG4gICAqIGBibG9ja3NUb1JlbW92ZWAuIFRocm93cyBhbiBlcnJvciBpZiBhbnkgb2YgdGhlIGJsb2NrcyB0byByZW1vdmUgY291bGQgbm90IGJlIGZvdW5kLlxuICAgKiBAcGFyYW0gYmxvY2tzVG9SZW1vdmUgQW4gYXJyYXkgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0gYmxvY2tzVG9JbnNlcnQgQW4gYXJyYXkgb2YgcGFydGlhbCBibG9ja3MgdG8gcmVwbGFjZSB0aGUgb2xkIG9uZXMgd2l0aC5cbiAgICovXG4gIHJlcGxhY2VCbG9ja3ModCwgZSkge1xuICAgIHJldHVybiBYbih0LCBlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgcGllY2Ugb2YgY29udGVudCBhdCB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50IGNhbiBiZSBhIHN0cmluZywgb3IgYXJyYXkgb2YgcGFydGlhbCBpbmxpbmUgY29udGVudCBlbGVtZW50c1xuICAgKi9cbiAgaW5zZXJ0SW5saW5lQ29udGVudCh0KSB7XG4gICAgY29uc3QgZSA9IHN0KFxuICAgICAgdCxcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zY2hlbWEsXG4gICAgICB0aGlzLnNjaGVtYS5zdHlsZVNjaGVtYVxuICAgICk7XG4gICAgWW4oXG4gICAgICB7XG4gICAgICAgIGZyb206IHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSxcbiAgICAgICAgdG86IHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5zZWxlY3Rpb24udG9cbiAgICAgIH0sXG4gICAgICBlLFxuICAgICAgdGhpc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFjdGl2ZSB0ZXh0IHN0eWxlcyBhdCB0aGUgdGV4dCBjdXJzb3IgcG9zaXRpb24gb3IgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaWYgaXQncyBhY3RpdmUuXG4gICAqL1xuICBnZXRBY3RpdmVTdHlsZXMoKSB7XG4gICAgY29uc3QgdCA9IHt9LCBlID0gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi4kdG8ubWFya3MoKTtcbiAgICBmb3IgKGNvbnN0IG8gb2YgZSkge1xuICAgICAgY29uc3QgciA9IHRoaXMuc2NoZW1hLnN0eWxlU2NoZW1hW28udHlwZS5uYW1lXTtcbiAgICAgIGlmICghcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJtYXJrIG5vdCBmb3VuZCBpbiBzdHlsZXNjaGVtYVwiLCBvLnR5cGUubmFtZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgci5wcm9wU2NoZW1hID09PSBcImJvb2xlYW5cIiA/IHRbci50eXBlXSA9ICEwIDogdFtyLnR5cGVdID0gby5hdHRycy5zdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgc3R5bGVzIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29udGVudC5cbiAgICogQHBhcmFtIHN0eWxlcyBUaGUgc3R5bGVzIHRvIGFkZC5cbiAgICovXG4gIGFkZFN0eWxlcyh0KSB7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuZm9jdXMoKTtcbiAgICBmb3IgKGNvbnN0IFtlLCBvXSBvZiBPYmplY3QuZW50cmllcyh0KSkge1xuICAgICAgY29uc3QgciA9IHRoaXMuc2NoZW1hLnN0eWxlU2NoZW1hW2VdO1xuICAgICAgaWYgKCFyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0eWxlICR7ZX0gbm90IGZvdW5kIGluIHN0eWxlU2NoZW1hYCk7XG4gICAgICBpZiAoci5wcm9wU2NoZW1hID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLnNldE1hcmsoZSk7XG4gICAgICBlbHNlIGlmIChyLnByb3BTY2hlbWEgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy5zZXRNYXJrKGUsIHsgc3RyaW5nVmFsdWU6IG8gfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBOKHIucHJvcFNjaGVtYSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHN0eWxlcyBmcm9tIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29udGVudC5cbiAgICogQHBhcmFtIHN0eWxlcyBUaGUgc3R5bGVzIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZVN0eWxlcyh0KSB7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuZm9jdXMoKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgT2JqZWN0LmtleXModCkpXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMudW5zZXRNYXJrKGUpO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIHN0eWxlcyBvbiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbnRlbnQuXG4gICAqIEBwYXJhbSBzdHlsZXMgVGhlIHN0eWxlcyB0byB0b2dnbGUuXG4gICAqL1xuICB0b2dnbGVTdHlsZXModCkge1xuICAgIHRoaXMuX3RpcHRhcEVkaXRvci52aWV3LmZvY3VzKCk7XG4gICAgZm9yIChjb25zdCBbZSwgb10gb2YgT2JqZWN0LmVudHJpZXModCkpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLnNjaGVtYS5zdHlsZVNjaGVtYVtlXTtcbiAgICAgIGlmICghcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHlsZSAke2V9IG5vdCBmb3VuZCBpbiBzdHlsZVNjaGVtYWApO1xuICAgICAgaWYgKHIucHJvcFNjaGVtYSA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5jb21tYW5kcy50b2dnbGVNYXJrKGUpO1xuICAgICAgZWxzZSBpZiAoci5wcm9wU2NoZW1hID09PSBcInN0cmluZ1wiKVxuICAgICAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMudG9nZ2xlTWFyayhlLCB7IHN0cmluZ1ZhbHVlOiBvIH0pO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgTihyLnByb3BTY2hlbWEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQuXG4gICAqL1xuICBnZXRTZWxlY3RlZFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MudGV4dEJldHdlZW4oXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb20sXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLnRvXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgVVJMIG9mIHRoZSBsYXN0IGxpbmsgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBhcmUgbm8gbGlua3MgaW4gdGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIGdldFNlbGVjdGVkTGlua1VybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLmdldEF0dHJpYnV0ZXMoXCJsaW5rXCIpLmhyZWY7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbGluayB0byByZXBsYWNlIHRoZSBzZWxlY3RlZCBjb250ZW50LlxuICAgKiBAcGFyYW0gdXJsIFRoZSBsaW5rIFVSTC5cbiAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gZGlzcGxheSB0aGUgbGluayB3aXRoLlxuICAgKi9cbiAgY3JlYXRlTGluayh0LCBlKSB7XG4gICAgaWYgKHQgPT09IFwiXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBmcm9tOiBvLCB0bzogciB9ID0gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICBlIHx8IChlID0gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy50ZXh0QmV0d2VlbihvLCByKSk7XG4gICAgY29uc3QgaSA9IHRoaXMuX3RpcHRhcEVkaXRvci5zY2hlbWEubWFyayhcImxpbmtcIiwgeyBocmVmOiB0IH0pO1xuICAgIHRoaXMuX3RpcHRhcEVkaXRvci52aWV3LmRpc3BhdGNoKFxuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLnZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dChlLCBvLCByKS5hZGRNYXJrKG8sIG8gKyBlLmxlbmd0aCwgaSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGJsb2NrIGNvbnRhaW5pbmcgdGhlIHRleHQgY3Vyc29yIGNhbiBiZSBuZXN0ZWQuXG4gICAqL1xuICBjYW5OZXN0QmxvY2soKSB7XG4gICAgY29uc3QgeyBzdGFydFBvczogdCwgZGVwdGg6IGUgfSA9IGIoXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuZG9jLFxuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLnNlbGVjdGlvbi5mcm9tXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKHQpLmluZGV4KGUgLSAxKSA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIE5lc3RzIHRoZSBibG9jayBjb250YWluaW5nIHRoZSB0ZXh0IGN1cnNvciBpbnRvIHRoZSBibG9jayBhYm92ZSBpdC5cbiAgICovXG4gIG5lc3RCbG9jaygpIHtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKFwiYmxvY2tDb250YWluZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgYmxvY2sgY29udGFpbmluZyB0aGUgdGV4dCBjdXJzb3IgaXMgbmVzdGVkLlxuICAgKi9cbiAgY2FuVW5uZXN0QmxvY2soKSB7XG4gICAgY29uc3QgeyBkZXB0aDogdCB9ID0gYihcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zdGF0ZS5kb2MsXG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmZyb21cbiAgICApO1xuICAgIHJldHVybiB0ID4gMjtcbiAgfVxuICAvKipcbiAgICogTGlmdHMgdGhlIGJsb2NrIGNvbnRhaW5pbmcgdGhlIHRleHQgY3Vyc29yIG91dCBvZiBpdHMgcGFyZW50LlxuICAgKi9cbiAgdW5uZXN0QmxvY2soKSB7XG4gICAgdGhpcy5fdGlwdGFwRWRpdG9yLmNvbW1hbmRzLmxpZnRMaXN0SXRlbShcImJsb2NrQ29udGFpbmVyXCIpO1xuICB9XG4gIC8vIFRPRE86IEZpeCB3aGVuIGltcGxlbWVudGluZyBIVE1ML01hcmtkb3duIGltcG9ydCAmIGV4cG9ydFxuICAvKipcbiAgICogU2VyaWFsaXplcyBibG9ja3MgaW50byBhbiBIVE1MIHN0cmluZy4gVG8gYmV0dGVyIGNvbmZvcm0gdG8gSFRNTCBzdGFuZGFyZHMsIGNoaWxkcmVuIG9mIGJsb2NrcyB3aGljaCBhcmVuJ3QgbGlzdFxuICAgKiBpdGVtcyBhcmUgdW4tbmVzdGVkIGluIHRoZSBvdXRwdXQgSFRNTC5cbiAgICogQHBhcmFtIGJsb2NrcyBBbiBhcnJheSBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZCBpbnRvIEhUTUwuXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MsIHNlcmlhbGl6ZWQgYXMgYW4gSFRNTCBzdHJpbmcuXG4gICAqL1xuICBhc3luYyBibG9ja3NUb0hUTUxMb3NzeSh0ID0gdGhpcy5kb2N1bWVudCkge1xuICAgIHJldHVybiBhdChcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zY2hlbWEsXG4gICAgICB0aGlzXG4gICAgKS5leHBvcnRCbG9ja3ModCk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBibG9ja3MgZnJvbSBhbiBIVE1MIHN0cmluZy4gVHJpZXMgdG8gY3JlYXRlIGBCbG9ja2Agb2JqZWN0cyBvdXQgb2YgYW55IEhUTUwgYmxvY2stbGV2ZWwgZWxlbWVudHMsIGFuZFxuICAgKiBgSW5saW5lTm9kZWAgb2JqZWN0cyBmcm9tIGFueSBIVE1MIGlubGluZSBlbGVtZW50cywgdGhvdWdoIG5vdCBhbGwgZWxlbWVudCB0eXBlcyBhcmUgcmVjb2duaXplZC4gSWYgQmxvY2tOb3RlXG4gICAqIGRvZXNuJ3QgcmVjb2duaXplIGFuIEhUTUwgZWxlbWVudCdzIHRhZywgaXQgd2lsbCBwYXJzZSBpdCBhcyBhIHBhcmFncmFwaCBvciBwbGFpbiB0ZXh0LlxuICAgKiBAcGFyYW0gaHRtbCBUaGUgSFRNTCBzdHJpbmcgdG8gcGFyc2UgYmxvY2tzIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MgcGFyc2VkIGZyb20gdGhlIEhUTUwgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgdHJ5UGFyc2VIVE1MVG9CbG9ja3ModCkge1xuICAgIHJldHVybiBsZShcbiAgICAgIHQsXG4gICAgICB0aGlzLnNjaGVtYS5ibG9ja1NjaGVtYSxcbiAgICAgIHRoaXMuc2NoZW1hLmlubGluZUNvbnRlbnRTY2hlbWEsXG4gICAgICB0aGlzLnNjaGVtYS5zdHlsZVNjaGVtYSxcbiAgICAgIHRoaXMuX3RpcHRhcEVkaXRvci5zY2hlbWFcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGJsb2NrcyBpbnRvIGEgTWFya2Rvd24gc3RyaW5nLiBUaGUgb3V0cHV0IGlzIHNpbXBsaWZpZWQgYXMgTWFya2Rvd24gZG9lcyBub3Qgc3VwcG9ydCBhbGwgZmVhdHVyZXMgb2ZcbiAgICogQmxvY2tOb3RlIC0gY2hpbGRyZW4gb2YgYmxvY2tzIHdoaWNoIGFyZW4ndCBsaXN0IGl0ZW1zIGFyZSB1bi1uZXN0ZWQgYW5kIGNlcnRhaW4gc3R5bGVzIGFyZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gYmxvY2tzIEFuIGFycmF5IG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBzZXJpYWxpemVkIGludG8gTWFya2Rvd24uXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MsIHNlcmlhbGl6ZWQgYXMgYSBNYXJrZG93biBzdHJpbmcuXG4gICAqL1xuICBhc3luYyBibG9ja3NUb01hcmtkb3duTG9zc3kodCA9IHRoaXMuZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gWm4odCwgdGhpcy5fdGlwdGFwRWRpdG9yLnNjaGVtYSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsaXN0IG9mIGJsb2NrcyBmcm9tIGEgTWFya2Rvd24gc3RyaW5nLiBUcmllcyB0byBjcmVhdGUgYEJsb2NrYCBhbmQgYElubGluZU5vZGVgIG9iamVjdHMgYmFzZWQgb25cbiAgICogTWFya2Rvd24gc3ludGF4LCB0aG91Z2ggbm90IGFsbCBzeW1ib2xzIGFyZSByZWNvZ25pemVkLiBJZiBCbG9ja05vdGUgZG9lc24ndCByZWNvZ25pemUgYSBzeW1ib2wsIGl0IHdpbGwgcGFyc2UgaXRcbiAgICogYXMgdGV4dC5cbiAgICogQHBhcmFtIG1hcmtkb3duIFRoZSBNYXJrZG93biBzdHJpbmcgdG8gcGFyc2UgYmxvY2tzIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBibG9ja3MgcGFyc2VkIGZyb20gdGhlIE1hcmtkb3duIHN0cmluZy5cbiAgICovXG4gIGFzeW5jIHRyeVBhcnNlTWFya2Rvd25Ub0Jsb2Nrcyh0KSB7XG4gICAgcmV0dXJuIHNvKFxuICAgICAgdCxcbiAgICAgIHRoaXMuc2NoZW1hLmJsb2NrU2NoZW1hLFxuICAgICAgdGhpcy5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgIHRoaXMuc2NoZW1hLnN0eWxlU2NoZW1hLFxuICAgICAgdGhpcy5fdGlwdGFwRWRpdG9yLnNjaGVtYVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgaW5mbyBmb3IgdGhlIGN1cnJlbnQgdXNlciB0aGF0J3Mgc2hvd24gdG8gb3RoZXIgY29sbGFib3JhdG9ycy5cbiAgICovXG4gIHVwZGF0ZUNvbGxhYm9yYXRpb25Vc2VySW5mbyh0KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY29sbGFib3JhdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDYW5ub3QgdXBkYXRlIGNvbGxhYm9yYXRpb24gdXNlciBpbmZvIHdoZW4gY29sbGFib3JhdGlvbiBpcyBkaXNhYmxlZC5cIlxuICAgICAgKTtcbiAgICB0aGlzLl90aXB0YXBFZGl0b3IuY29tbWFuZHMudXBkYXRlVXNlcih0KTtcbiAgfVxuICAvKipcbiAgICogQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJ1bnMgd2hlbmV2ZXIgdGhlIGVkaXRvcidzIGNvbnRlbnRzIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLlxuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvbkNoYW5nZSh0KSB7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHQodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLm9uKFwidXBkYXRlXCIsIGUpLCAoKSA9PiB7XG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iub2ZmKFwidXBkYXRlXCIsIGUpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBydW5zIHdoZW5ldmVyIHRoZSB0ZXh0IGN1cnNvciBwb3NpdGlvbiBvciBzZWxlY3Rpb24gY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLlxuICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBvblNlbGVjdGlvbkNoYW5nZSh0KSB7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHQodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fdGlwdGFwRWRpdG9yLm9uKFwic2VsZWN0aW9uVXBkYXRlXCIsIGUpLCAoKSA9PiB7XG4gICAgICB0aGlzLl90aXB0YXBFZGl0b3Iub2ZmKFwic2VsZWN0aW9uVXBkYXRlXCIsIGUpO1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIFFvKG4pIHtcbiAgbGV0IHQgPSBuLmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrLCBlID0gbi5zY2hlbWEuYmxvY2tTY2hlbWFbdC50eXBlXS5jb250ZW50O1xuICBmb3IgKDsgZSA9PT0gXCJub25lXCI7IClcbiAgICB0ID0gbi5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5uZXh0QmxvY2ssIGUgPSBuLnNjaGVtYS5ibG9ja1NjaGVtYVt0LnR5cGVdLmNvbnRlbnQsIG4uc2V0VGV4dEN1cnNvclBvc2l0aW9uKHQsIFwiZW5kXCIpO1xufVxuZnVuY3Rpb24gQShuLCB0KSB7XG4gIGNvbnN0IGUgPSBuLmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrO1xuICBpZiAoZS5jb250ZW50ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2xhc2ggTWVudSBvcGVuIGluIGEgYmxvY2sgdGhhdCBkb2Vzbid0IGNvbnRhaW4gY29udGVudC5cIik7XG4gIEFycmF5LmlzQXJyYXkoZS5jb250ZW50KSAmJiAoZS5jb250ZW50Lmxlbmd0aCA9PT0gMSAmJiBZKGUuY29udGVudFswXSkgJiYgZS5jb250ZW50WzBdLnR5cGUgPT09IFwidGV4dFwiICYmIGUuY29udGVudFswXS50ZXh0ID09PSBcIi9cIiB8fCBlLmNvbnRlbnQubGVuZ3RoID09PSAwKSA/IG4udXBkYXRlQmxvY2soZSwgdCkgOiAobi5pbnNlcnRCbG9ja3MoW3RdLCBlLCBcImFmdGVyXCIpLCBuLnNldFRleHRDdXJzb3JQb3NpdGlvbihcbiAgICBuLmdldFRleHRDdXJzb3JQb3NpdGlvbigpLm5leHRCbG9jayxcbiAgICBcImVuZFwiXG4gICkpO1xuICBjb25zdCBvID0gbi5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jaztcbiAgcmV0dXJuIFFvKG4pLCBvO1xufVxuZnVuY3Rpb24gRnIobikge1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiBMKFwiaGVhZGluZ1wiLCBuKSAmJiB0LnB1c2goXG4gICAge1xuICAgICAgdGl0bGU6IFwiSGVhZGluZyAxXCIsXG4gICAgICBvbkl0ZW1DbGljazogKCkgPT4ge1xuICAgICAgICBBKG4sIHtcbiAgICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgICBwcm9wczogeyBsZXZlbDogMSB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHN1YnRleHQ6IFwiVXNlZCBmb3IgYSB0b3AtbGV2ZWwgaGVhZGluZ1wiLFxuICAgICAgYmFkZ2U6IFYoXCJNb2QtQWx0LTFcIiksXG4gICAgICBhbGlhc2VzOiBbXCJoXCIsIFwiaGVhZGluZzFcIiwgXCJoMVwiXSxcbiAgICAgIGdyb3VwOiBcIkhlYWRpbmdzXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiBcIkhlYWRpbmcgMlwiLFxuICAgICAgb25JdGVtQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgQShuLCB7XG4gICAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgICAgcHJvcHM6IHsgbGV2ZWw6IDIgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzdWJ0ZXh0OiBcIlVzZWQgZm9yIGtleSBzZWN0aW9uc1wiLFxuICAgICAgYmFkZ2U6IFYoXCJNb2QtQWx0LTJcIiksXG4gICAgICBhbGlhc2VzOiBbXCJoMlwiLCBcImhlYWRpbmcyXCIsIFwic3ViaGVhZGluZ1wiXSxcbiAgICAgIGdyb3VwOiBcIkhlYWRpbmdzXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiBcIkhlYWRpbmcgM1wiLFxuICAgICAgb25JdGVtQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgQShuLCB7XG4gICAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgICAgcHJvcHM6IHsgbGV2ZWw6IDMgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzdWJ0ZXh0OiBcIlVzZWQgZm9yIHN1YnNlY3Rpb25zIGFuZCBncm91cCBoZWFkaW5nc1wiLFxuICAgICAgYmFkZ2U6IFYoXCJNb2QtQWx0LTNcIiksXG4gICAgICBhbGlhc2VzOiBbXCJoM1wiLCBcImhlYWRpbmczXCIsIFwic3ViaGVhZGluZ1wiXSxcbiAgICAgIGdyb3VwOiBcIkhlYWRpbmdzXCJcbiAgICB9XG4gICksIEwoXCJudW1iZXJlZExpc3RJdGVtXCIsIG4pICYmIHQucHVzaCh7XG4gICAgdGl0bGU6IFwiTnVtYmVyZWQgTGlzdFwiLFxuICAgIG9uSXRlbUNsaWNrOiAoKSA9PiB7XG4gICAgICBBKG4sIHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJlZExpc3RJdGVtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc3VidGV4dDogXCJVc2VkIHRvIGRpc3BsYXkgYSBudW1iZXJlZCBsaXN0XCIsXG4gICAgYmFkZ2U6IFYoXCJNb2QtU2hpZnQtN1wiKSxcbiAgICBhbGlhc2VzOiBbXCJvbFwiLCBcImxpXCIsIFwibGlzdFwiLCBcIm51bWJlcmVkbGlzdFwiLCBcIm51bWJlcmVkIGxpc3RcIl0sXG4gICAgZ3JvdXA6IFwiQmFzaWMgYmxvY2tzXCJcbiAgfSksIEwoXCJidWxsZXRMaXN0SXRlbVwiLCBuKSAmJiB0LnB1c2goe1xuICAgIHRpdGxlOiBcIkJ1bGxldCBMaXN0XCIsXG4gICAgb25JdGVtQ2xpY2s6ICgpID0+IHtcbiAgICAgIEEobiwge1xuICAgICAgICB0eXBlOiBcImJ1bGxldExpc3RJdGVtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc3VidGV4dDogXCJVc2VkIHRvIGRpc3BsYXkgYW4gdW5vcmRlcmVkIGxpc3RcIixcbiAgICBiYWRnZTogVihcIk1vZC1TaGlmdC04XCIpLFxuICAgIGFsaWFzZXM6IFtcInVsXCIsIFwibGlcIiwgXCJsaXN0XCIsIFwiYnVsbGV0bGlzdFwiLCBcImJ1bGxldCBsaXN0XCJdLFxuICAgIGdyb3VwOiBcIkJhc2ljIGJsb2Nrc1wiXG4gIH0pLCBMKFwicGFyYWdyYXBoXCIsIG4pICYmIHQucHVzaCh7XG4gICAgdGl0bGU6IFwiUGFyYWdyYXBoXCIsXG4gICAgb25JdGVtQ2xpY2s6ICgpID0+IHtcbiAgICAgIEEobiwge1xuICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHN1YnRleHQ6IFwiVXNlZCBmb3IgdGhlIGJvZHkgb2YgeW91ciBkb2N1bWVudFwiLFxuICAgIGJhZGdlOiBWKFwiTW9kLUFsdC0wXCIpLFxuICAgIGFsaWFzZXM6IFtcInBcIiwgXCJwYXJhZ3JhcGhcIl0sXG4gICAgZ3JvdXA6IFwiQmFzaWMgYmxvY2tzXCJcbiAgfSksIEwoXCJ0YWJsZVwiLCBuKSAmJiB0LnB1c2goe1xuICAgIHRpdGxlOiBcIlRhYmxlXCIsXG4gICAgb25JdGVtQ2xpY2s6ICgpID0+IHtcbiAgICAgIEEobiwge1xuICAgICAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInRhYmxlQ29udGVudFwiLFxuICAgICAgICAgIHJvd3M6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2VsbHM6IFtcIlwiLCBcIlwiLCBcIlwiXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2VsbHM6IFtcIlwiLCBcIlwiLCBcIlwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzdWJ0ZXh0OiBcIlVzZWQgZm9yIGZvciB0YWJsZXNcIixcbiAgICBhbGlhc2VzOiBbXCJ0YWJsZVwiXSxcbiAgICBncm91cDogXCJBZHZhbmNlZFwiLFxuICAgIGJhZGdlOiB2b2lkIDBcbiAgfSksIEwoXCJpbWFnZVwiLCBuKSAmJiB0LnB1c2goe1xuICAgIHRpdGxlOiBcIkltYWdlXCIsXG4gICAgb25JdGVtQ2xpY2s6ICgpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBBKG4sIHtcbiAgICAgICAgdHlwZTogXCJpbWFnZVwiXG4gICAgICB9KTtcbiAgICAgIG4ucHJvc2VtaXJyb3JWaWV3LmRpc3BhdGNoKFxuICAgICAgICBuLl90aXB0YXBFZGl0b3Iuc3RhdGUudHIuc2V0TWV0YShuLmltYWdlVG9vbGJhci5wbHVnaW4sIHtcbiAgICAgICAgICBibG9jazogZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICAgIHN1YnRleHQ6IFwiSW5zZXJ0IGFuIGltYWdlXCIsXG4gICAgYWxpYXNlczogW1xuICAgICAgXCJpbWFnZVwiLFxuICAgICAgXCJpbWFnZVVwbG9hZFwiLFxuICAgICAgXCJ1cGxvYWRcIixcbiAgICAgIFwiaW1nXCIsXG4gICAgICBcInBpY3R1cmVcIixcbiAgICAgIFwibWVkaWFcIixcbiAgICAgIFwidXJsXCIsXG4gICAgICBcImRyaXZlXCIsXG4gICAgICBcImRyb3Bib3hcIlxuICAgIF0sXG4gICAgZ3JvdXA6IFwiTWVkaWFcIlxuICB9KSwgdDtcbn1cbmZ1bmN0aW9uICRyKG4sIHQpIHtcbiAgcmV0dXJuIG4uZmlsdGVyKFxuICAgICh7IHRpdGxlOiBlLCBhbGlhc2VzOiBvIH0pID0+IGUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHQudG9Mb3dlckNhc2UoKSkgfHwgbyAmJiBvLmZpbHRlcihcbiAgICAgIChyKSA9PiByLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCh0LnRvTG93ZXJDYXNlKCkpXG4gICAgKS5sZW5ndGggIT09IDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGh0KG4gPSBcIlwiKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiID8gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogbixcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIF0gOiBuO1xufVxuZnVuY3Rpb24gcGUobikge1xuICByZXR1cm4gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiA/IGh0KG4pIDogQXJyYXkuaXNBcnJheShuKSA/IG4uZmxhdE1hcCgodCkgPT4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IGh0KHQpIDogJHQodCkgPyB7XG4gICAgLi4udCxcbiAgICBjb250ZW50OiBodCh0LmNvbnRlbnQpXG4gIH0gOiBZKHQpID8gdCA6IHtcbiAgICBwcm9wczoge30sXG4gICAgLi4udCxcbiAgICBjb250ZW50OiBwZSh0LmNvbnRlbnQpXG4gIH0pIDogbjtcbn1cbmZ1bmN0aW9uIEdyKG4sIHQpIHtcbiAgcmV0dXJuIHQubWFwKFxuICAgIChlKSA9PiB1ZShuLCBlKVxuICApO1xufVxuZnVuY3Rpb24gdWUobiwgdCkge1xuICBjb25zdCBlID0ge1xuICAgIGlkOiBcIlwiLFxuICAgIHR5cGU6IHQudHlwZSxcbiAgICBwcm9wczoge30sXG4gICAgY29udGVudDogblt0LnR5cGVdLmNvbnRlbnQgPT09IFwiaW5saW5lXCIgPyBbXSA6IHZvaWQgMCxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgLi4udFxuICB9O1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoblt0LnR5cGVdLnByb3BTY2hlbWEpLmZvckVhY2goXG4gICAgKFtvLCByXSkgPT4ge1xuICAgICAgZS5wcm9wc1tvXSA9PT0gdm9pZCAwICYmIChlLnByb3BzW29dID0gci5kZWZhdWx0KTtcbiAgICB9XG4gICksIHtcbiAgICAuLi5lLFxuICAgIGNvbnRlbnQ6IHBlKGUuY29udGVudCksXG4gICAgY2hpbGRyZW46IGUuY2hpbGRyZW4ubWFwKChvKSA9PiB1ZShuLCBvKSlcbiAgfTtcbn1cbmZ1bmN0aW9uIFpvKG4pIHtcbiAgbi5pZCB8fCAobi5pZCA9IFEub3B0aW9ucy5nZW5lcmF0ZUlEKCkpLCBuLmNoaWxkcmVuICYmIHRyKG4uY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gdHIobikge1xuICBmb3IgKGNvbnN0IHQgb2YgbilcbiAgICBabyh0KTtcbn1cbmV4cG9ydCB7XG4gIGRlIGFzIEJsb2NrTm90ZUVkaXRvcixcbiAgVHQgYXMgQmxvY2tOb3RlU2NoZW1hLFxuICBjbyBhcyBGb3JtYXR0aW5nVG9vbGJhclByb3NlbWlycm9yUGx1Z2luLFxuICBhbyBhcyBGb3JtYXR0aW5nVG9vbGJhclZpZXcsXG4gIGhvIGFzIEh5cGVybGlua1Rvb2xiYXJQcm9zZW1pcnJvclBsdWdpbixcbiAgZm8gYXMgSW1hZ2VUb29sYmFyUHJvc2VtaXJyb3JQbHVnaW4sXG4gIG1vIGFzIEltYWdlVG9vbGJhclZpZXcsXG4gIENvIGFzIFNpZGVNZW51UHJvc2VtaXJyb3JQbHVnaW4sXG4gIEVvIGFzIFNpZGVNZW51VmlldyxcbiAgeW8gYXMgU3VnZ2VzdGlvbk1lbnVQcm9zZU1pcnJvclBsdWdpbixcbiAgSW8gYXMgVGFibGVIYW5kbGVzUHJvc2VtaXJyb3JQbHVnaW4sXG4gIEJvIGFzIFRhYmxlSGFuZGxlc1ZpZXcsXG4gIFEgYXMgVW5pcXVlSUQsXG4gIE4gYXMgVW5yZWFjaGFibGVDYXNlRXJyb3IsXG4gIFpvIGFzIGFkZElkc1RvQmxvY2ssXG4gIHRyIGFzIGFkZElkc1RvQmxvY2tzLFxuICBwbiBhcyBhZGRJbmxpbmVDb250ZW50QXR0cmlidXRlcyxcbiAgdW4gYXMgYWRkSW5saW5lQ29udGVudEtleWJvYXJkU2hvcnRjdXRzLFxuICBibiBhcyBhZGRTdHlsZUF0dHJpYnV0ZXMsXG4gIFAgYXMgYmxvY2tUb05vZGUsXG4gIGl0IGFzIGNhbWVsVG9EYXRhS2ViYWIsXG4gIHpyIGFzIGNoZWNrQmxvY2tIYXNEZWZhdWx0UHJvcCxcbiAgUnIgYXMgY2hlY2tCbG9ja0lzRGVmYXVsdFR5cGUsXG4gIFduIGFzIGNoZWNrQmxvY2tUeXBlSGFzRGVmYXVsdFByb3AsXG4gIEwgYXMgY2hlY2tEZWZhdWx0QmxvY2tUeXBlSW5TY2hlbWEsXG4gIHd0IGFzIGNvbnRlbnROb2RlVG9JbmxpbmVDb250ZW50LFxuICBkbiBhcyBjcmVhdGVCbG9ja1NwZWMsXG4gIHR0IGFzIGNyZWF0ZUJsb2NrU3BlY0Zyb21TdHJvbmdseVR5cGVkVGlwdGFwTm9kZSxcbiAgYXQgYXMgY3JlYXRlRXh0ZXJuYWxIVE1MRXhwb3J0ZXIsXG4gIERyIGFzIGNyZWF0ZUlubGluZUNvbnRlbnRTcGVjLFxuICBtbiBhcyBjcmVhdGVJbmxpbmVDb250ZW50U3BlY0Zyb21UaXBUYXBOb2RlLFxuICBRdCBhcyBjcmVhdGVJbnRlcm5hbEJsb2NrU3BlYyxcbiAgSnQgYXMgY3JlYXRlSW50ZXJuYWxIVE1MU2VyaWFsaXplcixcbiAgaG4gYXMgY3JlYXRlSW50ZXJuYWxJbmxpbmVDb250ZW50U3BlYyxcbiAgZWUgYXMgY3JlYXRlSW50ZXJuYWxTdHlsZVNwZWMsXG4gIFcgYXMgY3JlYXRlU3Ryb25nbHlUeXBlZFRpcHRhcE5vZGUsXG4gIE9yIGFzIGNyZWF0ZVN0eWxlU3BlYyxcbiAgTyBhcyBjcmVhdGVTdHlsZVNwZWNGcm9tVGlwVGFwTWFyayxcbiAgVnIgYXMgY3JlYXRlU3VnZ2VzdGlvbk1lbnUsXG4gIGpuIGFzIGRlZmF1bHRCbG9ja1NjaGVtYSxcbiAgb2UgYXMgZGVmYXVsdEJsb2NrU3BlY3MsXG4gIFVyIGFzIGRlZmF1bHRJbmxpbmVDb250ZW50U2NoZW1hLFxuICBpZSBhcyBkZWZhdWx0SW5saW5lQ29udGVudFNwZWNzLFxuICB3IGFzIGRlZmF1bHRQcm9wcyxcbiAgX3IgYXMgZGVmYXVsdFN0eWxlU2NoZW1hLFxuICByZSBhcyBkZWZhdWx0U3R5bGVTcGVjcyxcbiAgJHIgYXMgZmlsdGVyU3VnZ2VzdGlvbkl0ZW1zLFxuICBWIGFzIGZvcm1hdEtleWJvYXJkU2hvcnRjdXQsXG4gIGxvIGFzIGZvcm1hdHRpbmdUb29sYmFyUGx1Z2luS2V5LFxuICBsbiBhcyBnZXRCbG9ja0Zyb21Qb3MsXG4gIHFvIGFzIGdldEJsb2NrTm90ZUV4dGVuc2lvbnMsXG4gIFp0IGFzIGdldEJsb2NrU2NoZW1hRnJvbVNwZWNzLFxuICBGciBhcyBnZXREZWZhdWx0U2xhc2hNZW51SXRlbXMsXG4gIEN0IGFzIGdldERyYWdnYWJsZUJsb2NrRnJvbUNvb3JkcyxcbiAgZm4gYXMgZ2V0SW5saW5lQ29udGVudFBhcnNlUnVsZXMsXG4gIHRlIGFzIGdldElubGluZUNvbnRlbnRTY2hlbWFGcm9tU3BlY3MsXG4gIGNuIGFzIGdldFBhcnNlUnVsZXMsXG4gIHluIGFzIGdldFN0eWxlUGFyc2VSdWxlcyxcbiAgbmUgYXMgZ2V0U3R5bGVTY2hlbWFGcm9tU3BlY3MsXG4gIHVvIGFzIGh5cGVybGlua1Rvb2xiYXJQbHVnaW5LZXksXG4gIFh0IGFzIGluaGVyaXRlZFByb3BzLFxuICBzdCBhcyBpbmxpbmVDb250ZW50VG9Ob2RlcyxcbiAgQSBhcyBpbnNlcnRPclVwZGF0ZUJsb2NrLFxuICBhbiBhcyBpc0FwcGxlT1MsXG4gIEl0IGFzIGlzTGlua0lubGluZUNvbnRlbnQsXG4gICR0IGFzIGlzUGFydGlhbExpbmtJbmxpbmVDb250ZW50LFxuICBQciBhcyBpc1NhZmFyaSxcbiAgWSBhcyBpc1N0eWxlZFRleHRJbmxpbmVDb250ZW50LFxuICBSIGFzIG1lcmdlQ1NTQ2xhc3NlcyxcbiAgayBhcyBub2RlVG9CbG9jayxcbiAgV3QgYXMgbm9kZVRvQ3VzdG9tSW5saW5lQ29udGVudCxcbiAgdWUgYXMgcGFydGlhbEJsb2NrVG9CbG9ja0ZvclRlc3RpbmcsXG4gIEdyIGFzIHBhcnRpYWxCbG9ja3NUb0Jsb2Nrc0ZvclRlc3RpbmcsXG4gIFl0IGFzIHByb3BzVG9BdHRyaWJ1dGVzLFxuICBTbyBhcyBzaWRlTWVudVBsdWdpbktleSxcbiAgZ24gYXMgc3R5bGVQcm9wc1RvQXR0cmlidXRlcyxcbiAgVSBhcyBzdWdnZXN0aW9uTWVudVBsdWdpbktleSxcbiAgR3QgYXMgdGFibGVDb250ZW50VG9Ob2RlcyxcbiAgWCBhcyB0YWJsZUhhbmRsZXNQbHVnaW5LZXksXG4gIEhyIGFzIHVwbG9hZFRvVG1wRmlsZXNEb3RPcmdfREVWX09OTFksXG4gIHB0IGFzIHdyYXBJbkJsb2NrU3RydWN0dXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2tub3RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocknote/core/dist/blocknote.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@blocknote/react/dist/blocknote-react.js":
/*!***************************************************************!*\
  !*** ./node_modules/@blocknote/react/dist/blocknote-react.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddBlockButton: () => (/* binding */ uo),\n/* harmony export */   BasicTextStyleButton: () => (/* binding */ ke),\n/* harmony export */   BlockColorsItem: () => (/* binding */ fo),\n/* harmony export */   BlockContentWrapper: () => (/* binding */ Fe),\n/* harmony export */   BlockNoteContext: () => (/* binding */ Kt),\n/* harmony export */   BlockNoteDefaultUI: () => (/* binding */ Fo),\n/* harmony export */   BlockNoteView: () => (/* binding */ oa),\n/* harmony export */   BlockTypeDropdown: () => (/* binding */ no),\n/* harmony export */   ColorStyleButton: () => (/* binding */ Zr),\n/* harmony export */   CreateLinkButton: () => (/* binding */ Ur),\n/* harmony export */   DragHandleButton: () => (/* binding */ mo),\n/* harmony export */   DragHandleMenu: () => (/* binding */ ho),\n/* harmony export */   DragHandleMenuItem: () => (/* binding */ fn),\n/* harmony export */   EditHyperlinkMenu: () => (/* binding */ ln),\n/* harmony export */   FormattingToolbar: () => (/* binding */ oo),\n/* harmony export */   FormattingToolbarController: () => (/* binding */ ao),\n/* harmony export */   HyperlinkToolbar: () => (/* binding */ io),\n/* harmony export */   HyperlinkToolbarController: () => (/* binding */ lo),\n/* harmony export */   ImageCaptionButton: () => (/* binding */ $r),\n/* harmony export */   ImageToolbar: () => (/* binding */ cn),\n/* harmony export */   ImageToolbarController: () => (/* binding */ so),\n/* harmony export */   NestBlockButton: () => (/* binding */ Wr),\n/* harmony export */   RemoveBlockItem: () => (/* binding */ go),\n/* harmony export */   ReplaceImageButton: () => (/* binding */ Yr),\n/* harmony export */   SideMenu: () => (/* binding */ bo),\n/* harmony export */   SideMenuButton: () => (/* binding */ un),\n/* harmony export */   SideMenuController: () => (/* binding */ xo),\n/* harmony export */   SuggestionMenu: () => (/* binding */ wo),\n/* harmony export */   SuggestionMenuController: () => (/* binding */ To),\n/* harmony export */   SuggestionMenuItem: () => (/* binding */ jo),\n/* harmony export */   SuggestionMenuWrapper: () => (/* binding */ Co),\n/* harmony export */   TableHandle: () => (/* binding */ Po),\n/* harmony export */   TableHandlesController: () => (/* binding */ Ao),\n/* harmony export */   TextAlignButton: () => (/* binding */ Ae),\n/* harmony export */   ToolbarButton: () => (/* binding */ P),\n/* harmony export */   ToolbarDropdown: () => (/* binding */ eo),\n/* harmony export */   UnnestBlockButton: () => (/* binding */ qr),\n/* harmony export */   applyBlockNoteCSSVariablesFromTheme: () => (/* binding */ Vt),\n/* harmony export */   blockTypeDropdownItems: () => (/* binding */ to),\n/* harmony export */   createReactBlockSpec: () => (/* binding */ ca),\n/* harmony export */   createReactInlineContentSpec: () => (/* binding */ ua),\n/* harmony export */   createReactStyleSpec: () => (/* binding */ da),\n/* harmony export */   darkDefaultTheme: () => (/* binding */ aa),\n/* harmony export */   defaultColorScheme: () => (/* binding */ y),\n/* harmony export */   getDefaultReactSlashMenuItems: () => (/* binding */ gn),\n/* harmony export */   getFormattingToolbarItems: () => (/* binding */ ro),\n/* harmony export */   lightDefaultTheme: () => (/* binding */ Lt),\n/* harmony export */   reactWrapInInlineContentStructure: () => (/* binding */ Go),\n/* harmony export */   removeBlockNoteCSSVariables: () => (/* binding */ Zo),\n/* harmony export */   useActiveStyles: () => (/* binding */ ia),\n/* harmony export */   useBlockNote: () => (/* binding */ la),\n/* harmony export */   useBlockNoteContext: () => (/* binding */ ee),\n/* harmony export */   useBlockNoteEditor: () => (/* binding */ V),\n/* harmony export */   useCloseSuggestionMenuNoItems: () => (/* binding */ po),\n/* harmony export */   useCreateBlockNote: () => (/* binding */ Yo),\n/* harmony export */   useEditorChange: () => (/* binding */ Je),\n/* harmony export */   useEditorContentOrSelectionChange: () => (/* binding */ U),\n/* harmony export */   useEditorForceUpdate: () => (/* binding */ sa),\n/* harmony export */   useEditorSelectionChange: () => (/* binding */ Qe),\n/* harmony export */   useLoadSuggestionMenuItems: () => (/* binding */ ko),\n/* harmony export */   useSelectedBlocks: () => (/* binding */ K),\n/* harmony export */   useSuggestionMenuKeyboardNavigation: () => (/* binding */ yo),\n/* harmony export */   useTableHandlesPositioning: () => (/* binding */ Mo)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _blocknote_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @blocknote/core */ \"(ssr)/./node_modules/@blocknote/core/dist/blocknote.js\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Group/Group.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Stack/Stack.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Text/Text.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Tooltip/Tooltip.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Button/Button.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/ActionIcon/ActionIcon.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/core/Box/Box.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Menu/Menu.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/TextInput/TextInput.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/FileInput/FileInput.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Popover/Popover.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Tabs/Tabs.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/LoadingOverlay/LoadingOverlay.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Badge/Badge.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/components/Loader/Loader.mjs\");\n/* harmony import */ var _mantine_core__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @mantine/core */ \"(ssr)/./node_modules/@mantine/core/esm/core/MantineProvider/MantineProvider.mjs\");\n/* harmony import */ var use_prefers_color_scheme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-prefers-color-scheme */ \"(ssr)/./node_modules/use-prefers-color-scheme/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @tiptap/react */ \"(ssr)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @tiptap/react */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n\n\n\n\n\nconst Kt = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nfunction ee(e) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Kt);\n}\nvar ze = { exports: {} }, ae = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar jt;\nfunction vr() {\n  if (jt)\n    return ae;\n  jt = 1;\n  var e = react__WEBPACK_IMPORTED_MODULE_0__, t = Symbol.for(\"react.element\"), n = Symbol.for(\"react.fragment\"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function c(s, d, f) {\n    var h, b = {}, T = null, C = null;\n    f !== void 0 && (T = \"\" + f), d.key !== void 0 && (T = \"\" + d.key), d.ref !== void 0 && (C = d.ref);\n    for (h in d)\n      r.call(d, h) && !l.hasOwnProperty(h) && (b[h] = d[h]);\n    if (s && s.defaultProps)\n      for (h in d = s.defaultProps, d)\n        b[h] === void 0 && (b[h] = d[h]);\n    return { $$typeof: t, type: s, key: T, ref: C, props: b, _owner: i.current };\n  }\n  return ae.Fragment = n, ae.jsx = c, ae.jsxs = c, ae;\n}\nvar ie = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar wt;\nfunction pr() {\n  return wt || (wt = 1,  true && function() {\n    var e = react__WEBPACK_IMPORTED_MODULE_0__, t = Symbol.for(\"react.element\"), n = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), i = Symbol.for(\"react.strict_mode\"), l = Symbol.for(\"react.profiler\"), c = Symbol.for(\"react.provider\"), s = Symbol.for(\"react.context\"), d = Symbol.for(\"react.forward_ref\"), f = Symbol.for(\"react.suspense\"), h = Symbol.for(\"react.suspense_list\"), b = Symbol.for(\"react.memo\"), T = Symbol.for(\"react.lazy\"), C = Symbol.for(\"react.offscreen\"), D = Symbol.iterator, ne = \"@@iterator\";\n    function F(a) {\n      if (a === null || typeof a != \"object\")\n        return null;\n      var u = D && a[D] || a[ne];\n      return typeof u == \"function\" ? u : null;\n    }\n    var O = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function M(a) {\n      {\n        for (var u = arguments.length, g = new Array(u > 1 ? u - 1 : 0), m = 1; m < u; m++)\n          g[m - 1] = arguments[m];\n        He(\"error\", a, g);\n      }\n    }\n    function He(a, u, g) {\n      {\n        var m = O.ReactDebugCurrentFrame, k = m.getStackAddendum();\n        k !== \"\" && (u += \"%s\", g = g.concat([k]));\n        var j = g.map(function(v) {\n          return String(v);\n        });\n        j.unshift(\"Warning: \" + u), Function.prototype.apply.call(console[a], console, j);\n      }\n    }\n    var $ = !1, he = !1, Ee = !1, Me = !1, Re = !1, W;\n    W = Symbol.for(\"react.module.reference\");\n    function mn(a) {\n      return !!(typeof a == \"string\" || typeof a == \"function\" || a === r || a === l || Re || a === i || a === f || a === h || Me || a === C || $ || he || Ee || typeof a == \"object\" && a !== null && (a.$$typeof === T || a.$$typeof === b || a.$$typeof === c || a.$$typeof === s || a.$$typeof === d || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      a.$$typeof === W || a.getModuleId !== void 0));\n    }\n    function bn(a, u, g) {\n      var m = a.displayName;\n      if (m)\n        return m;\n      var k = u.displayName || u.name || \"\";\n      return k !== \"\" ? g + \"(\" + k + \")\" : g;\n    }\n    function et(a) {\n      return a.displayName || \"Context\";\n    }\n    function N(a) {\n      if (a == null)\n        return null;\n      if (typeof a.tag == \"number\" && M(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof a == \"function\")\n        return a.displayName || a.name || null;\n      if (typeof a == \"string\")\n        return a;\n      switch (a) {\n        case r:\n          return \"Fragment\";\n        case n:\n          return \"Portal\";\n        case l:\n          return \"Profiler\";\n        case i:\n          return \"StrictMode\";\n        case f:\n          return \"Suspense\";\n        case h:\n          return \"SuspenseList\";\n      }\n      if (typeof a == \"object\")\n        switch (a.$$typeof) {\n          case s:\n            var u = a;\n            return et(u) + \".Consumer\";\n          case c:\n            var g = a;\n            return et(g._context) + \".Provider\";\n          case d:\n            return bn(a, a.render, \"ForwardRef\");\n          case b:\n            var m = a.displayName || null;\n            return m !== null ? m : N(a.type) || \"Memo\";\n          case T: {\n            var k = a, j = k._payload, v = k._init;\n            try {\n              return N(v(j));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var q = Object.assign, re = 0, tt, nt, rt, ot, at, it, lt;\n    function st() {\n    }\n    st.__reactDisabledLog = !0;\n    function xn() {\n      {\n        if (re === 0) {\n          tt = console.log, nt = console.info, rt = console.warn, ot = console.error, at = console.group, it = console.groupCollapsed, lt = console.groupEnd;\n          var a = {\n            configurable: !0,\n            enumerable: !0,\n            value: st,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: a,\n            log: a,\n            warn: a,\n            error: a,\n            group: a,\n            groupCollapsed: a,\n            groupEnd: a\n          });\n        }\n        re++;\n      }\n    }\n    function vn() {\n      {\n        if (re--, re === 0) {\n          var a = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: q({}, a, {\n              value: tt\n            }),\n            info: q({}, a, {\n              value: nt\n            }),\n            warn: q({}, a, {\n              value: rt\n            }),\n            error: q({}, a, {\n              value: ot\n            }),\n            group: q({}, a, {\n              value: at\n            }),\n            groupCollapsed: q({}, a, {\n              value: it\n            }),\n            groupEnd: q({}, a, {\n              value: lt\n            })\n          });\n        }\n        re < 0 && M(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var Ve = O.ReactCurrentDispatcher, Be;\n    function me(a, u, g) {\n      {\n        if (Be === void 0)\n          try {\n            throw Error();\n          } catch (k) {\n            var m = k.stack.trim().match(/\\n( *(at )?)/);\n            Be = m && m[1] || \"\";\n          }\n        return `\n` + Be + a;\n      }\n    }\n    var Le = !1, be;\n    {\n      var pn = typeof WeakMap == \"function\" ? WeakMap : Map;\n      be = new pn();\n    }\n    function ct(a, u) {\n      if (!a || Le)\n        return \"\";\n      {\n        var g = be.get(a);\n        if (g !== void 0)\n          return g;\n      }\n      var m;\n      Le = !0;\n      var k = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var j;\n      j = Ve.current, Ve.current = null, xn();\n      try {\n        if (u) {\n          var v = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(v.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(v, []);\n            } catch (Z) {\n              m = Z;\n            }\n            Reflect.construct(a, [], v);\n          } else {\n            try {\n              v.call();\n            } catch (Z) {\n              m = Z;\n            }\n            a.call(v.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (Z) {\n            m = Z;\n          }\n          a();\n        }\n      } catch (Z) {\n        if (Z && m && typeof Z.stack == \"string\") {\n          for (var x = Z.stack.split(`\n`), _ = m.stack.split(`\n`), E = x.length - 1, R = _.length - 1; E >= 1 && R >= 0 && x[E] !== _[R]; )\n            R--;\n          for (; E >= 1 && R >= 0; E--, R--)\n            if (x[E] !== _[R]) {\n              if (E !== 1 || R !== 1)\n                do\n                  if (E--, R--, R < 0 || x[E] !== _[R]) {\n                    var I = `\n` + x[E].replace(\" at new \", \" at \");\n                    return a.displayName && I.includes(\"<anonymous>\") && (I = I.replace(\"<anonymous>\", a.displayName)), typeof a == \"function\" && be.set(a, I), I;\n                  }\n                while (E >= 1 && R >= 0);\n              break;\n            }\n        }\n      } finally {\n        Le = !1, Ve.current = j, vn(), Error.prepareStackTrace = k;\n      }\n      var J = a ? a.displayName || a.name : \"\", Ct = J ? me(J) : \"\";\n      return typeof a == \"function\" && be.set(a, Ct), Ct;\n    }\n    function kn(a, u, g) {\n      return ct(a, !1);\n    }\n    function yn(a) {\n      var u = a.prototype;\n      return !!(u && u.isReactComponent);\n    }\n    function xe(a, u, g) {\n      if (a == null)\n        return \"\";\n      if (typeof a == \"function\")\n        return ct(a, yn(a));\n      if (typeof a == \"string\")\n        return me(a);\n      switch (a) {\n        case f:\n          return me(\"Suspense\");\n        case h:\n          return me(\"SuspenseList\");\n      }\n      if (typeof a == \"object\")\n        switch (a.$$typeof) {\n          case d:\n            return kn(a.render);\n          case b:\n            return xe(a.type, u, g);\n          case T: {\n            var m = a, k = m._payload, j = m._init;\n            try {\n              return xe(j(k), u, g);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var ve = Object.prototype.hasOwnProperty, ut = {}, dt = O.ReactDebugCurrentFrame;\n    function pe(a) {\n      if (a) {\n        var u = a._owner, g = xe(a.type, a._source, u ? u.type : null);\n        dt.setExtraStackFrame(g);\n      } else\n        dt.setExtraStackFrame(null);\n    }\n    function Cn(a, u, g, m, k) {\n      {\n        var j = Function.call.bind(ve);\n        for (var v in a)\n          if (j(a, v)) {\n            var x = void 0;\n            try {\n              if (typeof a[v] != \"function\") {\n                var _ = Error((m || \"React class\") + \": \" + g + \" type `\" + v + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof a[v] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw _.name = \"Invariant Violation\", _;\n              }\n              x = a[v](u, v, m, g, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (E) {\n              x = E;\n            }\n            x && !(x instanceof Error) && (pe(k), M(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", m || \"React class\", g, v, typeof x), pe(null)), x instanceof Error && !(x.message in ut) && (ut[x.message] = !0, pe(k), M(\"Failed %s type: %s\", g, x.message), pe(null));\n          }\n      }\n    }\n    var Sn = Array.isArray;\n    function De(a) {\n      return Sn(a);\n    }\n    function jn(a) {\n      {\n        var u = typeof Symbol == \"function\" && Symbol.toStringTag, g = u && a[Symbol.toStringTag] || a.constructor.name || \"Object\";\n        return g;\n      }\n    }\n    function wn(a) {\n      try {\n        return ft(a), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function ft(a) {\n      return \"\" + a;\n    }\n    function gt(a) {\n      if (wn(a))\n        return M(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", jn(a)), ft(a);\n    }\n    var oe = O.ReactCurrentOwner, Tn = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, ht, mt, _e;\n    _e = {};\n    function Hn(a) {\n      if (ve.call(a, \"ref\")) {\n        var u = Object.getOwnPropertyDescriptor(a, \"ref\").get;\n        if (u && u.isReactWarning)\n          return !1;\n      }\n      return a.ref !== void 0;\n    }\n    function En(a) {\n      if (ve.call(a, \"key\")) {\n        var u = Object.getOwnPropertyDescriptor(a, \"key\").get;\n        if (u && u.isReactWarning)\n          return !1;\n      }\n      return a.key !== void 0;\n    }\n    function Mn(a, u) {\n      if (typeof a.ref == \"string\" && oe.current && u && oe.current.stateNode !== u) {\n        var g = N(oe.current.type);\n        _e[g] || (M('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', N(oe.current.type), a.ref), _e[g] = !0);\n      }\n    }\n    function Rn(a, u) {\n      {\n        var g = function() {\n          ht || (ht = !0, M(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", u));\n        };\n        g.isReactWarning = !0, Object.defineProperty(a, \"key\", {\n          get: g,\n          configurable: !0\n        });\n      }\n    }\n    function Vn(a, u) {\n      {\n        var g = function() {\n          mt || (mt = !0, M(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", u));\n        };\n        g.isReactWarning = !0, Object.defineProperty(a, \"ref\", {\n          get: g,\n          configurable: !0\n        });\n      }\n    }\n    var Bn = function(a, u, g, m, k, j, v) {\n      var x = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: t,\n        // Built-in properties that belong on the element\n        type: a,\n        key: u,\n        ref: g,\n        props: v,\n        // Record the component responsible for creating this element.\n        _owner: j\n      };\n      return x._store = {}, Object.defineProperty(x._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(x, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: m\n      }), Object.defineProperty(x, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: k\n      }), Object.freeze && (Object.freeze(x.props), Object.freeze(x)), x;\n    };\n    function Ln(a, u, g, m, k) {\n      {\n        var j, v = {}, x = null, _ = null;\n        g !== void 0 && (gt(g), x = \"\" + g), En(u) && (gt(u.key), x = \"\" + u.key), Hn(u) && (_ = u.ref, Mn(u, k));\n        for (j in u)\n          ve.call(u, j) && !Tn.hasOwnProperty(j) && (v[j] = u[j]);\n        if (a && a.defaultProps) {\n          var E = a.defaultProps;\n          for (j in E)\n            v[j] === void 0 && (v[j] = E[j]);\n        }\n        if (x || _) {\n          var R = typeof a == \"function\" ? a.displayName || a.name || \"Unknown\" : a;\n          x && Rn(v, R), _ && Vn(v, R);\n        }\n        return Bn(a, x, _, k, m, oe.current, v);\n      }\n    }\n    var Ie = O.ReactCurrentOwner, bt = O.ReactDebugCurrentFrame;\n    function G(a) {\n      if (a) {\n        var u = a._owner, g = xe(a.type, a._source, u ? u.type : null);\n        bt.setExtraStackFrame(g);\n      } else\n        bt.setExtraStackFrame(null);\n    }\n    var Oe;\n    Oe = !1;\n    function Pe(a) {\n      return typeof a == \"object\" && a !== null && a.$$typeof === t;\n    }\n    function xt() {\n      {\n        if (Ie.current) {\n          var a = N(Ie.current.type);\n          if (a)\n            return `\n\nCheck the render method of \\`` + a + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function Dn(a) {\n      {\n        if (a !== void 0) {\n          var u = a.fileName.replace(/^.*[\\\\\\/]/, \"\"), g = a.lineNumber;\n          return `\n\nCheck your code at ` + u + \":\" + g + \".\";\n        }\n        return \"\";\n      }\n    }\n    var vt = {};\n    function _n(a) {\n      {\n        var u = xt();\n        if (!u) {\n          var g = typeof a == \"string\" ? a : a.displayName || a.name;\n          g && (u = `\n\nCheck the top-level render call using <` + g + \">.\");\n        }\n        return u;\n      }\n    }\n    function pt(a, u) {\n      {\n        if (!a._store || a._store.validated || a.key != null)\n          return;\n        a._store.validated = !0;\n        var g = _n(u);\n        if (vt[g])\n          return;\n        vt[g] = !0;\n        var m = \"\";\n        a && a._owner && a._owner !== Ie.current && (m = \" It was passed a child from \" + N(a._owner.type) + \".\"), G(a), M('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', g, m), G(null);\n      }\n    }\n    function kt(a, u) {\n      {\n        if (typeof a != \"object\")\n          return;\n        if (De(a))\n          for (var g = 0; g < a.length; g++) {\n            var m = a[g];\n            Pe(m) && pt(m, u);\n          }\n        else if (Pe(a))\n          a._store && (a._store.validated = !0);\n        else if (a) {\n          var k = F(a);\n          if (typeof k == \"function\" && k !== a.entries)\n            for (var j = k.call(a), v; !(v = j.next()).done; )\n              Pe(v.value) && pt(v.value, u);\n        }\n      }\n    }\n    function In(a) {\n      {\n        var u = a.type;\n        if (u == null || typeof u == \"string\")\n          return;\n        var g;\n        if (typeof u == \"function\")\n          g = u.propTypes;\n        else if (typeof u == \"object\" && (u.$$typeof === d || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        u.$$typeof === b))\n          g = u.propTypes;\n        else\n          return;\n        if (g) {\n          var m = N(u);\n          Cn(g, a.props, \"prop\", m, a);\n        } else if (u.PropTypes !== void 0 && !Oe) {\n          Oe = !0;\n          var k = N(u);\n          M(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", k || \"Unknown\");\n        }\n        typeof u.getDefaultProps == \"function\" && !u.getDefaultProps.isReactClassApproved && M(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function On(a) {\n      {\n        for (var u = Object.keys(a.props), g = 0; g < u.length; g++) {\n          var m = u[g];\n          if (m !== \"children\" && m !== \"key\") {\n            G(a), M(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", m), G(null);\n            break;\n          }\n        }\n        a.ref !== null && (G(a), M(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), G(null));\n      }\n    }\n    function yt(a, u, g, m, k, j) {\n      {\n        var v = mn(a);\n        if (!v) {\n          var x = \"\";\n          (a === void 0 || typeof a == \"object\" && a !== null && Object.keys(a).length === 0) && (x += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var _ = Dn(k);\n          _ ? x += _ : x += xt();\n          var E;\n          a === null ? E = \"null\" : De(a) ? E = \"array\" : a !== void 0 && a.$$typeof === t ? (E = \"<\" + (N(a.type) || \"Unknown\") + \" />\", x = \" Did you accidentally export a JSX literal instead of a component?\") : E = typeof a, M(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", E, x);\n        }\n        var R = Ln(a, u, g, k, j);\n        if (R == null)\n          return R;\n        if (v) {\n          var I = u.children;\n          if (I !== void 0)\n            if (m)\n              if (De(I)) {\n                for (var J = 0; J < I.length; J++)\n                  kt(I[J], a);\n                Object.freeze && Object.freeze(I);\n              } else\n                M(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              kt(I, a);\n        }\n        return a === r ? On(R) : In(R), R;\n      }\n    }\n    function Pn(a, u, g) {\n      return yt(a, u, g, !0);\n    }\n    function An(a, u, g) {\n      return yt(a, u, g, !1);\n    }\n    var Fn = An, Nn = Pn;\n    ie.Fragment = r, ie.jsx = Fn, ie.jsxs = Nn;\n  }()), ie;\n}\n false ? 0 : ze.exports = pr();\nvar o = ze.exports;\nfunction V(e) {\n  const t = ee();\n  if (!(t != null && t.editor))\n    throw new Error(\n      \"useBlockNoteEditor was called outside of a BlockNoteContext provider or BlockNoteView component\"\n    );\n  return t.editor;\n}\nfunction Je(e, t) {\n  const n = ee();\n  t || (t = n == null ? void 0 : n.editor), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!t)\n      throw new Error(\n        \"'editor' is required, either from BlockNoteContext or as a function argument\"\n      );\n    return t.onChange(e);\n  }, [e, t]);\n}\nfunction Qe(e, t) {\n  const n = ee();\n  t || (t = n == null ? void 0 : n.editor), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!t)\n      throw new Error(\n        \"'editor' is required, either from BlockNoteContext or as a function argument\"\n      );\n    return t.onSelectionChange(e);\n  }, [e, t]);\n}\nfunction U(e, t) {\n  Je(e, t), Qe(e, t);\n}\nfunction ge(e, t, n, r) {\n  const { refs: i, update: l, context: c, floatingStyles: s } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useFloating)({\n    open: e,\n    ...r\n  }), { isMounted: d, styles: f } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useTransitionStyles)(c);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    l();\n  }, [t, l]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t !== null && i.setReference({\n      getBoundingClientRect: () => t\n    });\n  }, [t, i]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      isMounted: d,\n      ref: i.setFloating,\n      style: {\n        display: \"flex\",\n        ...f,\n        ...s,\n        zIndex: n\n      }\n    }),\n    [s, d, i.setFloating, f, n]\n  );\n}\nfunction te(e) {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => e((r) => {\n    n({ ...r });\n  }), [e]), t;\n}\nconst Ce = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const { className: n, children: r, ...i } = e;\n  return /* @__PURE__ */ o.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_5__.Group,\n    {\n      className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(\"bn-toolbar\", n || \"\"),\n      ref: t,\n      ...i,\n      children: r\n    }\n  );\n});\nvar Gt = {\n  color: void 0,\n  size: void 0,\n  className: void 0,\n  style: void 0,\n  attr: void 0\n}, Tt = react__WEBPACK_IMPORTED_MODULE_0__.createContext && react__WEBPACK_IMPORTED_MODULE_0__.createContext(Gt), z = globalThis && globalThis.__assign || function() {\n  return z = Object.assign || function(e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) {\n      t = arguments[n];\n      for (var i in t)\n        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);\n    }\n    return e;\n  }, z.apply(this, arguments);\n}, kr = globalThis && globalThis.__rest || function(e, t) {\n  var n = {};\n  for (var r in e)\n    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);\n  if (e != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)\n      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);\n  return n;\n};\nfunction Jt(e) {\n  return e && e.map(function(t, n) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(t.tag, z({\n      key: n\n    }, t.attr), Jt(t.child));\n  });\n}\nfunction S(e) {\n  return function(t) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(yr, z({\n      attr: z({}, e.attr)\n    }, t), Jt(e.child));\n  };\n}\nfunction yr(e) {\n  var t = function(n) {\n    var r = e.attr, i = e.size, l = e.title, c = kr(e, [\"attr\", \"size\", \"title\"]), s = i || n.size || \"1em\", d;\n    return n.className && (d = n.className), e.className && (d = (d ? d + \" \" : \"\") + e.className), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", z({\n      stroke: \"currentColor\",\n      fill: \"currentColor\",\n      strokeWidth: \"0\"\n    }, n.attr, r, c, {\n      className: d,\n      style: z(z({\n        color: e.color || n.color\n      }, n.style), e.style),\n      height: s,\n      width: s,\n      xmlns: \"http://www.w3.org/2000/svg\"\n    }), l && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"title\", null, l), e.children);\n  };\n  return Tt !== void 0 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tt.Consumer, null, function(n) {\n    return t(n);\n  }) : t(Gt);\n}\nfunction Cr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M23 11.9998L15.9289 19.0708L14.5147 17.6566L20.1716 11.9998L14.5147 6.34292L15.9289 4.92871L23 11.9998ZM3.82843 11.9998L9.48528 17.6566L8.07107 19.0708L1 11.9998L8.07107 4.92871L9.48528 6.34292L3.82843 11.9998Z\" } }] })(e);\n}\nfunction Sr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM5 19H19V21H5V19ZM3 14H21V16H3V14ZM5 9H19V11H5V9Z\" } }] })(e);\n}\nfunction jr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM3 19H21V21H3V19ZM3 14H21V16H3V14ZM3 9H21V11H3V9Z\" } }] })(e);\n}\nfunction wr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM3 19H17V21H3V19ZM3 14H21V16H3V14ZM3 9H17V11H3V9Z\" } }] })(e);\n}\nfunction Tr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM7 19H21V21H7V19ZM3 14H21V16H3V14ZM7 9H21V11H7V9Z\" } }] })(e);\n}\nfunction Hr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M8 11H12.5C13.8807 11 15 9.88071 15 8.5C15 7.11929 13.8807 6 12.5 6H8V11ZM18 15.5C18 17.9853 15.9853 20 13.5 20H6V4H12.5C14.9853 4 17 6.01472 17 8.5C17 9.70431 16.5269 10.7981 15.7564 11.6058C17.0979 12.3847 18 13.837 18 15.5ZM8 13V18H13.5C14.8807 18 16 16.8807 16 15.5C16 14.1193 14.8807 13 13.5 13H8Z\" } }] })(e);\n}\nfunction Qt(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M13 20H11V13H4V20H2V4H4V11H11V4H13V20ZM21.0005 8V20H19.0005L19 10.204L17 10.74V8.67L19.5005 8H21.0005Z\" } }] })(e);\n}\nfunction Xt(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M4 4V11H11V4H13V20H11V13H4V20H2V4H4ZM18.5 8C20.5711 8 22.25 9.67893 22.25 11.75C22.25 12.6074 21.9623 13.3976 21.4781 14.0292L21.3302 14.2102L18.0343 18H22V20H15L14.9993 18.444L19.8207 12.8981C20.0881 12.5908 20.25 12.1893 20.25 11.75C20.25 10.7835 19.4665 10 18.5 10C17.5818 10 16.8288 10.7071 16.7558 11.6065L16.75 11.75H14.75C14.75 9.67893 16.4289 8 18.5 8Z\" } }] })(e);\n}\nfunction en(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M22 8L21.9984 10L19.4934 12.883C21.0823 13.3184 22.25 14.7728 22.25 16.5C22.25 18.5711 20.5711 20.25 18.5 20.25C16.674 20.25 15.1528 18.9449 14.8184 17.2166L16.7821 16.8352C16.9384 17.6413 17.6481 18.25 18.5 18.25C19.4665 18.25 20.25 17.4665 20.25 16.5C20.25 15.5335 19.4665 14.75 18.5 14.75C18.214 14.75 17.944 14.8186 17.7056 14.9403L16.3992 13.3932L19.3484 10H15V8H22ZM4 4V11H11V4H13V20H11V13H4V20H2V4H4Z\" } }] })(e);\n}\nfunction Er(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM3 12.5L7 9V16L3 12.5Z\" } }] })(e);\n}\nfunction Mr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M3 4H21V6H3V4ZM3 19H21V21H3V19ZM11 14H21V16H11V14ZM11 9H21V11H11V9ZM7 12.5L3 16V9L7 12.5Z\" } }] })(e);\n}\nfunction Rr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M15 20H7V18H9.92661L12.0425 6H9V4H17V6H14.0734L11.9575 18H15V20Z\" } }] })(e);\n}\nfunction Vr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M17 17H22V19H19V22H17V17ZM7 7H2V5H5V2H7V7ZM18.364 15.5355L16.9497 14.1213L18.364 12.7071C20.3166 10.7545 20.3166 7.58866 18.364 5.63604C16.4113 3.68342 13.2455 3.68342 11.2929 5.63604L9.87868 7.05025L8.46447 5.63604L9.87868 4.22183C12.6123 1.48816 17.0445 1.48816 19.7782 4.22183C22.5118 6.9555 22.5118 11.3877 19.7782 14.1213L18.364 15.5355ZM15.5355 18.364L14.1213 19.7782C11.3877 22.5118 6.9555 22.5118 4.22183 19.7782C1.48816 17.0445 1.48816 12.6123 4.22183 9.87868L5.63604 8.46447L7.05025 9.87868L5.63604 11.2929C3.68342 13.2455 3.68342 16.4113 5.63604 18.364C7.58866 20.3166 10.7545 20.3166 12.7071 18.364L14.1213 16.9497L15.5355 18.364ZM14.8284 7.75736L16.2426 9.17157L9.17157 16.2426L7.75736 14.8284L14.8284 7.75736Z\" } }] })(e);\n}\nfunction tn(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M18.3643 15.5353L16.95 14.1211L18.3643 12.7069C20.3169 10.7543 20.3169 7.58847 18.3643 5.63585C16.4116 3.68323 13.2458 3.68323 11.2932 5.63585L9.87898 7.05007L8.46477 5.63585L9.87898 4.22164C12.6127 1.48797 17.0448 1.48797 19.7785 4.22164C22.5121 6.95531 22.5121 11.3875 19.7785 14.1211L18.3643 15.5353ZM15.5358 18.3638L14.1216 19.778C11.388 22.5117 6.9558 22.5117 4.22213 19.778C1.48846 17.0443 1.48846 12.6122 4.22213 9.87849L5.63634 8.46428L7.05055 9.87849L5.63634 11.2927C3.68372 13.2453 3.68372 16.4112 5.63634 18.3638C7.58896 20.3164 10.7548 20.3164 12.7074 18.3638L14.1216 16.9496L15.5358 18.3638ZM14.8287 7.75717L16.2429 9.17139L9.17187 16.2425L7.75766 14.8282L14.8287 7.75717Z\" } }] })(e);\n}\nfunction nn(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M8 4H21V6H8V4ZM5 3V6H6V7H3V6H4V4H3V3H5ZM3 14V11.5H5V11H3V10H6V12.5H4V13H6V14H3ZM5 19.5H3V18.5H5V18H3V17H6V21H3V20H5V19.5ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z\" } }] })(e);\n}\nfunction rn(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M8 4H21V6H8V4ZM4.5 6.5C3.67157 6.5 3 5.82843 3 5C3 4.17157 3.67157 3.5 4.5 3.5C5.32843 3.5 6 4.17157 6 5C6 5.82843 5.32843 6.5 4.5 6.5ZM4.5 13.5C3.67157 13.5 3 12.8284 3 12C3 11.1716 3.67157 10.5 4.5 10.5C5.32843 10.5 6 11.1716 6 12C6 12.8284 5.32843 13.5 4.5 13.5ZM4.5 20.4C3.67157 20.4 3 19.7284 3 18.9C3 18.0716 3.67157 17.4 4.5 17.4C5.32843 17.4 6 18.0716 6 18.9C6 19.7284 5.32843 20.4 4.5 20.4ZM8 11H21V13H8V11ZM8 18H21V20H8V18Z\" } }] })(e);\n}\nfunction Br(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M17.1538 14C17.3846 14.5161 17.5 15.0893 17.5 15.7196C17.5 17.0625 16.9762 18.1116 15.9286 18.867C14.8809 19.6223 13.4335 20 11.5862 20C9.94674 20 8.32335 19.6185 6.71592 18.8555V16.6009C8.23538 17.4783 9.7908 17.917 11.3822 17.917C13.9333 17.917 15.2128 17.1846 15.2208 15.7196C15.2208 15.0939 15.0049 14.5598 14.5731 14.1173C14.5339 14.0772 14.4939 14.0381 14.4531 14H3V12H21V14H17.1538ZM13.076 11H7.62908C7.4566 10.8433 7.29616 10.6692 7.14776 10.4778C6.71592 9.92084 6.5 9.24559 6.5 8.45207C6.5 7.21602 6.96583 6.165 7.89749 5.299C8.82916 4.43299 10.2706 4 12.2219 4C13.6934 4 15.1009 4.32808 16.4444 4.98426V7.13591C15.2448 6.44921 13.9293 6.10587 12.4978 6.10587C10.0187 6.10587 8.77917 6.88793 8.77917 8.45207C8.77917 8.87172 8.99709 9.23796 9.43293 9.55079C9.86878 9.86362 10.4066 10.1135 11.0463 10.3004C11.6665 10.4816 12.3431 10.7148 13.076 11H13.076Z\" } }] })(e);\n}\nfunction Lr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M13 10V14H19V10H13ZM11 10H5V14H11V10ZM13 19H19V16H13V19ZM11 19V16H5V19H11ZM13 5V8H19V5H13ZM11 5H5V8H11V5ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3Z\" } }] })(e);\n}\nfunction ce(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M13 6V21H11V6H5V4H19V6H13Z\" } }] })(e);\n}\nfunction Dr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M8 3V12C8 14.2091 9.79086 16 12 16C14.2091 16 16 14.2091 16 12V3H18V12C18 15.3137 15.3137 18 12 18C8.68629 18 6 15.3137 6 12V3H8ZM4 20H20V22H4V20Z\" } }] })(e);\n}\nfunction _r(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z\" } }] })(e);\n}\nfunction Ir(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M20 3C20.5523 3 21 3.44772 21 4V5.757L19 7.757V5H5V13.1L9 9.1005L13.328 13.429L12.0012 14.7562L11.995 18.995L16.2414 19.0012L17.571 17.671L18.8995 19H19V16.242L21 14.242V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3H20ZM21.7782 7.80761L23.1924 9.22183L15.4142 17L13.9979 16.9979L14 15.5858L21.7782 7.80761ZM15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7Z\" } }] })(e);\n}\nfunction Or(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M10 6V8H5V19H16V14H18V20C18 20.5523 17.5523 21 17 21H4C3.44772 21 3 20.5523 3 20V7C3 6.44772 3.44772 6 4 6H10ZM21 3V12L17.206 8.207L11.2071 14.2071L9.79289 12.7929L15.792 6.793L12 3H21Z\" } }] })(e);\n}\nfunction K(e) {\n  const t = ee();\n  if (e || (e = t == null ? void 0 : t.editor), !e)\n    throw new Error(\n      \"'editor' is required, either from BlockNoteContext or as a function argument\"\n    );\n  const n = e, [r, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n    var l;\n    return ((l = n.getSelection()) == null ? void 0 : l.blocks) || [n.getTextCursorPosition().block];\n  });\n  return U(\n    () => {\n      var l;\n      return i(\n        ((l = n.getSelection()) == null ? void 0 : l.blocks) || [n.getTextCursorPosition().block]\n      );\n    },\n    n\n  ), r;\n}\nconst Pr = (e) => /* @__PURE__ */ o.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_6__.Stack, { gap: 0, className: \"bn-tooltip\", children: [\n  /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_7__.Text, { size: \"sm\", children: e.mainTooltip }),\n  e.secondaryTooltip && /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_7__.Text, { size: \"xs\", children: e.secondaryTooltip })\n] }), P = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  (e, t) => {\n    const n = e.icon;\n    return /* @__PURE__ */ o.jsx(\n      _mantine_core__WEBPACK_IMPORTED_MODULE_8__.Tooltip,\n      {\n        withinPortal: !1,\n        label: /* @__PURE__ */ o.jsx(\n          Pr,\n          {\n            mainTooltip: e.mainTooltip,\n            secondaryTooltip: e.secondaryTooltip\n          }\n        ),\n        children: e.children ? /* @__PURE__ */ o.jsxs(\n          _mantine_core__WEBPACK_IMPORTED_MODULE_9__.Button,\n          {\n            onMouseDown: (r) => {\n              (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.isSafari)() && r.currentTarget.focus();\n            },\n            onClick: e.onClick,\n            \"data-selected\": e.isSelected ? \"true\" : void 0,\n            \"data-test\": e.mainTooltip.slice(0, 1).toLowerCase() + e.mainTooltip.replace(/\\s+/g, \"\").slice(1),\n            size: \"xs\",\n            disabled: e.isDisabled || !1,\n            ref: t,\n            children: [\n              n && /* @__PURE__ */ o.jsx(n, {}),\n              e.children\n            ]\n          }\n        ) : /* @__PURE__ */ o.jsx(\n          _mantine_core__WEBPACK_IMPORTED_MODULE_10__.ActionIcon,\n          {\n            onMouseDown: (r) => {\n              (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.isSafari)() && r.currentTarget.focus();\n            },\n            onClick: e.onClick,\n            \"data-selected\": e.isSelected ? \"true\" : void 0,\n            \"data-test\": e.mainTooltip.slice(0, 1).toLowerCase() + e.mainTooltip.replace(/\\s+/g, \"\").slice(1),\n            size: 30,\n            disabled: e.isDisabled || !1,\n            ref: t,\n            children: n && /* @__PURE__ */ o.jsx(n, {})\n          }\n        )\n      }\n    );\n  }\n), Ar = {\n  bold: Hr,\n  italic: Rr,\n  underline: Dr,\n  strike: Br,\n  code: Cr\n}, Fr = {\n  bold: \"Mod+B\",\n  italic: \"Mod+I\",\n  underline: \"Mod+U\",\n  strike: \"Mod+Shift+X\",\n  code: \"\"\n};\nfunction Nr(e, t) {\n  return e in t.schema.styleSchema && t.schema.styleSchema[e].type === e && t.schema.styleSchema[e].propSchema === \"boolean\";\n}\nconst ke = (e) => {\n  const t = V(), n = Nr(\n    e.basicTextStyle,\n    t\n  ), r = K(t), [i, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    e.basicTextStyle in t.getActiveStyles()\n  );\n  U(() => {\n    n && l(e.basicTextStyle in t.getActiveStyles());\n  }, t);\n  const c = (d) => {\n    if (n) {\n      if (t.focus(), t.schema.styleSchema[d].propSchema !== \"boolean\")\n        throw new Error(\"can only toggle boolean styles\");\n      t.toggleStyles({ [d]: !0 });\n    }\n  };\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => n ? !!r.find((d) => d.content !== void 0) : !1, [n, r]) ? /* @__PURE__ */ o.jsx(\n    P,\n    {\n      onClick: () => c(e.basicTextStyle),\n      isSelected: i,\n      mainTooltip: e.basicTextStyle.slice(0, 1).toUpperCase() + e.basicTextStyle.slice(1),\n      secondaryTooltip: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.formatKeyboardShortcut)(Fr[e.basicTextStyle]),\n      icon: Ar[e.basicTextStyle]\n    }\n  ) : null;\n};\nfunction Xe() {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return {\n    ref: e,\n    updateMaxHeight: () => {\n      setTimeout(() => {\n        if (e.current && e.current.childElementCount > 0) {\n          e.current.firstElementChild.style.maxHeight = \"none\";\n          const t = e.current.firstElementChild.getBoundingClientRect();\n          e.current.firstElementChild.style.maxHeight = `${Math.min(\n            t.top >= 0 ? window.innerHeight - t.top - 20 : t.bottom - 20\n          )}px`;\n        }\n      }, 10);\n    }\n  };\n}\nconst Ue = (e) => {\n  const t = e.textColor || \"default\", n = e.backgroundColor || \"default\", r = e.size || 16, i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      pointerEvents: \"none\",\n      fontSize: (r * 0.75).toString() + \"px\",\n      height: r.toString() + \"px\",\n      lineHeight: r.toString() + \"px\",\n      textAlign: \"center\",\n      width: r.toString() + \"px\"\n    }),\n    [r]\n  );\n  return /* @__PURE__ */ o.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_11__.Box,\n    {\n      className: \"bn-color-icon\",\n      \"data-background-color\": n,\n      \"data-text-color\": t,\n      style: i,\n      children: \"A\"\n    }\n  );\n};\nfunction $e(e) {\n  return S({ tag: \"svg\", attr: { version: \"1.2\", baseProfile: \"tiny\", viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { d: \"M16.972 6.251c-.967-.538-2.185-.188-2.72.777l-3.713 6.682-2.125-2.125c-.781-.781-2.047-.781-2.828 0-.781.781-.781 2.047 0 2.828l4 4c.378.379.888.587 1.414.587l.277-.02c.621-.087 1.166-.46 1.471-1.009l5-9c.537-.966.189-2.183-.776-2.72z\" } }] })(e);\n}\nconst on = (e) => {\n  const t = () => e.text ? /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n    /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Label, { children: \"Text\" }),\n    [\n      \"default\",\n      \"gray\",\n      \"brown\",\n      \"red\",\n      \"orange\",\n      \"yellow\",\n      \"green\",\n      \"blue\",\n      \"purple\",\n      \"pink\"\n    ].map((r) => /* @__PURE__ */ o.jsx(\n      _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Item,\n      {\n        onClick: () => {\n          e.onClick && e.onClick(), e.text.setColor(r);\n        },\n        component: \"div\",\n        \"data-test\": \"text-color-\" + r,\n        leftSection: /* @__PURE__ */ o.jsx(Ue, { textColor: r, size: e.iconSize }),\n        rightSection: e.text.color === r ? /* @__PURE__ */ o.jsx($e, { size: 20, className: \"bn-tick-icon\" }) : /* @__PURE__ */ o.jsx(\"div\", { className: \"bn-tick-space\" }),\n        children: r.charAt(0).toUpperCase() + r.slice(1)\n      },\n      \"text-color-\" + r\n    ))\n  ] }) : null, n = () => e.background ? /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n    /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Label, { children: \"Background\" }),\n    [\n      \"default\",\n      \"gray\",\n      \"brown\",\n      \"red\",\n      \"orange\",\n      \"yellow\",\n      \"green\",\n      \"blue\",\n      \"purple\",\n      \"pink\"\n    ].map((r) => /* @__PURE__ */ o.jsx(\n      _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Item,\n      {\n        onClick: () => {\n          e.onClick && e.onClick(), e.background.setColor(r);\n        },\n        component: \"div\",\n        \"data-test\": \"background-color-\" + r,\n        leftSection: /* @__PURE__ */ o.jsx(Ue, { backgroundColor: r, size: e.iconSize }),\n        rightSection: e.background.color === r ? /* @__PURE__ */ o.jsx($e, { size: 20, className: \"bn-tick-icon\" }) : /* @__PURE__ */ o.jsx(\"div\", { className: \"bn-tick-space\" }),\n        children: r.charAt(0).toUpperCase() + r.slice(1)\n      },\n      \"background-color-\" + r\n    ))\n  ] }) : null;\n  return /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n    /* @__PURE__ */ o.jsx(t, {}),\n    /* @__PURE__ */ o.jsx(n, {})\n  ] });\n};\nfunction Ht(e, t) {\n  return `${e}Color` in t.schema.styleSchema && t.schema.styleSchema[`${e}Color`].type === `${e}Color` && t.schema.styleSchema[`${e}Color`].propSchema === \"string\";\n}\nconst Zr = () => {\n  const e = V(), t = Ht(\"text\", e), n = Ht(\"background\", e), r = K(e), [i, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    t && e.getActiveStyles().textColor || \"default\"\n  ), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    n && e.getActiveStyles().backgroundColor || \"default\"\n  );\n  U(() => {\n    t && l(e.getActiveStyles().textColor || \"default\"), n && s(\n      e.getActiveStyles().backgroundColor || \"default\"\n    );\n  }, e);\n  const { ref: d, updateMaxHeight: f } = Xe(), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (C) => {\n      if (!t)\n        throw Error(\n          \"Tried to set text color, but style does not exist in editor schema.\"\n        );\n      e.focus(), C === \"default\" ? e.removeStyles({ textColor: C }) : e.addStyles({ textColor: C });\n    },\n    [e, t]\n  ), b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (C) => {\n      if (!n)\n        throw Error(\n          \"Tried to set background color, but style does not exist in editor schema.\"\n        );\n      e.focus(), C === \"default\" ? e.removeStyles({ backgroundColor: C }) : e.addStyles({ backgroundColor: C });\n    },\n    [n, e]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!t && !n)\n      return !1;\n    for (const C of r)\n      if (C.content !== void 0)\n        return !0;\n    return !1;\n  }, [n, r, t]) ? /* @__PURE__ */ o.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu, { withinPortal: !1, onOpen: f, children: [\n    /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Target, { children: /* @__PURE__ */ o.jsx(\n      P,\n      {\n        mainTooltip: \"Colors\",\n        icon: () => /* @__PURE__ */ o.jsx(\n          Ue,\n          {\n            textColor: i,\n            backgroundColor: c,\n            size: 20\n          }\n        )\n      }\n    ) }),\n    /* @__PURE__ */ o.jsx(\"div\", { ref: d, children: /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Dropdown, { children: /* @__PURE__ */ o.jsx(\n      on,\n      {\n        text: t ? {\n          color: i,\n          setColor: h\n        } : void 0,\n        background: n ? {\n          color: c,\n          setColor: b\n        } : void 0\n      }\n    ) }) })\n  ] }) : null;\n}, an = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ className: e, ...t }, n) => /* @__PURE__ */ o.jsx(\n  _mantine_core__WEBPACK_IMPORTED_MODULE_6__.Stack,\n  {\n    ...t,\n    className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(\"bn-toolbar-input-dropdown\", e || \"\"),\n    ref: n,\n    children: t.children\n  }\n)), zr = {\n  text: _mantine_core__WEBPACK_IMPORTED_MODULE_13__.TextInput,\n  file: _mantine_core__WEBPACK_IMPORTED_MODULE_14__.FileInput\n}, We = (e) => {\n  const t = e.icon, n = zr[e.type];\n  return /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_5__.Group, { children: /* @__PURE__ */ o.jsx(n, { size: \"xs\", icon: /* @__PURE__ */ o.jsx(t, {}), ...e.inputProps }) });\n}, ln = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({ url: e, text: t, update: n, ...r }, i) => {\n  const [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e), [s, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(t);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    c(e), d(t);\n  }, [t, e]);\n  const f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (C) => {\n      C.key === \"Enter\" && (C.preventDefault(), n(l, s));\n    },\n    [n, l, s]\n  ), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (C) => c(C.currentTarget.value),\n    []\n  ), b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (C) => d(C.currentTarget.value),\n    []\n  ), T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => n(l, s),\n    [n, l, s]\n  );\n  return /* @__PURE__ */ o.jsxs(an, { ...r, ref: i, children: [\n    /* @__PURE__ */ o.jsx(\n      We,\n      {\n        type: \"text\",\n        icon: tn,\n        inputProps: {\n          autoFocus: !0,\n          placeholder: \"Edit URL\",\n          value: l,\n          onKeyDown: f,\n          onChange: h,\n          onSubmit: T\n        }\n      }\n    ),\n    /* @__PURE__ */ o.jsx(\n      We,\n      {\n        type: \"text\",\n        icon: ce,\n        inputProps: {\n          placeholder: \"Edit Title\",\n          value: s,\n          onKeyDown: f,\n          onChange: b,\n          onSubmit: T\n        }\n      }\n    )\n  ] });\n}), sn = (e) => {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n(!1);\n  }, []), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    n(!0);\n  }, []);\n  return /* @__PURE__ */ o.jsxs(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_15__.Popover,\n    {\n      withinPortal: !1,\n      onOpen: () => {\n        i();\n      },\n      onClose: () => {\n        r();\n      },\n      zIndex: 1e4,\n      ...e,\n      children: [\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_15__.Popover.Target, { children: e.target }),\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_15__.Popover.Dropdown, { children: t ? e.dropdown : null })\n      ]\n    }\n  );\n}, Ur = () => {\n  const e = V(), t = K(e), [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e.getSelectedLinkUrl() || \"\"), [i, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e.getSelectedText());\n  U(() => {\n    l(e.getSelectedText() || \"\"), r(e.getSelectedLinkUrl() || \"\");\n  }, e);\n  const c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (d, f) => {\n      e.createLink(d, f), e.focus();\n    },\n    [e]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    for (const d of t)\n      if (d.content === void 0)\n        return !1;\n    return !0;\n  }, [t]) ? /* @__PURE__ */ o.jsx(\n    sn,\n    {\n      target: /* @__PURE__ */ o.jsx(\n        P,\n        {\n          mainTooltip: \"Create Link\",\n          secondaryTooltip: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.formatKeyboardShortcut)(\"Mod+K\"),\n          icon: tn\n        }\n      ),\n      dropdown: /* @__PURE__ */ o.jsx(ln, { url: n, text: i, update: c })\n    }\n  ) : null;\n}, $r = () => {\n  const e = V(), [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), r = K(e), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (r.length !== 1)\n      return;\n    const s = r[0];\n    if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockIsDefaultType)(\"image\", s, e))\n      return s;\n  }, [e, r]), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (s) => {\n      i && (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkDefaultBlockTypeInSchema)(\"image\", e) && s.key === \"Enter\" && (s.preventDefault(), e.updateBlock(i, {\n        type: \"image\",\n        props: {\n          caption: t\n        }\n      }));\n    },\n    [t, e, i]\n  ), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (s) => n(s.currentTarget.value),\n    []\n  );\n  return i ? /* @__PURE__ */ o.jsx(\n    sn,\n    {\n      target: /* @__PURE__ */ o.jsx(\n        P,\n        {\n          mainTooltip: \"Edit Caption\",\n          icon: ce,\n          isSelected: i.props.caption !== \"\"\n        }\n      ),\n      dropdown: /* @__PURE__ */ o.jsx(an, { children: /* @__PURE__ */ o.jsx(\n        We,\n        {\n          type: \"text\",\n          icon: ce,\n          inputProps: {\n            // TODO: weird pattern of props passing?\n            value: t,\n            autoFocus: !0,\n            placeholder: \"Edit Caption\",\n            onKeyDown: l,\n            defaultValue: i.props.caption,\n            onChange: c\n          }\n        }\n      ) })\n    }\n  ) : null;\n}, Wr = () => {\n  const e = V(), [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => e.canNestBlock()\n  );\n  U(() => {\n    e.canNestBlock(), n(e.canNestBlock());\n  }, e);\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    e.focus(), e.nestBlock();\n  }, [e]);\n  return /* @__PURE__ */ o.jsx(\n    P,\n    {\n      onClick: r,\n      isDisabled: !t,\n      mainTooltip: \"Nest Block\",\n      secondaryTooltip: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.formatKeyboardShortcut)(\"Tab\"),\n      icon: Mr\n    }\n  );\n}, qr = () => {\n  const e = V(), [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => e.canUnnestBlock()\n  );\n  U(() => {\n    n(e.canUnnestBlock());\n  }, e);\n  const r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    e.focus(), e.unnestBlock();\n  }, [e]);\n  return /* @__PURE__ */ o.jsx(\n    P,\n    {\n      onClick: r,\n      isDisabled: !t,\n      mainTooltip: \"Unnest Block\",\n      secondaryTooltip: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.formatKeyboardShortcut)(\"Shift+Tab\"),\n      icon: Er\n    }\n  );\n}, cn = (e) => {\n  const t = V(), [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    t.uploadFile !== void 0 ? \"upload\" : \"embed\"\n  ), [i, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    c && setTimeout(() => {\n      s(!1);\n    }, 3e3);\n  }, [c]);\n  const d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (D) => {\n      if (D === null)\n        return;\n      async function ne(F) {\n        if (l(!0), t.uploadFile !== void 0)\n          try {\n            const O = await t.uploadFile(F);\n            t.updateBlock(e.block, {\n              type: \"image\",\n              props: {\n                url: O\n              }\n            });\n          } catch {\n            s(!0);\n          } finally {\n            l(!1);\n          }\n      }\n      ne(D);\n    },\n    [t, e.block]\n  ), [f, h] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (D) => {\n      h(D.currentTarget.value);\n    },\n    []\n  ), T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (D) => {\n      D.key === \"Enter\" && (D.preventDefault(), t.updateBlock(e.block, {\n        type: \"image\",\n        props: {\n          url: f\n        }\n      }));\n    },\n    [t, e.block, f]\n  ), C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    t.updateBlock(e.block, {\n      type: \"image\",\n      props: {\n        url: f\n      }\n    });\n  }, [t, e.block, f]);\n  return /* @__PURE__ */ o.jsx(Ce, { className: \"bn-image-toolbar\", children: /* @__PURE__ */ o.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_16__.Tabs, { value: n, onChange: r, children: [\n    i && /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_17__.LoadingOverlay, { visible: i }),\n    /* @__PURE__ */ o.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_16__.Tabs.List, { children: [\n      t.uploadFile !== void 0 && /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_16__.Tabs.Tab, { value: \"upload\", \"data-test\": \"upload-tab\", children: \"Upload\" }),\n      /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_16__.Tabs.Tab, { value: \"embed\", \"data-test\": \"embed-tab\", children: \"Embed\" })\n    ] }),\n    t.uploadFile !== void 0 && /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_16__.Tabs.Panel, { className: \"bn-upload-image-panel\", value: \"upload\", children: /* @__PURE__ */ o.jsxs(\"div\", { children: [\n      /* @__PURE__ */ o.jsx(\n        _mantine_core__WEBPACK_IMPORTED_MODULE_14__.FileInput,\n        {\n          placeholder: \"Upload Image\",\n          size: \"xs\",\n          value: null,\n          onChange: d,\n          \"data-test\": \"upload-input\"\n        }\n      ),\n      c && /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_7__.Text, { c: \"red\", size: \"12px\", children: \"Error: Upload failed\" })\n    ] }) }),\n    /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_16__.Tabs.Panel, { className: \"bn-embed-image-panel\", value: \"embed\", children: /* @__PURE__ */ o.jsxs(\"div\", { children: [\n      /* @__PURE__ */ o.jsx(\n        _mantine_core__WEBPACK_IMPORTED_MODULE_13__.TextInput,\n        {\n          size: \"xs\",\n          placeholder: \"Enter URL\",\n          value: f,\n          onChange: b,\n          onKeyDown: T,\n          \"data-test\": \"embed-input\"\n        }\n      ),\n      /* @__PURE__ */ o.jsx(\n        _mantine_core__WEBPACK_IMPORTED_MODULE_9__.Button,\n        {\n          className: \"bn-embed-image-button\",\n          onClick: C,\n          size: \"xs\",\n          \"data-test\": \"embed-input-button\",\n          children: \"Embed Image\"\n        }\n      )\n    ] }) })\n  ] }) });\n}, Yr = () => {\n  const e = V(), t = K(e), [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    r(!1);\n  }, [t]);\n  const i = t.length === 1 ? t[0] : void 0;\n  return i === void 0 || i.type !== \"image\" || !(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockIsDefaultType)(\"image\", i, e) ? null : /* @__PURE__ */ o.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_15__.Popover, { withinPortal: !1, opened: n, position: \"bottom\", children: [\n    /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_15__.Popover.Target, { children: /* @__PURE__ */ o.jsx(\n      P,\n      {\n        onClick: () => r(!n),\n        isSelected: n,\n        mainTooltip: \"Replace Image\",\n        icon: Ir\n      }\n    ) }),\n    /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_15__.Popover.Dropdown, { children: /* @__PURE__ */ o.jsx(cn, { block: i }) })\n  ] });\n}, Kr = {\n  left: wr,\n  center: Sr,\n  right: Tr,\n  justify: jr\n}, Ae = (e) => {\n  const t = V(), n = K(t), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const c = n[0];\n    if ((0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockHasDefaultProp)(\"textAlignment\", c, t))\n      return c.props.textAlignment;\n  }, [t, n]), i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (c) => {\n      t.focus();\n      for (const s of n)\n        (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockTypeHasDefaultProp)(\"textAlignment\", s.type, t) && t.updateBlock(s, {\n          props: { textAlignment: c }\n        });\n    },\n    [t, n]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => !!n.find((c) => \"textAlignment\" in c.props), [n]) ? /* @__PURE__ */ o.jsx(\n    P,\n    {\n      onClick: () => i(e.textAlignment),\n      isSelected: r === e.textAlignment,\n      mainTooltip: e.textAlignment === \"justify\" ? \"Justify Text\" : \"Align Text \" + e.textAlignment.slice(0, 1).toUpperCase() + e.textAlignment.slice(1),\n      icon: Kr[e.textAlignment]\n    }\n  ) : null;\n};\nfunction Gr(e) {\n  const t = e.icon;\n  return /* @__PURE__ */ o.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Item,\n    {\n      onClick: e.onClick,\n      leftSection: t && /* @__PURE__ */ o.jsx(t, { size: 16 }),\n      rightSection: e.isSelected ? /* @__PURE__ */ o.jsx($e, { size: 20, className: \"bn-tick-icon\" }) : (\n        // Ensures space for tick even if item isn't currently selected.\n        /* @__PURE__ */ o.jsx(\"div\", { className: \"bn-tick-space\" })\n      ),\n      disabled: e.isDisabled,\n      children: e.text\n    },\n    e.text\n  );\n}\nfunction Jr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 20 20\", fill: \"currentColor\", \"aria-hidden\": \"true\" }, child: [{ tag: \"path\", attr: { fillRule: \"evenodd\", d: \"M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z\", clipRule: \"evenodd\" } }] })(e);\n}\nfunction Qr(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 20 20\", fill: \"currentColor\", \"aria-hidden\": \"true\" }, child: [{ tag: \"path\", attr: { fillRule: \"evenodd\", d: \"M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z\", clipRule: \"evenodd\" } }] })(e);\n}\nconst Xr = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((e, t) => {\n  const n = e.icon;\n  return /* @__PURE__ */ o.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_9__.Button,\n    {\n      onMouseDown: (r) => {\n        (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.isSafari)() && r.currentTarget.focus();\n      },\n      leftSection: n && /* @__PURE__ */ o.jsx(n, { size: 16 }),\n      rightSection: /* @__PURE__ */ o.jsx(Jr, {}),\n      size: \"xs\",\n      variant: \"subtle\",\n      disabled: e.isDisabled,\n      onClick: e.onClick,\n      ref: t,\n      children: e.text\n    }\n  );\n});\nfunction eo(e) {\n  const t = e.items.filter((i) => i.isSelected)[0], { ref: n, updateMaxHeight: r } = Xe();\n  return t ? /* @__PURE__ */ o.jsxs(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu,\n    {\n      withinPortal: !1,\n      transitionProps: {\n        exitDuration: 0\n      },\n      disabled: e.isDisabled,\n      onOpen: r,\n      children: [\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Target, { children: /* @__PURE__ */ o.jsx(\n          Xr,\n          {\n            text: t.text,\n            icon: t.icon,\n            isDisabled: t.isDisabled\n          }\n        ) }),\n        /* @__PURE__ */ o.jsx(\"div\", { ref: n, children: /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Dropdown, { children: e.items.map((i) => /* @__PURE__ */ o.jsx(Gr, { ...i }, i.text)) }) })\n      ]\n    }\n  ) : null;\n}\nconst to = [\n  {\n    name: \"Paragraph\",\n    type: \"paragraph\",\n    icon: ce,\n    isSelected: (e) => e.type === \"paragraph\"\n  },\n  {\n    name: \"Heading 1\",\n    type: \"heading\",\n    props: { level: 1 },\n    icon: Qt,\n    isSelected: (e) => e.type === \"heading\" && \"level\" in e.props && e.props.level === 1\n  },\n  {\n    name: \"Heading 2\",\n    type: \"heading\",\n    props: { level: 2 },\n    icon: Xt,\n    isSelected: (e) => e.type === \"heading\" && \"level\" in e.props && e.props.level === 2\n  },\n  {\n    name: \"Heading 3\",\n    type: \"heading\",\n    props: { level: 3 },\n    icon: en,\n    isSelected: (e) => e.type === \"heading\" && \"level\" in e.props && e.props.level === 3\n  },\n  {\n    name: \"Bullet List\",\n    type: \"bulletListItem\",\n    icon: rn,\n    isSelected: (e) => e.type === \"bulletListItem\"\n  },\n  {\n    name: \"Numbered List\",\n    type: \"numberedListItem\",\n    icon: nn,\n    isSelected: (e) => e.type === \"numberedListItem\"\n  }\n], no = (e) => {\n  const t = V(), n = K(t), [r, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(t.getTextCursorPosition().block), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (e.items || to).filter((d) => {\n    if (!(d.type in t.schema.blockSchema))\n      return !1;\n    for (const [f, h] of Object.entries(d.props || {})) {\n      const b = t.schema.blockSchema[d.type].propSchema;\n      if (!(f in b) || b[f].values !== void 0 && !b[f].values.includes(h))\n        return !1;\n    }\n    return !0;\n  }), [t, e.items]), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => l.find((d) => d.type === r.type) !== void 0,\n    [r.type, l]\n  ), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const d = (f) => {\n      t.focus();\n      for (const h of n)\n        t.updateBlock(h, {\n          type: f.type,\n          props: f.props\n        });\n    };\n    return l.map((f) => ({\n      text: f.name,\n      icon: f.icon,\n      onClick: () => d(f),\n      isSelected: f.isSelected(r)\n    }));\n  }, [r, l, t, n]);\n  return U(() => {\n    i(t.getTextCursorPosition().block);\n  }, t), c ? /* @__PURE__ */ o.jsx(eo, { items: s }) : null;\n}, ro = (e) => [\n  /* @__PURE__ */ o.jsx(\n    no,\n    {\n      items: e\n    },\n    \"blockTypeDropdown\"\n  ),\n  /* @__PURE__ */ o.jsx($r, {}, \"imageCaptionButton\"),\n  /* @__PURE__ */ o.jsx(Yr, {}, \"replaceImageButton\"),\n  /* @__PURE__ */ o.jsx(ke, { basicTextStyle: \"bold\" }, \"boldStyleButton\"),\n  /* @__PURE__ */ o.jsx(ke, { basicTextStyle: \"italic\" }, \"italicStyleButton\"),\n  /* @__PURE__ */ o.jsx(\n    ke,\n    {\n      basicTextStyle: \"underline\"\n    },\n    \"underlineStyleButton\"\n  ),\n  /* @__PURE__ */ o.jsx(ke, { basicTextStyle: \"strike\" }, \"strikeStyleButton\"),\n  /* @__PURE__ */ o.jsx(Ae, { textAlignment: \"left\" }, \"textAlignLeftButton\"),\n  /* @__PURE__ */ o.jsx(Ae, { textAlignment: \"center\" }, \"textAlignCenterButton\"),\n  /* @__PURE__ */ o.jsx(Ae, { textAlignment: \"right\" }, \"textAlignRightButton\"),\n  /* @__PURE__ */ o.jsx(Zr, {}, \"colorStyleButton\"),\n  /* @__PURE__ */ o.jsx(Wr, {}, \"nestBlockButton\"),\n  /* @__PURE__ */ o.jsx(qr, {}, \"unnestBlockButton\"),\n  /* @__PURE__ */ o.jsx(Ur, {}, \"createLinkButton\")\n], oo = (e) => /* @__PURE__ */ o.jsx(Ce, { children: e.children || ro(e.blockTypeDropdownItems) }), Et = (e) => {\n  switch (e) {\n    case \"left\":\n      return \"top-start\";\n    case \"center\":\n      return \"top\";\n    case \"right\":\n      return \"top-end\";\n    default:\n      return \"top-start\";\n  }\n}, ao = (e) => {\n  const t = V(), [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => {\n      const f = t.getTextCursorPosition().block;\n      return \"textAlignment\" in f.props ? Et(\n        f.props.textAlignment\n      ) : \"top-start\";\n    }\n  );\n  U(() => {\n    const f = t.getTextCursorPosition().block;\n    \"textAlignment\" in f.props ? r(\n      Et(\n        f.props.textAlignment\n      )\n    ) : r(\"top-start\");\n  }, t);\n  const i = te(\n    t.formattingToolbar.onUpdate.bind(t.formattingToolbar)\n  ), { isMounted: l, ref: c, style: s } = ge(\n    (i == null ? void 0 : i.show) || !1,\n    (i == null ? void 0 : i.referencePos) || null,\n    3e3,\n    {\n      placement: n,\n      middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_18__.offset)(10), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_19__.flip)()]\n    }\n  );\n  if (!l || !i)\n    return null;\n  const d = e.formattingToolbar || oo;\n  return /* @__PURE__ */ o.jsx(\"div\", { ref: c, style: s, children: /* @__PURE__ */ o.jsx(d, {}) });\n}, io = (e) => {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  if (e.children)\n    return /* @__PURE__ */ o.jsx(Ce, { children: e.children });\n  const {\n    text: i,\n    url: l,\n    deleteHyperlink: c,\n    editHyperlink: s,\n    startHideTimer: d,\n    stopHideTimer: f\n  } = e;\n  return t ? /* @__PURE__ */ o.jsx(\n    ln,\n    {\n      url: l,\n      text: i,\n      update: s,\n      onBlur: (h) => setTimeout(() => {\n        var b;\n        (b = r.current) != null && b.contains(h.relatedTarget) || n(!1);\n      }, 500),\n      ref: r\n    }\n  ) : /* @__PURE__ */ o.jsxs(Ce, { onMouseEnter: f, onMouseLeave: d, children: [\n    /* @__PURE__ */ o.jsx(\n      P,\n      {\n        mainTooltip: \"Edit\",\n        isSelected: !1,\n        onClick: () => n(!0),\n        children: \"Edit Link\"\n      }\n    ),\n    /* @__PURE__ */ o.jsx(\n      P,\n      {\n        mainTooltip: \"Open in new tab\",\n        isSelected: !1,\n        onClick: () => {\n          window.open(l, \"_blank\");\n        },\n        icon: Or\n      }\n    ),\n    /* @__PURE__ */ o.jsx(\n      P,\n      {\n        mainTooltip: \"Remove link\",\n        isSelected: !1,\n        onClick: c,\n        icon: Vr\n      }\n    )\n  ] });\n}, lo = (e) => {\n  const t = V(), n = {\n    deleteHyperlink: t.hyperlinkToolbar.deleteHyperlink,\n    editHyperlink: t.hyperlinkToolbar.editHyperlink,\n    startHideTimer: t.hyperlinkToolbar.startHideTimer,\n    stopHideTimer: t.hyperlinkToolbar.stopHideTimer\n  }, r = te(\n    t.hyperlinkToolbar.onUpdate.bind(t.hyperlinkToolbar)\n  ), { isMounted: i, ref: l, style: c } = ge(\n    (r == null ? void 0 : r.show) || !1,\n    (r == null ? void 0 : r.referencePos) || null,\n    4e3,\n    {\n      placement: \"top-start\",\n      middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_18__.offset)(10), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_19__.flip)()]\n    }\n  );\n  if (!i || !r)\n    return null;\n  const { show: s, referencePos: d, ...f } = r, h = e.hyperlinkToolbar || io;\n  return /* @__PURE__ */ o.jsx(\"div\", { ref: l, style: c, children: /* @__PURE__ */ o.jsx(h, { ...f, ...n }) });\n}, so = (e) => {\n  const t = V();\n  if (!t.imageToolbar)\n    throw new Error(\n      \"ImageToolbarController can only be used when BlockNote editor schema contains image block\"\n    );\n  const n = te(\n    t.imageToolbar.onUpdate.bind(t.imageToolbar)\n  ), { isMounted: r, ref: i, style: l } = ge(\n    (n == null ? void 0 : n.show) || !1,\n    (n == null ? void 0 : n.referencePos) || null,\n    5e3,\n    {\n      placement: \"bottom\",\n      middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_18__.offset)(10), (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_19__.flip)()]\n    }\n  );\n  if (!r || !n)\n    return null;\n  const { show: c, referencePos: s, ...d } = n, f = e.imageToolbar || cn;\n  return /* @__PURE__ */ o.jsx(\"div\", { ref: i, style: l, children: /* @__PURE__ */ o.jsx(f, { ...d }) });\n};\nfunction co(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 1024 1024\" }, child: [{ tag: \"path\", attr: { d: \"M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8Z\" } }, { tag: \"path\", attr: { d: \"M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8Z\" } }] })(e);\n}\nconst un = (e) => /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_10__.ActionIcon, { size: 24, children: e.children }), uo = (e) => /* @__PURE__ */ o.jsx(un, { children: /* @__PURE__ */ o.jsx(\n  co,\n  {\n    size: 24,\n    onClick: e.addBlock,\n    \"data-test\": \"dragHandleAdd\"\n  }\n) });\nfunction dn(e) {\n  return S({ tag: \"svg\", attr: { viewBox: \"0 0 24 24\" }, child: [{ tag: \"path\", attr: { fill: \"none\", d: \"M0 0h24v24H0V0z\" } }, { tag: \"path\", attr: { d: \"M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\" } }] })(e);\n}\nconst fn = (e) => {\n  const { children: t, ...n } = e;\n  return /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Item, { ...n, children: t });\n}, fo = (e) => {\n  const t = V(), [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), { ref: i, updateMaxHeight: l } = Xe(), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    c.current && clearTimeout(c.current), c.current = setTimeout(() => {\n      r(!1);\n    }, 250);\n  }, []), d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    c.current && clearTimeout(c.current), n || l(), r(!0);\n  }, [n, l]);\n  return !(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockTypeHasDefaultProp)(\"textColor\", e.block.type, t) && !(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockTypeHasDefaultProp)(\"backgroundColor\", e.block.type, t) ? null : /* @__PURE__ */ o.jsx(\n    fn,\n    {\n      onMouseLeave: s,\n      onMouseOver: d,\n      children: /* @__PURE__ */ o.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu, { withinPortal: !1, opened: n, position: \"right\", children: [\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Target, { children: /* @__PURE__ */ o.jsxs(\"div\", { style: { display: \"flex\", alignItems: \"center\" }, children: [\n          /* @__PURE__ */ o.jsx(\"div\", { style: { flex: 1 }, children: e.children }),\n          /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_11__.Box, { style: { display: \"flex\", alignItems: \"center\" }, children: /* @__PURE__ */ o.jsx(Qr, { size: 15 }) })\n        ] }) }),\n        /* @__PURE__ */ o.jsx(\"div\", { ref: i, children: /* @__PURE__ */ o.jsx(\n          _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Dropdown,\n          {\n            onMouseLeave: s,\n            onMouseOver: d,\n            style: { marginLeft: \"5px\" },\n            children: /* @__PURE__ */ o.jsx(\n              on,\n              {\n                iconSize: 18,\n                text: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockTypeHasDefaultProp)(\n                  \"textColor\",\n                  e.block.type,\n                  t\n                ) && (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockHasDefaultProp)(\"textColor\", e.block, t) ? {\n                  color: e.block.props.textColor,\n                  setColor: (f) => t.updateBlock(e.block, {\n                    type: e.block.type,\n                    props: { textColor: f }\n                  })\n                } : void 0,\n                background: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockTypeHasDefaultProp)(\n                  \"backgroundColor\",\n                  e.block.type,\n                  t\n                ) && (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.checkBlockHasDefaultProp)(\"backgroundColor\", e.block, t) ? {\n                  color: e.block.props.backgroundColor,\n                  setColor: (f) => t.updateBlock(e.block, {\n                    props: { backgroundColor: f }\n                  })\n                } : void 0\n              }\n            )\n          }\n        ) })\n      ] })\n    }\n  );\n}, go = (e) => {\n  const t = V();\n  return /* @__PURE__ */ o.jsx(fn, { onClick: () => t.removeBlocks([e.block]), children: e.children });\n}, ho = (e) => /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Dropdown, { className: \"bn-drag-handle-menu\", children: e.children || /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n  /* @__PURE__ */ o.jsx(go, { ...e, children: \"Delete\" }),\n  /* @__PURE__ */ o.jsx(fo, { ...e, children: \"Colors\" })\n] }) }), mo = (e) => {\n  const t = e.dragHandleMenu || ho;\n  return /* @__PURE__ */ o.jsxs(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu,\n    {\n      withinPortal: !1,\n      trigger: \"click\",\n      onOpen: e.freezeMenu,\n      onClose: e.unfreezeMenu,\n      width: 100,\n      position: \"left\",\n      children: [\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Target, { children: /* @__PURE__ */ o.jsx(\n          \"div\",\n          {\n            className: \"bn-drag-handle\",\n            draggable: \"true\",\n            onDragStart: e.blockDragStart,\n            onDragEnd: e.blockDragEnd,\n            children: /* @__PURE__ */ o.jsx(un, { children: /* @__PURE__ */ o.jsx(dn, { size: 24, \"data-test\": \"dragHandle\" }) })\n          }\n        ) }),\n        /* @__PURE__ */ o.jsx(t, { block: e.block })\n      ]\n    }\n  );\n}, bo = (e) => {\n  const { addBlock: t, ...n } = e;\n  return /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_5__.Group, { className: \"bn-side-menu\", gap: 0, children: e.children || /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n    /* @__PURE__ */ o.jsx(uo, { addBlock: t }),\n    /* @__PURE__ */ o.jsx(mo, { ...n })\n  ] }) });\n}, xo = (e) => {\n  const t = V(), n = {\n    addBlock: t.sideMenu.addBlock,\n    blockDragStart: t.sideMenu.blockDragStart,\n    blockDragEnd: t.sideMenu.blockDragEnd,\n    freezeMenu: t.sideMenu.freezeMenu,\n    unfreezeMenu: t.sideMenu.unfreezeMenu\n  }, r = te(\n    t.sideMenu.onUpdate.bind(t.sideMenu)\n  ), { isMounted: i, ref: l, style: c } = ge(\n    (r == null ? void 0 : r.show) || !1,\n    (r == null ? void 0 : r.referencePos) || null,\n    1e3,\n    {\n      placement: \"left\"\n    }\n  );\n  if (!i || !r)\n    return null;\n  const { show: s, referencePos: d, ...f } = r, h = e.sideMenu || bo;\n  return /* @__PURE__ */ o.jsx(\"div\", { ref: l, style: c, children: /* @__PURE__ */ o.jsx(h, { ...f, ...n }) });\n}, vo = {\n  \"Heading 1\": Qt,\n  \"Heading 2\": Xt,\n  \"Heading 3\": en,\n  \"Numbered List\": nn,\n  \"Bullet List\": rn,\n  Paragraph: ce,\n  Table: Lr,\n  Image: _r\n};\nfunction gn(e) {\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.getDefaultSlashMenuItems)(e).map((t) => {\n    const n = vo[t.title];\n    return {\n      ...t,\n      icon: /* @__PURE__ */ o.jsx(n, { size: 18 })\n    };\n  });\n}\nfunction po(e, t, n, r = 3) {\n  const i = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t !== void 0 && (e.length > 0 ? i.current = t.length : t.length - i.current > r && n());\n  }, [n, r, e.length, t]);\n}\nfunction ko(e, t) {\n  const [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [i, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(), s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const d = e;\n    c.current = e, l(!0), t(e).then((f) => {\n      c.current === d && (r(f), l(!1), s.current = d);\n    });\n  }, [e, t]), {\n    items: n || [],\n    // The query that was used to retrieve the last set of items may not be the\n    // same as the current query as the items from the current query may not\n    // have been retrieved yet. This is useful when using the returns of this\n    // hook in other hooks.\n    usedQuery: s.current,\n    loadingState: s.current === void 0 ? \"loading-initial\" : i ? \"loading\" : \"loaded\"\n  };\n}\nfunction yo(e, t, n, r) {\n  const [i, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const c = (s) => s.key === \"ArrowUp\" ? (s.preventDefault(), t.length && l((i - 1 + t.length) % t.length), !0) : s.key === \"ArrowDown\" ? (s.preventDefault(), t.length && l((i + 1) % t.length), !0) : s.key === \"Enter\" ? (s.preventDefault(), t.length && (r == null || r(t[i])), !0) : s.key === \"Escape\" ? (s.preventDefault(), n(), !0) : !1;\n    return e.domElement.addEventListener(\n      \"keydown\",\n      c,\n      !0\n    ), () => {\n      e.domElement.removeEventListener(\n        \"keydown\",\n        c,\n        !0\n      );\n    };\n  }, [n, e.domElement, t, i, r]), i;\n}\nfunction Co(e) {\n  const t = V(), {\n    getItems: n,\n    suggestionMenuComponent: r,\n    query: i,\n    clearQuery: l,\n    closeMenu: c,\n    onItemClick: s\n  } = e, d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (D) => {\n      c(), l(), s == null || s(D);\n    },\n    [s, c, l]\n  ), { items: f, usedQuery: h, loadingState: b } = ko(\n    i,\n    n\n  );\n  po(f, h, c);\n  const T = yo(\n    t,\n    f,\n    c,\n    d\n  ), C = r;\n  return /* @__PURE__ */ o.jsx(\n    C,\n    {\n      items: f,\n      onItemClick: d,\n      loadingState: b,\n      selectedIndex: T\n    }\n  );\n}\nconst So = 5;\nfunction jo(e) {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  function n() {\n    var c;\n    const i = e.isSelected, l = (c = t.current) == null ? void 0 : c.matches(\":hover\");\n    return i || l;\n  }\n  function r() {\n    var i, l;\n    n() ? (i = t.current) == null || i.setAttribute(\"data-hovered\", \"true\") : (l = t.current) == null || l.removeAttribute(\"data-hovered\");\n  }\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    r(), n() && t.current && t.current.getBoundingClientRect().left > So && t.current.scrollIntoView({\n      behavior: \"smooth\",\n      block: \"nearest\"\n    });\n  }), /* @__PURE__ */ o.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Item,\n    {\n      className: \"bn-slash-menu-item\",\n      onClick: e.onClick,\n      closeMenuOnClick: !1,\n      onMouseLeave: () => {\n        setTimeout(() => {\n          r();\n        }, 1);\n      },\n      leftSection: e.icon,\n      rightSection: e.badge && /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_20__.Badge, { size: \"xs\", children: e.badge }),\n      ref: t,\n      children: /* @__PURE__ */ o.jsxs(_mantine_core__WEBPACK_IMPORTED_MODULE_6__.Stack, { children: [\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_7__.Text, { lh: \"20px\", size: \"14px\", fw: 500, children: e.title }),\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_7__.Text, { lh: \"16px\", size: \"10px\", children: e.subtext })\n      ] })\n    }\n  );\n}\nfunction wo(e) {\n  const { items: t, loadingState: n, selectedIndex: r, onItemClick: i } = e, l = n === \"loading-initial\" || n === \"loading\" ? /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_21__.Loader, { className: \"bn-slash-menu-loader\", type: \"dots\" }) : null, c = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let s;\n    const d = [];\n    for (let f = 0; f < t.length; f++) {\n      const h = t[f];\n      h.group !== s && (s = h.group, d.push(\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Label, { children: s }, s)\n      )), d.push(\n        /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\n          jo,\n          {\n            ...h,\n            isSelected: f === r,\n            key: h.title,\n            onClick: () => i == null ? void 0 : i(h)\n          }\n        )\n      );\n    }\n    return d;\n  }, [t, r, i]);\n  return /* @__PURE__ */ o.jsx(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu,\n    {\n      withinPortal: !1,\n      trapFocus: !1,\n      defaultOpened: !0,\n      trigger: \"hover\",\n      closeDelay: 1e7,\n      children: /* @__PURE__ */ o.jsxs(\n        _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Dropdown,\n        {\n          onMouseDown: (s) => s.preventDefault(),\n          className: \"bn-slash-menu\",\n          children: [\n            c,\n            react__WEBPACK_IMPORTED_MODULE_0__.Children.count(c) === 0 && (e.loadingState === \"loading\" || e.loadingState === \"loaded\") && /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Item, { children: \"No match found\" }),\n            l\n          ]\n        }\n      )\n    }\n  );\n}\nfunction To(e) {\n  const t = V(), { triggerCharacter: n, suggestionMenuComponent: r } = e;\n  let { onItemClick: i, getItems: l } = e;\n  i || (i = (b) => {\n    b.onItemClick(t);\n  });\n  const c = {\n    closeMenu: t.suggestionMenus.closeMenu,\n    clearQuery: t.suggestionMenus.clearQuery\n  }, s = te(\n    (b) => t.suggestionMenus.onUpdate.bind(t.suggestionMenus)(\n      n,\n      b\n    )\n  ), { isMounted: d, ref: f, style: h } = ge(\n    (s == null ? void 0 : s.show) || !1,\n    (s == null ? void 0 : s.referencePos) || null,\n    2e3,\n    {\n      placement: \"bottom-start\",\n      middleware: [\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_18__.offset)(10),\n        // Flips the menu placement to maximize the space available, and prevents\n        // the menu from being cut off by the confines of the screen.\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_19__.flip)(),\n        (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_19__.size)({\n          apply({ availableHeight: b, elements: T }) {\n            Object.assign(T.floating.style, {\n              maxHeight: `${b - 10}px`\n            });\n          }\n        })\n      ]\n    }\n  );\n  return !d || !s ? null : (l || (l = async (b) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.filterSuggestionItems)(\n    gn(t),\n    b\n  )), /* @__PURE__ */ o.jsx(\"div\", { ref: f, style: h, children: /* @__PURE__ */ o.jsx(\n    Co,\n    {\n      query: s.query,\n      closeMenu: c.closeMenu,\n      clearQuery: c.clearQuery,\n      getItems: l,\n      suggestionMenuComponent: r || wo,\n      onItemClick: i\n    }\n  ) }));\n}\nfunction Ho(e, t, n) {\n  return n && n.draggedCellOrientation === \"row\" ? new DOMRect(\n    t.x,\n    n.mousePos,\n    t.width,\n    0\n  ) : new DOMRect(\n    t.x,\n    e.y,\n    t.width,\n    e.height\n  );\n}\nfunction Eo(e, t, n) {\n  return n && n.draggedCellOrientation === \"col\" ? new DOMRect(\n    n.mousePos,\n    t.y,\n    0,\n    t.height\n  ) : new DOMRect(\n    e.x,\n    t.y,\n    e.width,\n    t.height\n  );\n}\nfunction Mt(e, t, n, r, i) {\n  const { refs: l, update: c, context: s, floatingStyles: d } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useFloating)({\n    open: t,\n    placement: e === \"row\" ? \"left\" : \"top\",\n    middleware: [(0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_18__.offset)(e === \"row\" ? -10 : -12)]\n  }), { isMounted: f, styles: h } = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_4__.useTransitionStyles)(s);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    c();\n  }, [n, r, c]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n === null || r === null || l.setReference({\n      getBoundingClientRect: () => (e === \"row\" ? Ho : Eo)(n, r, i)\n    });\n  }, [i, e, n, r, l]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      isMounted: f,\n      ref: l.setFloating,\n      style: {\n        display: \"flex\",\n        ...h,\n        ...d,\n        zIndex: 1e4\n      }\n    }),\n    [d, f, l.setFloating, h]\n  );\n}\nfunction Mo(e, t, n, r) {\n  const i = Mt(\n    \"row\",\n    e,\n    t,\n    n,\n    r\n  ), l = Mt(\n    \"col\",\n    e,\n    t,\n    n,\n    r\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => ({\n      rowHandle: i,\n      colHandle: l\n    }),\n    [l, i]\n  );\n}\nconst Ro = (e) => /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Dropdown, { className: \"bn-table-handle-menu\", children: e.children }), Te = (e) => {\n  const { children: t, ...n } = e;\n  return /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Item, { ...n, children: t });\n}, Vo = (e) => /* @__PURE__ */ o.jsx(\n  Te,\n  {\n    onClick: () => {\n      const t = e.block.content.rows[e.index].cells.map(\n        () => []\n      ), n = [...e.block.content.rows];\n      n.splice(e.index + (e.side === \"below\" ? 1 : 0), 0, {\n        cells: t\n      }), e.editor.updateBlock(e.block, {\n        type: \"table\",\n        content: {\n          type: \"tableContent\",\n          rows: n\n        }\n      });\n    },\n    children: `Add row ${e.side}`\n  }\n), Bo = (e) => /* @__PURE__ */ o.jsx(\n  Te,\n  {\n    onClick: () => {\n      const t = {\n        type: \"tableContent\",\n        rows: e.block.content.rows.map((n) => {\n          const r = [...n.cells];\n          return r.splice(e.index + (e.side === \"right\" ? 1 : 0), 0, []), { cells: r };\n        })\n      };\n      e.editor.updateBlock(e.block, {\n        type: \"table\",\n        content: t\n      });\n    },\n    children: `Add column ${e.side}`\n  }\n), Rt = (e) => e.orientation === \"row\" ? /* @__PURE__ */ o.jsx(Vo, { ...e, side: e.side }) : /* @__PURE__ */ o.jsx(Bo, { ...e, side: e.side }), Lo = (e) => /* @__PURE__ */ o.jsx(\n  Te,\n  {\n    onClick: () => {\n      const t = {\n        type: \"tableContent\",\n        rows: e.block.content.rows.filter(\n          (n, r) => r !== e.index\n        )\n      };\n      e.editor.updateBlock(e.block, {\n        type: \"table\",\n        content: t\n      });\n    },\n    children: \"Delete row\"\n  }\n), Do = (e) => /* @__PURE__ */ o.jsx(\n  Te,\n  {\n    onClick: () => {\n      const t = {\n        type: \"tableContent\",\n        rows: e.block.content.rows.map((n) => ({\n          cells: n.cells.filter((r, i) => i !== e.index)\n        }))\n      };\n      e.editor.updateBlock(e.block, {\n        type: \"table\",\n        content: t\n      });\n    },\n    children: \"Delete column\"\n  }\n), _o = (e) => e.orientation === \"row\" ? /* @__PURE__ */ o.jsx(Lo, { ...e }) : /* @__PURE__ */ o.jsx(Do, { ...e }), Io = (e) => /* @__PURE__ */ o.jsxs(Ro, { children: [\n  /* @__PURE__ */ o.jsx(\n    _o,\n    {\n      orientation: e.orientation,\n      editor: e.editor,\n      block: e.block,\n      index: e.index\n    }\n  ),\n  /* @__PURE__ */ o.jsx(\n    Rt,\n    {\n      orientation: e.orientation,\n      editor: e.editor,\n      block: e.block,\n      index: e.index,\n      side: e.orientation === \"row\" ? \"above\" : \"left\"\n    }\n  ),\n  /* @__PURE__ */ o.jsx(\n    Rt,\n    {\n      orientation: e.orientation,\n      editor: e.editor,\n      block: e.block,\n      index: e.index,\n      side: e.orientation === \"row\" ? \"below\" : \"right\"\n    }\n  )\n] }), Oo = (e) => {\n  const t = e.tableHandleMenu || Io, [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  return /* @__PURE__ */ o.jsxs(\n    _mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu,\n    {\n      withinPortal: !1,\n      trigger: \"click\",\n      onOpen: () => {\n        e.freezeHandles(), e.hideOtherSide();\n      },\n      onClose: () => {\n        e.unfreezeHandles(), e.showOtherSide();\n      },\n      position: \"right\",\n      children: [\n        /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_12__.Menu.Target, { children: /* @__PURE__ */ o.jsx(\n          \"div\",\n          {\n            className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(\n              \"bn-table-handle\",\n              n ? \"bn-table-handle-dragging\" : \"\"\n            ),\n            draggable: \"true\",\n            onDragStart: (i) => {\n              r(!0), e.dragStart(i);\n            },\n            onDragEnd: () => {\n              e.dragEnd(), r(!1);\n            },\n            style: e.orientation === \"column\" ? { transform: \"rotate(0.25turn)\" } : void 0,\n            children: e.children\n          }\n        ) }),\n        /* @__PURE__ */ o.jsx(\n          t,\n          {\n            orientation: e.orientation,\n            editor: e.editor,\n            block: e.block,\n            index: e.index\n          }\n        )\n      ]\n    }\n  );\n}, Po = (e) => /* @__PURE__ */ o.jsx(Oo, { ...e, children: /* @__PURE__ */ o.jsx(dn, { size: 24, \"data-test\": \"tableHandle\" }) }), Ao = (e) => {\n  var b, T;\n  const t = V();\n  if (!t.tableHandles)\n    throw new Error(\n      \"TableHandlesController can only be used when BlockNote editor schema contains table block\"\n    );\n  const n = {\n    rowDragStart: t.tableHandles.rowDragStart,\n    colDragStart: t.tableHandles.colDragStart,\n    dragEnd: t.tableHandles.dragEnd,\n    freezeHandles: t.tableHandles.freezeHandles,\n    unfreezeHandles: t.tableHandles.unfreezeHandles\n  }, r = te(\n    t.tableHandles.onUpdate.bind(t.tableHandles)\n  ), { rowHandle: i, colHandle: l } = Mo(\n    (r == null ? void 0 : r.show) || !1,\n    (r == null ? void 0 : r.referencePosCell) || null,\n    (r == null ? void 0 : r.referencePosTable) || null,\n    r != null && r.draggingState ? {\n      draggedCellOrientation: (b = r == null ? void 0 : r.draggingState) == null ? void 0 : b.draggedCellOrientation,\n      mousePos: (T = r == null ? void 0 : r.draggingState) == null ? void 0 : T.mousePos\n    } : void 0\n  ), [c, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [d, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1);\n  if (!i.isMounted || !l.isMounted || !r)\n    return null;\n  const h = e.tableHandle || Po;\n  return /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n    !c && /* @__PURE__ */ o.jsx(\"div\", { ref: i.ref, style: i.style, children: /* @__PURE__ */ o.jsx(\n      h,\n      {\n        editor: t,\n        orientation: \"row\",\n        showOtherSide: () => f(!1),\n        hideOtherSide: () => f(!0),\n        index: r.rowIndex,\n        block: r.block,\n        dragStart: n.rowDragStart,\n        dragEnd: n.dragEnd,\n        freezeHandles: n.freezeHandles,\n        unfreezeHandles: n.unfreezeHandles\n      }\n    ) }),\n    !d && /* @__PURE__ */ o.jsx(\"div\", { ref: l.ref, style: l.style, children: /* @__PURE__ */ o.jsx(\n      h,\n      {\n        editor: t,\n        orientation: \"column\",\n        showOtherSide: () => s(!1),\n        hideOtherSide: () => s(!0),\n        index: r.colIndex,\n        block: r.block,\n        dragStart: n.colDragStart,\n        dragEnd: n.dragEnd,\n        freezeHandles: n.freezeHandles,\n        unfreezeHandles: n.unfreezeHandles\n      }\n    ) })\n  ] });\n};\nfunction Fo(e) {\n  const t = V();\n  if (!t)\n    throw new Error(\n      \"BlockNoteDefaultUI must be used within a BlockNoteContext.Provider\"\n    );\n  return /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n    e.formattingToolbar !== !1 && /* @__PURE__ */ o.jsx(ao, {}),\n    e.hyperlinkToolbar !== !1 && /* @__PURE__ */ o.jsx(lo, {}),\n    e.slashMenu !== !1 && /* @__PURE__ */ o.jsx(\n      To,\n      {\n        getItems: async (n) => (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.filterSuggestionItems)(gn(t), n),\n        onItemClick: (n) => {\n          n.onItemClick();\n        },\n        triggerCharacter: \"/\"\n      }\n    ),\n    e.sideMenu !== !1 && /* @__PURE__ */ o.jsx(xo, {}),\n    t.imageToolbar && e.imageToolbar !== !1 && /* @__PURE__ */ o.jsx(so, {}),\n    t.tableHandles && e.tableHandles !== !1 && /* @__PURE__ */ o.jsx(Ao, {})\n  ] });\n}\nconst hn = (e, t, n = !1) => {\n  const r = [];\n  function i(l, c = \"--bn\") {\n    for (const s in l) {\n      const d = s.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase(), f = `${c}-${d}`;\n      typeof l[s] != \"object\" ? (typeof l[s] == \"number\" && (l[s] = `${l[s]}px`), n ? t.style.removeProperty(f) : t.style.setProperty(f, l[s].toString())) : i(l[s], f);\n    }\n  }\n  return i(e), r;\n}, Vt = (e, t) => hn(e, t), No = {\n  colors: {\n    editor: {\n      text: void 0,\n      background: void 0\n    },\n    menu: {\n      text: void 0,\n      background: void 0\n    },\n    tooltip: {\n      text: void 0,\n      background: void 0\n    },\n    hovered: {\n      text: void 0,\n      background: void 0\n    },\n    selected: {\n      text: void 0,\n      background: void 0\n    },\n    disabled: {\n      text: void 0,\n      background: void 0\n    },\n    shadow: void 0,\n    border: void 0,\n    sideMenu: void 0,\n    highlights: {\n      gray: {\n        text: void 0,\n        background: void 0\n      },\n      brown: {\n        text: void 0,\n        background: void 0\n      },\n      red: {\n        text: void 0,\n        background: void 0\n      },\n      orange: {\n        text: void 0,\n        background: void 0\n      },\n      yellow: {\n        text: void 0,\n        background: void 0\n      },\n      green: {\n        text: void 0,\n        background: void 0\n      },\n      blue: {\n        text: void 0,\n        background: void 0\n      },\n      purple: {\n        text: void 0,\n        background: void 0\n      },\n      pink: {\n        text: void 0,\n        background: void 0\n      }\n    }\n  },\n  borderRadius: void 0,\n  fontFamily: void 0\n}, Zo = (e) => hn(No, e, !0);\nfunction zo(e) {\n  return (t) => {\n    e.forEach((n) => {\n      typeof n == \"function\" ? n(t) : n != null && (n.current = t);\n    });\n  };\n}\nconst Uo = ({\n  renderers: e\n}) => /* @__PURE__ */ o.jsx(o.Fragment, { children: Object.entries(e).map(([t, n]) => (0,react_dom__WEBPACK_IMPORTED_MODULE_3__.createPortal)(n.reactElement, n.element, t)) });\nfunction $o(e) {\n  const [t, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (e.editor._tiptapEditor.contentComponent = {\n    setRenderer(r, i) {\n      n((l) => ({ ...l, [r]: i }));\n    },\n    removeRenderer(r) {\n      n((i) => {\n        const l = { ...i };\n        return delete l[r], l;\n      });\n    }\n  }, queueMicrotask(() => {\n    e.editor._tiptapEditor.createNodeViews();\n  }), () => {\n    e.editor._tiptapEditor.contentComponent = null;\n  }), [e.editor._tiptapEditor]), /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n    /* @__PURE__ */ o.jsx(Uo, { renderers: t }),\n    e.children\n  ] });\n}\nconst Wo = {\n  // Removes button press effect\n  activeClassName: \"\"\n}, Bt = () => {\n};\nfunction qo(e, t) {\n  const {\n    editor: n,\n    className: r,\n    theme: i,\n    children: l,\n    editable: c,\n    onSelectionChange: s,\n    onChange: d,\n    formattingToolbar: f,\n    hyperlinkToolbar: h,\n    slashMenu: b,\n    sideMenu: T,\n    imageToolbar: C,\n    tableHandles: D,\n    ...ne\n  } = e, F = ee(), O = (0,use_prefers_color_scheme__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(), M = (F == null ? void 0 : F.colorSchemePreference) || O, [He, $] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0), he = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (W) => {\n      if (W) {\n        if (Zo(W), i === \"light\") {\n          $(\"light\");\n          return;\n        }\n        if (i === \"dark\") {\n          $(\"dark\");\n          return;\n        }\n        if (typeof i == \"object\") {\n          if (\"light\" in i && \"dark\" in i) {\n            Vt(\n              i[M === \"dark\" ? \"dark\" : \"light\"],\n              W\n            ), $(\n              M === \"dark\" ? \"dark\" : \"light\"\n            );\n            return;\n          }\n          Vt(i, W), $(void 0);\n          return;\n        }\n        $(M === \"dark\" ? \"dark\" : \"light\");\n      }\n    },\n    [M, i]\n  );\n  Je(d || Bt, n), Qe(s || Bt, n), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    n.isEditable = c !== !1;\n  }, [c, n]);\n  const Ee = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => /* @__PURE__ */ o.jsxs(o.Fragment, { children: [\n    l,\n    /* @__PURE__ */ o.jsx(\n      Fo,\n      {\n        formattingToolbar: f,\n        hyperlinkToolbar: h,\n        slashMenu: b,\n        sideMenu: T,\n        imageToolbar: C,\n        tableHandles: D\n      }\n    )\n  ] }), [\n    l,\n    f,\n    h,\n    C,\n    T,\n    b,\n    D\n  ]), Me = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    ...F,\n    editor: n\n  }), [F, n]), Re = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => zo([he, n._tiptapEditor.mount, t]), [he, n._tiptapEditor.mount, t]);\n  return (\n    // `cssVariablesSelector` scopes Mantine CSS variables to only the editor,\n    // as proposed here:  https://github.com/orgs/mantinedev/discussions/5685\n    /* @__PURE__ */ o.jsx(_mantine_core__WEBPACK_IMPORTED_MODULE_22__.MantineProvider, { theme: Wo, cssVariablesSelector: \".bn-container\", children: /* @__PURE__ */ o.jsx(Kt.Provider, { value: Me, children: /* @__PURE__ */ o.jsx($o, { editor: n, children: /* @__PURE__ */ o.jsx(\n      \"div\",\n      {\n        className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(\"bn-container\", r || \"\"),\n        \"data-color-scheme\": He,\n        ...ne,\n        ref: Re,\n        children: Ee\n      }\n    ) }) }) })\n  );\n}\nconst oa = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(\n  qo\n), y = [\n  \"#FFFFFF\",\n  \"#EFEFEF\",\n  \"#CFCFCF\",\n  \"#AFAFAF\",\n  \"#7F7F7F\",\n  \"#3F3F3F\",\n  \"#1F1F1F\",\n  \"#161616\",\n  \"#0F0F0F\",\n  \"#000000\"\n], Lt = {\n  colors: {\n    editor: {\n      text: y[5],\n      background: y[0]\n    },\n    menu: {\n      text: y[5],\n      background: y[0]\n    },\n    tooltip: {\n      text: y[5],\n      background: y[1]\n    },\n    hovered: {\n      text: y[5],\n      background: y[1]\n    },\n    selected: {\n      text: y[0],\n      background: y[5]\n    },\n    disabled: {\n      text: y[3],\n      background: y[1]\n    },\n    shadow: y[2],\n    border: y[1],\n    sideMenu: y[2],\n    highlights: {\n      gray: {\n        text: \"#9b9a97\",\n        background: \"#ebeced\"\n      },\n      brown: {\n        text: \"#64473a\",\n        background: \"#e9e5e3\"\n      },\n      red: {\n        text: \"#e03e3e\",\n        background: \"#fbe4e4\"\n      },\n      orange: {\n        text: \"#d9730d\",\n        background: \"#f6e9d9\"\n      },\n      yellow: {\n        text: \"#dfab01\",\n        background: \"#fbf3db\"\n      },\n      green: {\n        text: \"#4d6461\",\n        background: \"#ddedea\"\n      },\n      blue: {\n        text: \"#0b6e99\",\n        background: \"#ddebf1\"\n      },\n      purple: {\n        text: \"#6940a5\",\n        background: \"#eae4f2\"\n      },\n      pink: {\n        text: \"#ad1a72\",\n        background: \"#f4dfeb\"\n      }\n    }\n  },\n  borderRadius: 6,\n  fontFamily: '\"Inter\", \"SF Pro Display\", -apple-system, BlinkMacSystemFont, \"Open Sans\", \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif'\n}, aa = {\n  colors: {\n    editor: {\n      text: y[2],\n      background: y[6]\n    },\n    menu: {\n      text: y[2],\n      background: y[6]\n    },\n    tooltip: {\n      text: y[2],\n      background: y[7]\n    },\n    hovered: {\n      text: y[2],\n      background: y[7]\n    },\n    selected: {\n      text: y[2],\n      background: y[8]\n    },\n    disabled: {\n      text: y[5],\n      background: y[7]\n    },\n    shadow: y[8],\n    border: y[7],\n    sideMenu: y[4],\n    highlights: {\n      gray: {\n        text: \"#bebdb8\",\n        background: \"#9b9a97\"\n      },\n      brown: {\n        text: \"#8e6552\",\n        background: \"#64473a\"\n      },\n      red: {\n        text: \"#ec4040\",\n        background: \"#be3434\"\n      },\n      orange: {\n        text: \"#e3790d\",\n        background: \"#b7600a\"\n      },\n      yellow: {\n        text: \"#dfab01\",\n        background: \"#b58b00\"\n      },\n      green: {\n        text: \"#6b8b87\",\n        background: \"#4d6461\"\n      },\n      blue: {\n        text: \"#0e87bc\",\n        background: \"#0b6e99\"\n      },\n      purple: {\n        text: \"#8552d7\",\n        background: \"#6940a5\"\n      },\n      pink: {\n        text: \"#da208f\",\n        background: \"#ad1a72\"\n      }\n    }\n  },\n  borderRadius: Lt.borderRadius,\n  fontFamily: Lt.fontFamily\n};\nfunction ia(e) {\n  const t = ee();\n  if (e || (e = t == null ? void 0 : t.editor), !e)\n    throw new Error(\n      \"'editor' is required, either from BlockNoteContext or as a function argument\"\n    );\n  const n = e, [r, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => n.getActiveStyles());\n  return Je(() => {\n    i(n.getActiveStyles());\n  }, n), Qe(() => {\n    i(n.getActiveStyles());\n  }, n), r;\n}\nconst Yo = (e = {}, t = []) => (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n  const n = _blocknote_core__WEBPACK_IMPORTED_MODULE_1__.BlockNoteEditor.create(e);\n  return window && (window.ProseMirror = n._tiptapEditor), n;\n}, t), la = Yo;\nfunction Ko() {\n  const [, e] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  return () => e((t) => t + 1);\n}\nconst sa = (e) => {\n  const t = Ko();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const n = () => {\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          t();\n        });\n      });\n    };\n    return e.on(\"transaction\", n), () => {\n      e.off(\"transaction\", n);\n    };\n  }, [e]);\n};\nvar qe, ye = react_dom__WEBPACK_IMPORTED_MODULE_3__;\nif (false)\n  {}\nelse {\n  var Dt = ye.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  qe = function(e, t) {\n    Dt.usingClientEntryPoint = !0;\n    try {\n      return ye.createRoot(e, t);\n    } finally {\n      Dt.usingClientEntryPoint = !1;\n    }\n  };\n}\nfunction Se(e) {\n  let t;\n  const n = document.createElement(\"div\"), r = qe(n);\n  if ((0,react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync)(() => {\n    r.render(e((s) => t = s || void 0));\n  }), !n.childElementCount)\n    return console.warn(\"ReactInlineContentSpec: renderHTML() failed\"), {\n      dom: document.createElement(\"span\")\n    };\n  t == null || t.setAttribute(\"data-tmp-find\", \"true\");\n  const i = n.cloneNode(!0), l = i.firstElementChild, c = i.querySelector(\n    \"[data-tmp-find]\"\n  );\n  return c == null || c.removeAttribute(\"data-tmp-find\"), r.unmount(), {\n    dom: l,\n    contentDOM: c || void 0\n  };\n}\nfunction Fe(e) {\n  var t;\n  return (\n    // Creates `blockContent` element\n    /* @__PURE__ */ o.jsx(\n      _tiptap_react__WEBPACK_IMPORTED_MODULE_23__.NodeViewWrapper,\n      {\n        ...Object.fromEntries(\n          Object.entries(e.domAttributes || {}).filter(\n            ([n]) => n !== \"class\"\n          )\n        ),\n        className: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.mergeCSSClasses)(\n          \"bn-block-content\",\n          ((t = e.domAttributes) == null ? void 0 : t.class) || \"\"\n        ),\n        \"data-content-type\": e.blockType,\n        ...Object.fromEntries(\n          Object.entries(e.blockProps).filter(\n            ([n, r]) => !_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.inheritedProps.includes(n) && r !== e.propSchema[n].default\n          ).map(([n, r]) => [(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.camelToDataKebab)(n), r])\n        ),\n        children: e.children\n      }\n    )\n  );\n}\nfunction ca(e, t) {\n  const n = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.createStronglyTypedTiptapNode)({\n    name: e.type,\n    content: e.content === \"inline\" ? \"inline*\" : \"\",\n    group: \"blockContent\",\n    selectable: !0,\n    addAttributes() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.propsToAttributes)(e.propSchema);\n    },\n    parseHTML() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.getParseRules)(e, t.parse);\n    },\n    renderHTML() {\n      const r = document.createElement(\"div\");\n      return r.setAttribute(\"data-tmp-placeholder\", \"true\"), {\n        dom: r\n      };\n    },\n    addNodeView() {\n      return (r) => (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_23__.ReactNodeViewRenderer)(\n        (i) => {\n          var h;\n          const l = this.options.editor, c = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.getBlockFromPos)(\n            i.getPos,\n            l,\n            this.editor,\n            e.type\n          ), s = ((h = this.options.domAttributes) == null ? void 0 : h.blockContent) || {}, d = (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_23__.NodeViewContent)({}).ref, f = t.render;\n          return /* @__PURE__ */ o.jsx(\n            Fe,\n            {\n              blockType: c.type,\n              blockProps: c.props,\n              propSchema: e.propSchema,\n              domAttributes: s,\n              children: /* @__PURE__ */ o.jsx(\n                f,\n                {\n                  block: c,\n                  editor: l,\n                  contentRef: d\n                }\n              )\n            }\n          );\n        },\n        {\n          className: \"bn-react-node-view-renderer\"\n        }\n      )(r);\n    }\n  });\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.createInternalBlockSpec)(e, {\n    node: n,\n    toInternalHTML: (r, i) => {\n      var d, f;\n      const l = ((d = n.options.domAttributes) == null ? void 0 : d.blockContent) || {}, c = t.render, s = Se((h) => /* @__PURE__ */ o.jsx(\n        Fe,\n        {\n          blockType: r.type,\n          blockProps: r.props,\n          propSchema: e.propSchema,\n          domAttributes: l,\n          children: /* @__PURE__ */ o.jsx(\n            c,\n            {\n              block: r,\n              editor: i,\n              contentRef: h\n            }\n          )\n        }\n      ));\n      return (f = s.contentDOM) == null || f.setAttribute(\"data-editable\", \"\"), s;\n    },\n    toExternalHTML: (r, i) => {\n      var d, f;\n      const l = ((d = n.options.domAttributes) == null ? void 0 : d.blockContent) || {}, c = t.toExternalHTML || t.render, s = Se((h) => /* @__PURE__ */ o.jsx(\n        Fe,\n        {\n          blockType: r.type,\n          blockProps: r.props,\n          propSchema: e.propSchema,\n          domAttributes: l,\n          children: /* @__PURE__ */ o.jsx(\n            c,\n            {\n              block: r,\n              editor: i,\n              contentRef: h\n            }\n          )\n        }\n      ));\n      return (f = s.contentDOM) == null || f.setAttribute(\"data-editable\", \"\"), s;\n    }\n  });\n}\nfunction Go(e, t, n, r) {\n  return () => (\n    // Creates inline content section element\n    /* @__PURE__ */ o.jsx(\n      _tiptap_react__WEBPACK_IMPORTED_MODULE_23__.NodeViewWrapper,\n      {\n        as: \"span\",\n        className: \"bn-inline-content-section\",\n        \"data-inline-content-type\": t,\n        ...Object.fromEntries(\n          Object.entries(n).filter(([i, l]) => l !== r[i].default).map(([i, l]) => [(0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.camelToDataKebab)(i), l])\n        ),\n        children: e\n      }\n    )\n  );\n}\nfunction ua(e, t) {\n  const n = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.createStronglyTypedTiptapNode)({\n    name: e.type,\n    inline: !0,\n    group: \"inline\",\n    selectable: e.content === \"styled\",\n    atom: e.content === \"none\",\n    content: e.content === \"styled\" ? \"inline*\" : \"\",\n    addAttributes() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.propsToAttributes)(e.propSchema);\n    },\n    addKeyboardShortcuts() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.addInlineContentKeyboardShortcuts)(e);\n    },\n    parseHTML() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.getInlineContentParseRules)(e);\n    },\n    renderHTML({ node: r }) {\n      const i = this.options.editor, l = (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.nodeToCustomInlineContent)(\n        r,\n        i.schema.inlineContentSchema,\n        i.schema.styleSchema\n      ), c = t.render, s = Se((d) => /* @__PURE__ */ o.jsx(c, { inlineContent: l, contentRef: d }));\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.addInlineContentAttributes)(\n        s,\n        e.type,\n        r.attrs,\n        e.propSchema\n      );\n    },\n    // TODO: needed?\n    addNodeView() {\n      const r = this.options.editor;\n      return (i) => (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_23__.ReactNodeViewRenderer)(\n        (l) => {\n          const c = (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_23__.NodeViewContent)({}).ref, s = t.render, d = Go(\n            /* @__PURE__ */ o.jsx(\n              s,\n              {\n                contentRef: c,\n                inlineContent: (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.nodeToCustomInlineContent)(\n                  l.node,\n                  r.schema.inlineContentSchema,\n                  r.schema.styleSchema\n                )\n              }\n            ),\n            e.type,\n            l.node.attrs,\n            e.propSchema\n          );\n          return /* @__PURE__ */ o.jsx(d, {});\n        },\n        {\n          className: \"bn-ic-react-node-view-renderer\",\n          as: \"span\"\n          // contentDOMElementTag: \"span\", (requires tt upgrade)\n        }\n      )(i);\n    }\n  });\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.createInternalInlineContentSpec)(e, {\n    node: n\n  });\n}\nfunction da(e, t) {\n  const n = _tiptap_react__WEBPACK_IMPORTED_MODULE_24__.Mark.create({\n    name: e.type,\n    addAttributes() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.stylePropsToAttributes)(e.propSchema);\n    },\n    parseHTML() {\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.getStyleParseRules)(e);\n    },\n    renderHTML({ mark: r }) {\n      const i = {};\n      e.propSchema === \"string\" && (i.value = r.attrs.stringValue);\n      const l = t.render, c = Se((s) => /* @__PURE__ */ o.jsx(l, { ...i, contentRef: s }));\n      return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.addStyleAttributes)(\n        c,\n        e.type,\n        r.attrs.stringValue,\n        e.propSchema\n      );\n    }\n  });\n  return (0,_blocknote_core__WEBPACK_IMPORTED_MODULE_1__.createInternalStyleSpec)(e, {\n    mark: n\n  });\n}\n\n//# sourceMappingURL=blocknote-react.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9yZWFjdC9kaXN0L2Jsb2Nrbm90ZS1yZWFjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9NO0FBQzJsQjtBQUN2cUI7QUFDcUo7QUFDbk87QUFDMEI7QUFDa0Q7QUFDdEgsV0FBVyxvREFBRTtBQUNiO0FBQ0EsU0FBUyxpREFBRTtBQUNYO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFDLDRMQUE0TDtBQUN2TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsd0VBQUU7QUFDWDtBQUNBLEdBQUc7QUFDSDtBQWlFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGxpdmVibG9ja3MtZXhhbXBsZXMvbmV4dGpzLXlqcy1ibG9ja25vdGUtYWR2YW5jZWQvLi9ub2RlX21vZHVsZXMvQGJsb2Nrbm90ZS9yZWFjdC9kaXN0L2Jsb2Nrbm90ZS1yZWFjdC5qcz83MDM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBLCB7IGNyZWF0ZUNvbnRleHQgYXMgWm4sIHVzZUNvbnRleHQgYXMgem4sIHVzZUVmZmVjdCBhcyBMLCB1c2VNZW1vIGFzIEIsIHVzZVN0YXRlIGFzIHAsIGZvcndhcmRSZWYgYXMgdWUsIHVzZVJlZiBhcyBZLCB1c2VDYWxsYmFjayBhcyBILCBjcmVhdGVFbGVtZW50IGFzIFVuLCBDaGlsZHJlbiBhcyAkbiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbWVyZ2VDU1NDbGFzc2VzIGFzIGRlLCBpc1NhZmFyaSBhcyBOZSwgZm9ybWF0S2V5Ym9hcmRTaG9ydGN1dCBhcyBqZSwgY2hlY2tCbG9ja0lzRGVmYXVsdFR5cGUgYXMgX3QsIGNoZWNrRGVmYXVsdEJsb2NrVHlwZUluU2NoZW1hIGFzIFduLCBjaGVja0Jsb2NrSGFzRGVmYXVsdFByb3AgYXMgWmUsIGNoZWNrQmxvY2tUeXBlSGFzRGVmYXVsdFByb3AgYXMgbGUsIGdldERlZmF1bHRTbGFzaE1lbnVJdGVtcyBhcyBxbiwgZmlsdGVyU3VnZ2VzdGlvbkl0ZW1zIGFzIEl0LCBCbG9ja05vdGVFZGl0b3IgYXMgWW4sIGluaGVyaXRlZFByb3BzIGFzIEtuLCBjYW1lbFRvRGF0YUtlYmFiIGFzIE90LCBjcmVhdGVTdHJvbmdseVR5cGVkVGlwdGFwTm9kZSBhcyBQdCwgcHJvcHNUb0F0dHJpYnV0ZXMgYXMgQXQsIGdldFBhcnNlUnVsZXMgYXMgR24sIGdldEJsb2NrRnJvbVBvcyBhcyBKbiwgY3JlYXRlSW50ZXJuYWxCbG9ja1NwZWMgYXMgUW4sIGFkZElubGluZUNvbnRlbnRLZXlib2FyZFNob3J0Y3V0cyBhcyBYbiwgZ2V0SW5saW5lQ29udGVudFBhcnNlUnVsZXMgYXMgZXIsIG5vZGVUb0N1c3RvbUlubGluZUNvbnRlbnQgYXMgU3QsIGFkZElubGluZUNvbnRlbnRBdHRyaWJ1dGVzIGFzIHRyLCBjcmVhdGVJbnRlcm5hbElubGluZUNvbnRlbnRTcGVjIGFzIG5yLCBzdHlsZVByb3BzVG9BdHRyaWJ1dGVzIGFzIHJyLCBnZXRTdHlsZVBhcnNlUnVsZXMgYXMgb3IsIGFkZFN0eWxlQXR0cmlidXRlcyBhcyBhciwgY3JlYXRlSW50ZXJuYWxTdHlsZVNwZWMgYXMgaXIgfSBmcm9tIFwiQGJsb2Nrbm90ZS9jb3JlXCI7XG5pbXBvcnQgeyB1c2VGbG9hdGluZyBhcyBGdCwgdXNlVHJhbnNpdGlvblN0eWxlcyBhcyBOdCwgb2Zmc2V0IGFzIGZlLCBmbGlwIGFzIHdlLCBzaXplIGFzIGxyIH0gZnJvbSBcIkBmbG9hdGluZy11aS9yZWFjdFwiO1xuaW1wb3J0IHsgR3JvdXAgYXMgWWUsIFN0YWNrIGFzIEtlLCBUZXh0IGFzIHNlLCBUb29sdGlwIGFzIHNyLCBCdXR0b24gYXMgR2UsIEFjdGlvbkljb24gYXMgWnQsIEJveCBhcyB6dCwgTWVudSBhcyB3LCBUZXh0SW5wdXQgYXMgVXQsIEZpbGVJbnB1dCBhcyAkdCwgUG9wb3ZlciBhcyBYLCBUYWJzIGFzIFEsIExvYWRpbmdPdmVybGF5IGFzIGNyLCBCYWRnZSBhcyB1ciwgTG9hZGVyIGFzIGRyLCBNYW50aW5lUHJvdmlkZXIgYXMgZnIgfSBmcm9tIFwiQG1hbnRpbmUvY29yZVwiO1xuaW1wb3J0IGdyIGZyb20gXCJ1c2UtcHJlZmVycy1jb2xvci1zY2hlbWVcIjtcbmltcG9ydCBociwgeyBjcmVhdGVQb3J0YWwgYXMgbXIsIGZsdXNoU3luYyBhcyBiciB9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7IE5vZGVWaWV3V3JhcHBlciBhcyBXdCwgUmVhY3ROb2RlVmlld1JlbmRlcmVyIGFzIHF0LCBOb2RlVmlld0NvbnRlbnQgYXMgWXQsIE1hcmsgYXMgeHIgfSBmcm9tIFwiQHRpcHRhcC9yZWFjdFwiO1xuY29uc3QgS3QgPSBabih2b2lkIDApO1xuZnVuY3Rpb24gZWUoZSkge1xuICByZXR1cm4gem4oS3QpO1xufVxudmFyIHplID0geyBleHBvcnRzOiB7fSB9LCBhZSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGp0O1xuZnVuY3Rpb24gdnIoKSB7XG4gIGlmIChqdClcbiAgICByZXR1cm4gYWU7XG4gIGp0ID0gMTtcbiAgdmFyIGUgPSBBLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIG4gPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIHIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBpID0gZS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lciwgbCA9IHsga2V5OiAhMCwgcmVmOiAhMCwgX19zZWxmOiAhMCwgX19zb3VyY2U6ICEwIH07XG4gIGZ1bmN0aW9uIGMocywgZCwgZikge1xuICAgIHZhciBoLCBiID0ge30sIFQgPSBudWxsLCBDID0gbnVsbDtcbiAgICBmICE9PSB2b2lkIDAgJiYgKFQgPSBcIlwiICsgZiksIGQua2V5ICE9PSB2b2lkIDAgJiYgKFQgPSBcIlwiICsgZC5rZXkpLCBkLnJlZiAhPT0gdm9pZCAwICYmIChDID0gZC5yZWYpO1xuICAgIGZvciAoaCBpbiBkKVxuICAgICAgci5jYWxsKGQsIGgpICYmICFsLmhhc093blByb3BlcnR5KGgpICYmIChiW2hdID0gZFtoXSk7XG4gICAgaWYgKHMgJiYgcy5kZWZhdWx0UHJvcHMpXG4gICAgICBmb3IgKGggaW4gZCA9IHMuZGVmYXVsdFByb3BzLCBkKVxuICAgICAgICBiW2hdID09PSB2b2lkIDAgJiYgKGJbaF0gPSBkW2hdKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogdCwgdHlwZTogcywga2V5OiBULCByZWY6IEMsIHByb3BzOiBiLCBfb3duZXI6IGkuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBhZS5GcmFnbWVudCA9IG4sIGFlLmpzeCA9IGMsIGFlLmpzeHMgPSBjLCBhZTtcbn1cbnZhciBpZSA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIHd0O1xuZnVuY3Rpb24gcHIoKSB7XG4gIHJldHVybiB3dCB8fCAod3QgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSBBLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIG4gPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCByID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBzID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGYgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgYiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBUID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIEMgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBEID0gU3ltYm9sLml0ZXJhdG9yLCBuZSA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIEYoYSkge1xuICAgICAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgdSA9IEQgJiYgYVtEXSB8fCBhW25lXTtcbiAgICAgIHJldHVybiB0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgPyB1IDogbnVsbDtcbiAgICB9XG4gICAgdmFyIE8gPSBlLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgIGZ1bmN0aW9uIE0oYSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciB1ID0gYXJndW1lbnRzLmxlbmd0aCwgZyA9IG5ldyBBcnJheSh1ID4gMSA/IHUgLSAxIDogMCksIG0gPSAxOyBtIDwgdTsgbSsrKVxuICAgICAgICAgIGdbbSAtIDFdID0gYXJndW1lbnRzW21dO1xuICAgICAgICBIZShcImVycm9yXCIsIGEsIGcpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBIZShhLCB1LCBnKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBtID0gTy5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBrID0gbS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIGsgIT09IFwiXCIgJiYgKHUgKz0gXCIlc1wiLCBnID0gZy5jb25jYXQoW2tdKSk7XG4gICAgICAgIHZhciBqID0gZy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodik7XG4gICAgICAgIH0pO1xuICAgICAgICBqLnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIHUpLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2FdLCBjb25zb2xlLCBqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyICQgPSAhMSwgaGUgPSAhMSwgRWUgPSAhMSwgTWUgPSAhMSwgUmUgPSAhMSwgVztcbiAgICBXID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gbW4oYSkge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiBhID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiIHx8IGEgPT09IHIgfHwgYSA9PT0gbCB8fCBSZSB8fCBhID09PSBpIHx8IGEgPT09IGYgfHwgYSA9PT0gaCB8fCBNZSB8fCBhID09PSBDIHx8ICQgfHwgaGUgfHwgRWUgfHwgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiBhICE9PSBudWxsICYmIChhLiQkdHlwZW9mID09PSBUIHx8IGEuJCR0eXBlb2YgPT09IGIgfHwgYS4kJHR5cGVvZiA9PT0gYyB8fCBhLiQkdHlwZW9mID09PSBzIHx8IGEuJCR0eXBlb2YgPT09IGQgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgYS4kJHR5cGVvZiA9PT0gVyB8fCBhLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm4oYSwgdSwgZykge1xuICAgICAgdmFyIG0gPSBhLmRpc3BsYXlOYW1lO1xuICAgICAgaWYgKG0pXG4gICAgICAgIHJldHVybiBtO1xuICAgICAgdmFyIGsgPSB1LmRpc3BsYXlOYW1lIHx8IHUubmFtZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGsgIT09IFwiXCIgPyBnICsgXCIoXCIgKyBrICsgXCIpXCIgOiBnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBldChhKSB7XG4gICAgICByZXR1cm4gYS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gTihhKSB7XG4gICAgICBpZiAoYSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgYS50YWcgPT0gXCJudW1iZXJcIiAmJiBNKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGEuZGlzcGxheU5hbWUgfHwgYS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgY2FzZSByOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgbjpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBsOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgaTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgZjpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChhLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgdmFyIHUgPSBhO1xuICAgICAgICAgICAgcmV0dXJuIGV0KHUpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICB2YXIgZyA9IGE7XG4gICAgICAgICAgICByZXR1cm4gZXQoZy5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgZDpcbiAgICAgICAgICAgIHJldHVybiBibihhLCBhLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIHZhciBtID0gYS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG0gIT09IG51bGwgPyBtIDogTihhLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgVDoge1xuICAgICAgICAgICAgdmFyIGsgPSBhLCBqID0gay5fcGF5bG9hZCwgdiA9IGsuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gTih2KGopKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcSA9IE9iamVjdC5hc3NpZ24sIHJlID0gMCwgdHQsIG50LCBydCwgb3QsIGF0LCBpdCwgbHQ7XG4gICAgZnVuY3Rpb24gc3QoKSB7XG4gICAgfVxuICAgIHN0Ll9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIHhuKCkge1xuICAgICAge1xuICAgICAgICBpZiAocmUgPT09IDApIHtcbiAgICAgICAgICB0dCA9IGNvbnNvbGUubG9nLCBudCA9IGNvbnNvbGUuaW5mbywgcnQgPSBjb25zb2xlLndhcm4sIG90ID0gY29uc29sZS5lcnJvciwgYXQgPSBjb25zb2xlLmdyb3VwLCBpdCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIGx0ID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiBzdCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogYSxcbiAgICAgICAgICAgIGxvZzogYSxcbiAgICAgICAgICAgIHdhcm46IGEsXG4gICAgICAgICAgICBlcnJvcjogYSxcbiAgICAgICAgICAgIGdyb3VwOiBhLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGEsXG4gICAgICAgICAgICBncm91cEVuZDogYVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZuKCkge1xuICAgICAge1xuICAgICAgICBpZiAocmUtLSwgcmUgPT09IDApIHtcbiAgICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiBxKHt9LCBhLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0dFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBxKHt9LCBhLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBudFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuOiBxKHt9LCBhLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBydFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogcSh7fSwgYSwge1xuICAgICAgICAgICAgICB2YWx1ZTogb3RcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IHEoe30sIGEsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGF0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBxKHt9LCBhLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBpdFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cEVuZDogcSh7fSwgYSwge1xuICAgICAgICAgICAgICB2YWx1ZTogbHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmUgPCAwICYmIE0oXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgVmUgPSBPLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsIEJlO1xuICAgIGZ1bmN0aW9uIG1lKGEsIHUsIGcpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEJlID09PSB2b2lkIDApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoaykge1xuICAgICAgICAgICAgdmFyIG0gPSBrLnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgQmUgPSBtICYmIG1bMV0gfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5gICsgQmUgKyBhO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgTGUgPSAhMSwgYmU7XG4gICAge1xuICAgICAgdmFyIHBuID0gdHlwZW9mIFdlYWtNYXAgPT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IE1hcDtcbiAgICAgIGJlID0gbmV3IHBuKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN0KGEsIHUpIHtcbiAgICAgIGlmICghYSB8fCBMZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB7XG4gICAgICAgIHZhciBnID0gYmUuZ2V0KGEpO1xuICAgICAgICBpZiAoZyAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiBnO1xuICAgICAgfVxuICAgICAgdmFyIG07XG4gICAgICBMZSA9ICEwO1xuICAgICAgdmFyIGsgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIGo7XG4gICAgICBqID0gVmUuY3VycmVudCwgVmUuY3VycmVudCA9IG51bGwsIHhuKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHZhciB2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2LnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdCh2LCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChaKSB7XG4gICAgICAgICAgICAgIG0gPSBaO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoYSwgW10sIHYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2LmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFopIHtcbiAgICAgICAgICAgICAgbSA9IFo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLmNhbGwodi5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChaKSB7XG4gICAgICAgICAgICBtID0gWjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChaKSB7XG4gICAgICAgIGlmIChaICYmIG0gJiYgdHlwZW9mIFouc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIHggPSBaLnN0YWNrLnNwbGl0KGBcbmApLCBfID0gbS5zdGFjay5zcGxpdChgXG5gKSwgRSA9IHgubGVuZ3RoIC0gMSwgUiA9IF8ubGVuZ3RoIC0gMTsgRSA+PSAxICYmIFIgPj0gMCAmJiB4W0VdICE9PSBfW1JdOyApXG4gICAgICAgICAgICBSLS07XG4gICAgICAgICAgZm9yICg7IEUgPj0gMSAmJiBSID49IDA7IEUtLSwgUi0tKVxuICAgICAgICAgICAgaWYgKHhbRV0gIT09IF9bUl0pIHtcbiAgICAgICAgICAgICAgaWYgKEUgIT09IDEgfHwgUiAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKEUtLSwgUi0tLCBSIDwgMCB8fCB4W0VdICE9PSBfW1JdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBJID0gYFxuYCArIHhbRV0ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZGlzcGxheU5hbWUgJiYgSS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChJID0gSS5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgYS5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIgJiYgYmUuc2V0KGEsIEkpLCBJO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChFID49IDEgJiYgUiA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIExlID0gITEsIFZlLmN1cnJlbnQgPSBqLCB2bigpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGs7XG4gICAgICB9XG4gICAgICB2YXIgSiA9IGEgPyBhLmRpc3BsYXlOYW1lIHx8IGEubmFtZSA6IFwiXCIsIEN0ID0gSiA/IG1lKEopIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIgJiYgYmUuc2V0KGEsIEN0KSwgQ3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtuKGEsIHUsIGcpIHtcbiAgICAgIHJldHVybiBjdChhLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHluKGEpIHtcbiAgICAgIHZhciB1ID0gYS5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISEodSAmJiB1LmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4ZShhLCB1LCBnKSB7XG4gICAgICBpZiAoYSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBjdChhLCB5bihhKSk7XG4gICAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIG1lKGEpO1xuICAgICAgc3dpdGNoIChhKSB7XG4gICAgICAgIGNhc2UgZjpcbiAgICAgICAgICByZXR1cm4gbWUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBoOlxuICAgICAgICAgIHJldHVybiBtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGEuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGQ6XG4gICAgICAgICAgICByZXR1cm4ga24oYS5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIHJldHVybiB4ZShhLnR5cGUsIHUsIGcpO1xuICAgICAgICAgIGNhc2UgVDoge1xuICAgICAgICAgICAgdmFyIG0gPSBhLCBrID0gbS5fcGF5bG9hZCwgaiA9IG0uX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4geGUoaihrKSwgdSwgZyk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgdmUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCB1dCA9IHt9LCBkdCA9IE8uUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBwZShhKSB7XG4gICAgICBpZiAoYSkge1xuICAgICAgICB2YXIgdSA9IGEuX293bmVyLCBnID0geGUoYS50eXBlLCBhLl9zb3VyY2UsIHUgPyB1LnR5cGUgOiBudWxsKTtcbiAgICAgICAgZHQuc2V0RXh0cmFTdGFja0ZyYW1lKGcpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGR0LnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ24oYSwgdSwgZywgbSwgaykge1xuICAgICAge1xuICAgICAgICB2YXIgaiA9IEZ1bmN0aW9uLmNhbGwuYmluZCh2ZSk7XG4gICAgICAgIGZvciAodmFyIHYgaW4gYSlcbiAgICAgICAgICBpZiAoaihhLCB2KSkge1xuICAgICAgICAgICAgdmFyIHggPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGFbdl0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIF8gPSBFcnJvcigobSB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgZyArIFwiIHR5cGUgYFwiICsgdiArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgYVt2XSArIFwiYC5UaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC5cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgXy5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIF87XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeCA9IGFbdl0odSwgdiwgbSwgZywgbnVsbCwgXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgeCA9IEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ICYmICEoeCBpbnN0YW5jZW9mIEVycm9yKSAmJiAocGUoayksIE0oXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsIG0gfHwgXCJSZWFjdCBjbGFzc1wiLCBnLCB2LCB0eXBlb2YgeCksIHBlKG51bGwpKSwgeCBpbnN0YW5jZW9mIEVycm9yICYmICEoeC5tZXNzYWdlIGluIHV0KSAmJiAodXRbeC5tZXNzYWdlXSA9ICEwLCBwZShrKSwgTShcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBnLCB4Lm1lc3NhZ2UpLCBwZShudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgU24gPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIERlKGEpIHtcbiAgICAgIHJldHVybiBTbihhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gam4oYSkge1xuICAgICAge1xuICAgICAgICB2YXIgdSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgZyA9IHUgJiYgYVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IGEuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICByZXR1cm4gZztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd24oYSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ0KGEpLCAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZ0KGEpIHtcbiAgICAgIHJldHVybiBcIlwiICsgYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3QoYSkge1xuICAgICAgaWYgKHduKGEpKVxuICAgICAgICByZXR1cm4gTShcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLCBqbihhKSksIGZ0KGEpO1xuICAgIH1cbiAgICB2YXIgb2UgPSBPLlJlYWN0Q3VycmVudE93bmVyLCBUbiA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIGh0LCBtdCwgX2U7XG4gICAgX2UgPSB7fTtcbiAgICBmdW5jdGlvbiBIbihhKSB7XG4gICAgICBpZiAodmUuY2FsbChhLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgdSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSwgXCJyZWZcIikuZ2V0O1xuICAgICAgICBpZiAodSAmJiB1LmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLnJlZiAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFbihhKSB7XG4gICAgICBpZiAodmUuY2FsbChhLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgdSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAodSAmJiB1LmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNbihhLCB1KSB7XG4gICAgICBpZiAodHlwZW9mIGEucmVmID09IFwic3RyaW5nXCIgJiYgb2UuY3VycmVudCAmJiB1ICYmIG9lLmN1cnJlbnQuc3RhdGVOb2RlICE9PSB1KSB7XG4gICAgICAgIHZhciBnID0gTihvZS5jdXJyZW50LnR5cGUpO1xuICAgICAgICBfZVtnXSB8fCAoTSgnQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIE4ob2UuY3VycmVudC50eXBlKSwgYS5yZWYpLCBfZVtnXSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUm4oYSwgdSkge1xuICAgICAge1xuICAgICAgICB2YXIgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGh0IHx8IChodCA9ICEwLCBNKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgdSkpO1xuICAgICAgICB9O1xuICAgICAgICBnLmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiBnLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZuKGEsIHUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBtdCB8fCAobXQgPSAhMCwgTShcIiVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZy5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogZyxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgQm4gPSBmdW5jdGlvbihhLCB1LCBnLCBtLCBrLCBqLCB2KSB7XG4gICAgICB2YXIgeCA9IHtcbiAgICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAgICQkdHlwZW9mOiB0LFxuICAgICAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgICAgIHR5cGU6IGEsXG4gICAgICAgIGtleTogdSxcbiAgICAgICAgcmVmOiBnLFxuICAgICAgICBwcm9wczogdixcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgX293bmVyOiBqXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHguX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4Ll9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoeCwgXCJfc2VsZlwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBtXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHgsIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBrXG4gICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh4LnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh4KSksIHg7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBMbihhLCB1LCBnLCBtLCBrKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBqLCB2ID0ge30sIHggPSBudWxsLCBfID0gbnVsbDtcbiAgICAgICAgZyAhPT0gdm9pZCAwICYmIChndChnKSwgeCA9IFwiXCIgKyBnKSwgRW4odSkgJiYgKGd0KHUua2V5KSwgeCA9IFwiXCIgKyB1LmtleSksIEhuKHUpICYmIChfID0gdS5yZWYsIE1uKHUsIGspKTtcbiAgICAgICAgZm9yIChqIGluIHUpXG4gICAgICAgICAgdmUuY2FsbCh1LCBqKSAmJiAhVG4uaGFzT3duUHJvcGVydHkoaikgJiYgKHZbal0gPSB1W2pdKTtcbiAgICAgICAgaWYgKGEgJiYgYS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgRSA9IGEuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGZvciAoaiBpbiBFKVxuICAgICAgICAgICAgdltqXSA9PT0gdm9pZCAwICYmICh2W2pdID0gRVtqXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggfHwgXykge1xuICAgICAgICAgIHZhciBSID0gdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiID8gYS5kaXNwbGF5TmFtZSB8fCBhLm5hbWUgfHwgXCJVbmtub3duXCIgOiBhO1xuICAgICAgICAgIHggJiYgUm4odiwgUiksIF8gJiYgVm4odiwgUik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJuKGEsIHgsIF8sIGssIG0sIG9lLmN1cnJlbnQsIHYpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSWUgPSBPLlJlYWN0Q3VycmVudE93bmVyLCBidCA9IE8uUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBHKGEpIHtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIHZhciB1ID0gYS5fb3duZXIsIGcgPSB4ZShhLnR5cGUsIGEuX3NvdXJjZSwgdSA/IHUudHlwZSA6IG51bGwpO1xuICAgICAgICBidC5zZXRFeHRyYVN0YWNrRnJhbWUoZyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgYnQuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgT2U7XG4gICAgT2UgPSAhMTtcbiAgICBmdW5jdGlvbiBQZShhKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiBhICE9PSBudWxsICYmIGEuJCR0eXBlb2YgPT09IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHh0KCkge1xuICAgICAge1xuICAgICAgICBpZiAoSWUuY3VycmVudCkge1xuICAgICAgICAgIHZhciBhID0gTihJZS5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIGEgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIERuKGEpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciB1ID0gYS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCBcIlwiKSwgZyA9IGEubGluZU51bWJlcjtcbiAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB5b3VyIGNvZGUgYXQgYCArIHUgKyBcIjpcIiArIGcgKyBcIi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHZ0ID0ge307XG4gICAgZnVuY3Rpb24gX24oYSkge1xuICAgICAge1xuICAgICAgICB2YXIgdSA9IHh0KCk7XG4gICAgICAgIGlmICghdSkge1xuICAgICAgICAgIHZhciBnID0gdHlwZW9mIGEgPT0gXCJzdHJpbmdcIiA/IGEgOiBhLmRpc3BsYXlOYW1lIHx8IGEubmFtZTtcbiAgICAgICAgICBnICYmICh1ID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgZyArIFwiPi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB0KGEsIHUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFhLl9zdG9yZSB8fCBhLl9zdG9yZS52YWxpZGF0ZWQgfHwgYS5rZXkgIT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGEuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICB2YXIgZyA9IF9uKHUpO1xuICAgICAgICBpZiAodnRbZ10pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2dFtnXSA9ICEwO1xuICAgICAgICB2YXIgbSA9IFwiXCI7XG4gICAgICAgIGEgJiYgYS5fb3duZXIgJiYgYS5fb3duZXIgIT09IEllLmN1cnJlbnQgJiYgKG0gPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIE4oYS5fb3duZXIudHlwZSkgKyBcIi5cIiksIEcoYSksIE0oJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGcsIG0pLCBHKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBrdChhLCB1KSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgYSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKERlKGEpKVxuICAgICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgYS5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgdmFyIG0gPSBhW2ddO1xuICAgICAgICAgICAgUGUobSkgJiYgcHQobSwgdSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQZShhKSlcbiAgICAgICAgICBhLl9zdG9yZSAmJiAoYS5fc3RvcmUudmFsaWRhdGVkID0gITApO1xuICAgICAgICBlbHNlIGlmIChhKSB7XG4gICAgICAgICAgdmFyIGsgPSBGKGEpO1xuICAgICAgICAgIGlmICh0eXBlb2YgayA9PSBcImZ1bmN0aW9uXCIgJiYgayAhPT0gYS5lbnRyaWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGsuY2FsbChhKSwgdjsgISh2ID0gai5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgUGUodi52YWx1ZSkgJiYgcHQodi52YWx1ZSwgdSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gSW4oYSkge1xuICAgICAge1xuICAgICAgICB2YXIgdSA9IGEudHlwZTtcbiAgICAgICAgaWYgKHUgPT0gbnVsbCB8fCB0eXBlb2YgdSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGc7XG4gICAgICAgIGlmICh0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgZyA9IHUucHJvcFR5cGVzO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdSA9PSBcIm9iamVjdFwiICYmICh1LiQkdHlwZW9mID09PSBkIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgICAgIHUuJCR0eXBlb2YgPT09IGIpKVxuICAgICAgICAgIGcgPSB1LnByb3BUeXBlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICB2YXIgbSA9IE4odSk7XG4gICAgICAgICAgQ24oZywgYS5wcm9wcywgXCJwcm9wXCIsIG0sIGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHUuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIU9lKSB7XG4gICAgICAgICAgT2UgPSAhMDtcbiAgICAgICAgICB2YXIgayA9IE4odSk7XG4gICAgICAgICAgTShcIkNvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50P1wiLCBrIHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2YgdS5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICF1LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBNKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9uKGEpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IE9iamVjdC5rZXlzKGEucHJvcHMpLCBnID0gMDsgZyA8IHUubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICB2YXIgbSA9IHVbZ107XG4gICAgICAgICAgaWYgKG0gIT09IFwiY2hpbGRyZW5cIiAmJiBtICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICBHKGEpLCBNKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgbSksIEcobnVsbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYS5yZWYgIT09IG51bGwgJiYgKEcoYSksIE0oXCJJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLlwiKSwgRyhudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHl0KGEsIHUsIGcsIG0sIGssIGopIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHYgPSBtbihhKTtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgdmFyIHggPSBcIlwiO1xuICAgICAgICAgIChhID09PSB2b2lkIDAgfHwgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiBhICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGEpLmxlbmd0aCA9PT0gMCkgJiYgKHggKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgXyA9IERuKGspO1xuICAgICAgICAgIF8gPyB4ICs9IF8gOiB4ICs9IHh0KCk7XG4gICAgICAgICAgdmFyIEU7XG4gICAgICAgICAgYSA9PT0gbnVsbCA/IEUgPSBcIm51bGxcIiA6IERlKGEpID8gRSA9IFwiYXJyYXlcIiA6IGEgIT09IHZvaWQgMCAmJiBhLiQkdHlwZW9mID09PSB0ID8gKEUgPSBcIjxcIiArIChOKGEudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgeCA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogRSA9IHR5cGVvZiBhLCBNKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIEUsIHgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBSID0gTG4oYSwgdSwgZywgaywgaik7XG4gICAgICAgIGlmIChSID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIFI7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgdmFyIEkgPSB1LmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChJICE9PSB2b2lkIDApXG4gICAgICAgICAgICBpZiAobSlcbiAgICAgICAgICAgICAgaWYgKERlKEkpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgSiA9IDA7IEogPCBJLmxlbmd0aDsgSisrKVxuICAgICAgICAgICAgICAgICAga3QoSVtKXSwgYSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKEkpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBNKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAga3QoSSwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEgPT09IHIgPyBPbihSKSA6IEluKFIpLCBSO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBQbihhLCB1LCBnKSB7XG4gICAgICByZXR1cm4geXQoYSwgdSwgZywgITApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBbihhLCB1LCBnKSB7XG4gICAgICByZXR1cm4geXQoYSwgdSwgZywgITEpO1xuICAgIH1cbiAgICB2YXIgRm4gPSBBbiwgTm4gPSBQbjtcbiAgICBpZS5GcmFnbWVudCA9IHIsIGllLmpzeCA9IEZuLCBpZS5qc3hzID0gTm47XG4gIH0oKSksIGllO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gemUuZXhwb3J0cyA9IHZyKCkgOiB6ZS5leHBvcnRzID0gcHIoKTtcbnZhciBvID0gemUuZXhwb3J0cztcbmZ1bmN0aW9uIFYoZSkge1xuICBjb25zdCB0ID0gZWUoKTtcbiAgaWYgKCEodCAhPSBudWxsICYmIHQuZWRpdG9yKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcInVzZUJsb2NrTm90ZUVkaXRvciB3YXMgY2FsbGVkIG91dHNpZGUgb2YgYSBCbG9ja05vdGVDb250ZXh0IHByb3ZpZGVyIG9yIEJsb2NrTm90ZVZpZXcgY29tcG9uZW50XCJcbiAgICApO1xuICByZXR1cm4gdC5lZGl0b3I7XG59XG5mdW5jdGlvbiBKZShlLCB0KSB7XG4gIGNvbnN0IG4gPSBlZSgpO1xuICB0IHx8ICh0ID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi5lZGl0b3IpLCBMKCgpID0+IHtcbiAgICBpZiAoIXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiJ2VkaXRvcicgaXMgcmVxdWlyZWQsIGVpdGhlciBmcm9tIEJsb2NrTm90ZUNvbnRleHQgb3IgYXMgYSBmdW5jdGlvbiBhcmd1bWVudFwiXG4gICAgICApO1xuICAgIHJldHVybiB0Lm9uQ2hhbmdlKGUpO1xuICB9LCBbZSwgdF0pO1xufVxuZnVuY3Rpb24gUWUoZSwgdCkge1xuICBjb25zdCBuID0gZWUoKTtcbiAgdCB8fCAodCA9IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uZWRpdG9yKSwgTCgoKSA9PiB7XG4gICAgaWYgKCF0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIidlZGl0b3InIGlzIHJlcXVpcmVkLCBlaXRoZXIgZnJvbSBCbG9ja05vdGVDb250ZXh0IG9yIGFzIGEgZnVuY3Rpb24gYXJndW1lbnRcIlxuICAgICAgKTtcbiAgICByZXR1cm4gdC5vblNlbGVjdGlvbkNoYW5nZShlKTtcbiAgfSwgW2UsIHRdKTtcbn1cbmZ1bmN0aW9uIFUoZSwgdCkge1xuICBKZShlLCB0KSwgUWUoZSwgdCk7XG59XG5mdW5jdGlvbiBnZShlLCB0LCBuLCByKSB7XG4gIGNvbnN0IHsgcmVmczogaSwgdXBkYXRlOiBsLCBjb250ZXh0OiBjLCBmbG9hdGluZ1N0eWxlczogcyB9ID0gRnQoe1xuICAgIG9wZW46IGUsXG4gICAgLi4uclxuICB9KSwgeyBpc01vdW50ZWQ6IGQsIHN0eWxlczogZiB9ID0gTnQoYyk7XG4gIHJldHVybiBMKCgpID0+IHtcbiAgICBsKCk7XG4gIH0sIFt0LCBsXSksIEwoKCkgPT4ge1xuICAgIHQgIT09IG51bGwgJiYgaS5zZXRSZWZlcmVuY2Uoe1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiB0XG4gICAgfSk7XG4gIH0sIFt0LCBpXSksIEIoXG4gICAgKCkgPT4gKHtcbiAgICAgIGlzTW91bnRlZDogZCxcbiAgICAgIHJlZjogaS5zZXRGbG9hdGluZyxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAuLi5mLFxuICAgICAgICAuLi5zLFxuICAgICAgICB6SW5kZXg6IG5cbiAgICAgIH1cbiAgICB9KSxcbiAgICBbcywgZCwgaS5zZXRGbG9hdGluZywgZiwgbl1cbiAgKTtcbn1cbmZ1bmN0aW9uIHRlKGUpIHtcbiAgY29uc3QgW3QsIG5dID0gcCgpO1xuICByZXR1cm4gTCgoKSA9PiBlKChyKSA9PiB7XG4gICAgbih7IC4uLnIgfSk7XG4gIH0pLCBbZV0pLCB0O1xufVxuY29uc3QgQ2UgPSB1ZSgoZSwgdCkgPT4ge1xuICBjb25zdCB7IGNsYXNzTmFtZTogbiwgY2hpbGRyZW46IHIsIC4uLmkgfSA9IGU7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgWWUsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBkZShcImJuLXRvb2xiYXJcIiwgbiB8fCBcIlwiKSxcbiAgICAgIHJlZjogdCxcbiAgICAgIC4uLmksXG4gICAgICBjaGlsZHJlbjogclxuICAgIH1cbiAgKTtcbn0pO1xudmFyIEd0ID0ge1xuICBjb2xvcjogdm9pZCAwLFxuICBzaXplOiB2b2lkIDAsXG4gIGNsYXNzTmFtZTogdm9pZCAwLFxuICBzdHlsZTogdm9pZCAwLFxuICBhdHRyOiB2b2lkIDBcbn0sIFR0ID0gQS5jcmVhdGVDb250ZXh0ICYmIEEuY3JlYXRlQ29udGV4dChHdCksIHogPSBnbG9iYWxUaGlzICYmIGdsb2JhbFRoaXMuX19hc3NpZ24gfHwgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB6ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbihlKSB7XG4gICAgZm9yICh2YXIgdCwgbiA9IDEsIHIgPSBhcmd1bWVudHMubGVuZ3RoOyBuIDwgcjsgbisrKSB7XG4gICAgICB0ID0gYXJndW1lbnRzW25dO1xuICAgICAgZm9yICh2YXIgaSBpbiB0KVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgaSkgJiYgKGVbaV0gPSB0W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0sIHouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sIGtyID0gZ2xvYmFsVGhpcyAmJiBnbG9iYWxUaGlzLl9fcmVzdCB8fCBmdW5jdGlvbihlLCB0KSB7XG4gIHZhciBuID0ge307XG4gIGZvciAodmFyIHIgaW4gZSlcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgcikgJiYgdC5pbmRleE9mKHIpIDwgMCAmJiAobltyXSA9IGVbcl0pO1xuICBpZiAoZSAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09IFwiZnVuY3Rpb25cIilcbiAgICBmb3IgKHZhciBpID0gMCwgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IGkgPCByLmxlbmd0aDsgaSsrKVxuICAgICAgdC5pbmRleE9mKHJbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgcltpXSkgJiYgKG5bcltpXV0gPSBlW3JbaV1dKTtcbiAgcmV0dXJuIG47XG59O1xuZnVuY3Rpb24gSnQoZSkge1xuICByZXR1cm4gZSAmJiBlLm1hcChmdW5jdGlvbih0LCBuKSB7XG4gICAgcmV0dXJuIEEuY3JlYXRlRWxlbWVudCh0LnRhZywgeih7XG4gICAgICBrZXk6IG5cbiAgICB9LCB0LmF0dHIpLCBKdCh0LmNoaWxkKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gUyhlKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIEEuY3JlYXRlRWxlbWVudCh5ciwgeih7XG4gICAgICBhdHRyOiB6KHt9LCBlLmF0dHIpXG4gICAgfSwgdCksIEp0KGUuY2hpbGQpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHlyKGUpIHtcbiAgdmFyIHQgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHIgPSBlLmF0dHIsIGkgPSBlLnNpemUsIGwgPSBlLnRpdGxlLCBjID0ga3IoZSwgW1wiYXR0clwiLCBcInNpemVcIiwgXCJ0aXRsZVwiXSksIHMgPSBpIHx8IG4uc2l6ZSB8fCBcIjFlbVwiLCBkO1xuICAgIHJldHVybiBuLmNsYXNzTmFtZSAmJiAoZCA9IG4uY2xhc3NOYW1lKSwgZS5jbGFzc05hbWUgJiYgKGQgPSAoZCA/IGQgKyBcIiBcIiA6IFwiXCIpICsgZS5jbGFzc05hbWUpLCBBLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeih7XG4gICAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IFwiMFwiXG4gICAgfSwgbi5hdHRyLCByLCBjLCB7XG4gICAgICBjbGFzc05hbWU6IGQsXG4gICAgICBzdHlsZTogeih6KHtcbiAgICAgICAgY29sb3I6IGUuY29sb3IgfHwgbi5jb2xvclxuICAgICAgfSwgbi5zdHlsZSksIGUuc3R5bGUpLFxuICAgICAgaGVpZ2h0OiBzLFxuICAgICAgd2lkdGg6IHMsXG4gICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgfSksIGwgJiYgQS5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgbCksIGUuY2hpbGRyZW4pO1xuICB9O1xuICByZXR1cm4gVHQgIT09IHZvaWQgMCA/IEEuY3JlYXRlRWxlbWVudChUdC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24obikge1xuICAgIHJldHVybiB0KG4pO1xuICB9KSA6IHQoR3QpO1xufVxuZnVuY3Rpb24gQ3IoZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTIzIDExLjk5OThMMTUuOTI4OSAxOS4wNzA4TDE0LjUxNDcgMTcuNjU2NkwyMC4xNzE2IDExLjk5OThMMTQuNTE0NyA2LjM0MjkyTDE1LjkyODkgNC45Mjg3MUwyMyAxMS45OTk4Wk0zLjgyODQzIDExLjk5OThMOS40ODUyOCAxNy42NTY2TDguMDcxMDcgMTkuMDcwOEwxIDExLjk5OThMOC4wNzEwNyA0LjkyODcxTDkuNDg1MjggNi4zNDI5MkwzLjgyODQzIDExLjk5OThaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIFNyKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDRIMjFWNkgzVjRaTTUgMTlIMTlWMjFINVYxOVpNMyAxNEgyMVYxNkgzVjE0Wk01IDlIMTlWMTFINVY5WlwiIH0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBqcihlKSB7XG4gIHJldHVybiBTKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMyA0SDIxVjZIM1Y0Wk0zIDE5SDIxVjIxSDNWMTlaTTMgMTRIMjFWMTZIM1YxNFpNMyA5SDIxVjExSDNWOVpcIiB9IH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gd3IoZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTMgNEgyMVY2SDNWNFpNMyAxOUgxN1YyMUgzVjE5Wk0zIDE0SDIxVjE2SDNWMTRaTTMgOUgxN1YxMUgzVjlaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIFRyKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDRIMjFWNkgzVjRaTTcgMTlIMjFWMjFIN1YxOVpNMyAxNEgyMVYxNkgzVjE0Wk03IDlIMjFWMTFIN1Y5WlwiIH0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBIcihlKSB7XG4gIHJldHVybiBTKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNOCAxMUgxMi41QzEzLjg4MDcgMTEgMTUgOS44ODA3MSAxNSA4LjVDMTUgNy4xMTkyOSAxMy44ODA3IDYgMTIuNSA2SDhWMTFaTTE4IDE1LjVDMTggMTcuOTg1MyAxNS45ODUzIDIwIDEzLjUgMjBINlY0SDEyLjVDMTQuOTg1MyA0IDE3IDYuMDE0NzIgMTcgOC41QzE3IDkuNzA0MzEgMTYuNTI2OSAxMC43OTgxIDE1Ljc1NjQgMTEuNjA1OEMxNy4wOTc5IDEyLjM4NDcgMTggMTMuODM3IDE4IDE1LjVaTTggMTNWMThIMTMuNUMxNC44ODA3IDE4IDE2IDE2Ljg4MDcgMTYgMTUuNUMxNiAxNC4xMTkzIDE0Ljg4MDcgMTMgMTMuNSAxM0g4WlwiIH0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBRdChlKSB7XG4gIHJldHVybiBTKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTMgMjBIMTFWMTNINFYyMEgyVjRINFYxMUgxMVY0SDEzVjIwWk0yMS4wMDA1IDhWMjBIMTkuMDAwNUwxOSAxMC4yMDRMMTcgMTAuNzRWOC42N0wxOS41MDA1IDhIMjEuMDAwNVpcIiB9IH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gWHQoZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTQgNFYxMUgxMVY0SDEzVjIwSDExVjEzSDRWMjBIMlY0SDRaTTE4LjUgOEMyMC41NzExIDggMjIuMjUgOS42Nzg5MyAyMi4yNSAxMS43NUMyMi4yNSAxMi42MDc0IDIxLjk2MjMgMTMuMzk3NiAyMS40NzgxIDE0LjAyOTJMMjEuMzMwMiAxNC4yMTAyTDE4LjAzNDMgMThIMjJWMjBIMTVMMTQuOTk5MyAxOC40NDRMMTkuODIwNyAxMi44OTgxQzIwLjA4ODEgMTIuNTkwOCAyMC4yNSAxMi4xODkzIDIwLjI1IDExLjc1QzIwLjI1IDEwLjc4MzUgMTkuNDY2NSAxMCAxOC41IDEwQzE3LjU4MTggMTAgMTYuODI4OCAxMC43MDcxIDE2Ljc1NTggMTEuNjA2NUwxNi43NSAxMS43NUgxNC43NUMxNC43NSA5LjY3ODkzIDE2LjQyODkgOCAxOC41IDhaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIGVuKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0yMiA4TDIxLjk5ODQgMTBMMTkuNDkzNCAxMi44ODNDMjEuMDgyMyAxMy4zMTg0IDIyLjI1IDE0Ljc3MjggMjIuMjUgMTYuNUMyMi4yNSAxOC41NzExIDIwLjU3MTEgMjAuMjUgMTguNSAyMC4yNUMxNi42NzQgMjAuMjUgMTUuMTUyOCAxOC45NDQ5IDE0LjgxODQgMTcuMjE2NkwxNi43ODIxIDE2LjgzNTJDMTYuOTM4NCAxNy42NDEzIDE3LjY0ODEgMTguMjUgMTguNSAxOC4yNUMxOS40NjY1IDE4LjI1IDIwLjI1IDE3LjQ2NjUgMjAuMjUgMTYuNUMyMC4yNSAxNS41MzM1IDE5LjQ2NjUgMTQuNzUgMTguNSAxNC43NUMxOC4yMTQgMTQuNzUgMTcuOTQ0IDE0LjgxODYgMTcuNzA1NiAxNC45NDAzTDE2LjM5OTIgMTMuMzkzMkwxOS4zNDg0IDEwSDE1VjhIMjJaTTQgNFYxMUgxMVY0SDEzVjIwSDExVjEzSDRWMjBIMlY0SDRaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIEVyKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDRIMjFWNkgzVjRaTTMgMTlIMjFWMjFIM1YxOVpNMTEgMTRIMjFWMTZIMTFWMTRaTTExIDlIMjFWMTFIMTFWOVpNMyAxMi41TDcgOVYxNkwzIDEyLjVaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIE1yKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0zIDRIMjFWNkgzVjRaTTMgMTlIMjFWMjFIM1YxOVpNMTEgMTRIMjFWMTZIMTFWMTRaTTExIDlIMjFWMTFIMTFWOVpNNyAxMi41TDMgMTZWOUw3IDEyLjVaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIFJyKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xNSAyMEg3VjE4SDkuOTI2NjFMMTIuMDQyNSA2SDlWNEgxN1Y2SDE0LjA3MzRMMTEuOTU3NSAxOEgxNVYyMFpcIiB9IH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gVnIoZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTE3IDE3SDIyVjE5SDE5VjIySDE3VjE3Wk03IDdIMlY1SDVWMkg3VjdaTTE4LjM2NCAxNS41MzU1TDE2Ljk0OTcgMTQuMTIxM0wxOC4zNjQgMTIuNzA3MUMyMC4zMTY2IDEwLjc1NDUgMjAuMzE2NiA3LjU4ODY2IDE4LjM2NCA1LjYzNjA0QzE2LjQxMTMgMy42ODM0MiAxMy4yNDU1IDMuNjgzNDIgMTEuMjkyOSA1LjYzNjA0TDkuODc4NjggNy4wNTAyNUw4LjQ2NDQ3IDUuNjM2MDRMOS44Nzg2OCA0LjIyMTgzQzEyLjYxMjMgMS40ODgxNiAxNy4wNDQ1IDEuNDg4MTYgMTkuNzc4MiA0LjIyMTgzQzIyLjUxMTggNi45NTU1IDIyLjUxMTggMTEuMzg3NyAxOS43NzgyIDE0LjEyMTNMMTguMzY0IDE1LjUzNTVaTTE1LjUzNTUgMTguMzY0TDE0LjEyMTMgMTkuNzc4MkMxMS4zODc3IDIyLjUxMTggNi45NTU1IDIyLjUxMTggNC4yMjE4MyAxOS43NzgyQzEuNDg4MTYgMTcuMDQ0NSAxLjQ4ODE2IDEyLjYxMjMgNC4yMjE4MyA5Ljg3ODY4TDUuNjM2MDQgOC40NjQ0N0w3LjA1MDI1IDkuODc4NjhMNS42MzYwNCAxMS4yOTI5QzMuNjgzNDIgMTMuMjQ1NSAzLjY4MzQyIDE2LjQxMTMgNS42MzYwNCAxOC4zNjRDNy41ODg2NiAyMC4zMTY2IDEwLjc1NDUgMjAuMzE2NiAxMi43MDcxIDE4LjM2NEwxNC4xMjEzIDE2Ljk0OTdMMTUuNTM1NSAxOC4zNjRaTTE0LjgyODQgNy43NTczNkwxNi4yNDI2IDkuMTcxNTdMOS4xNzE1NyAxNi4yNDI2TDcuNzU3MzYgMTQuODI4NEwxNC44Mjg0IDcuNzU3MzZaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIHRuKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xOC4zNjQzIDE1LjUzNTNMMTYuOTUgMTQuMTIxMUwxOC4zNjQzIDEyLjcwNjlDMjAuMzE2OSAxMC43NTQzIDIwLjMxNjkgNy41ODg0NyAxOC4zNjQzIDUuNjM1ODVDMTYuNDExNiAzLjY4MzIzIDEzLjI0NTggMy42ODMyMyAxMS4yOTMyIDUuNjM1ODVMOS44Nzg5OCA3LjA1MDA3TDguNDY0NzcgNS42MzU4NUw5Ljg3ODk4IDQuMjIxNjRDMTIuNjEyNyAxLjQ4Nzk3IDE3LjA0NDggMS40ODc5NyAxOS43Nzg1IDQuMjIxNjRDMjIuNTEyMSA2Ljk1NTMxIDIyLjUxMjEgMTEuMzg3NSAxOS43Nzg1IDE0LjEyMTFMMTguMzY0MyAxNS41MzUzWk0xNS41MzU4IDE4LjM2MzhMMTQuMTIxNiAxOS43NzhDMTEuMzg4IDIyLjUxMTcgNi45NTU4IDIyLjUxMTcgNC4yMjIxMyAxOS43NzhDMS40ODg0NiAxNy4wNDQzIDEuNDg4NDYgMTIuNjEyMiA0LjIyMjEzIDkuODc4NDlMNS42MzYzNCA4LjQ2NDI4TDcuMDUwNTUgOS44Nzg0OUw1LjYzNjM0IDExLjI5MjdDMy42ODM3MiAxMy4yNDUzIDMuNjgzNzIgMTYuNDExMiA1LjYzNjM0IDE4LjM2MzhDNy41ODg5NiAyMC4zMTY0IDEwLjc1NDggMjAuMzE2NCAxMi43MDc0IDE4LjM2MzhMMTQuMTIxNiAxNi45NDk2TDE1LjUzNTggMTguMzYzOFpNMTQuODI4NyA3Ljc1NzE3TDE2LjI0MjkgOS4xNzEzOUw5LjE3MTg3IDE2LjI0MjVMNy43NTc2NiAxNC44MjgyTDE0LjgyODcgNy43NTcxN1pcIiB9IH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gbm4oZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTggNEgyMVY2SDhWNFpNNSAzVjZINlY3SDNWNkg0VjRIM1YzSDVaTTMgMTRWMTEuNUg1VjExSDNWMTBINlYxMi41SDRWMTNINlYxNEgzWk01IDE5LjVIM1YxOC41SDVWMThIM1YxN0g2VjIxSDNWMjBINVYxOS41Wk04IDExSDIxVjEzSDhWMTFaTTggMThIMjFWMjBIOFYxOFpcIiB9IH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gcm4oZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTggNEgyMVY2SDhWNFpNNC41IDYuNUMzLjY3MTU3IDYuNSAzIDUuODI4NDMgMyA1QzMgNC4xNzE1NyAzLjY3MTU3IDMuNSA0LjUgMy41QzUuMzI4NDMgMy41IDYgNC4xNzE1NyA2IDVDNiA1LjgyODQzIDUuMzI4NDMgNi41IDQuNSA2LjVaTTQuNSAxMy41QzMuNjcxNTcgMTMuNSAzIDEyLjgyODQgMyAxMkMzIDExLjE3MTYgMy42NzE1NyAxMC41IDQuNSAxMC41QzUuMzI4NDMgMTAuNSA2IDExLjE3MTYgNiAxMkM2IDEyLjgyODQgNS4zMjg0MyAxMy41IDQuNSAxMy41Wk00LjUgMjAuNEMzLjY3MTU3IDIwLjQgMyAxOS43Mjg0IDMgMTguOUMzIDE4LjA3MTYgMy42NzE1NyAxNy40IDQuNSAxNy40QzUuMzI4NDMgMTcuNCA2IDE4LjA3MTYgNiAxOC45QzYgMTkuNzI4NCA1LjMyODQzIDIwLjQgNC41IDIwLjRaTTggMTFIMjFWMTNIOFYxMVpNOCAxOEgyMVYyMEg4VjE4WlwiIH0gfV0gfSkoZSk7XG59XG5mdW5jdGlvbiBCcihlKSB7XG4gIHJldHVybiBTKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTcuMTUzOCAxNEMxNy4zODQ2IDE0LjUxNjEgMTcuNSAxNS4wODkzIDE3LjUgMTUuNzE5NkMxNy41IDE3LjA2MjUgMTYuOTc2MiAxOC4xMTE2IDE1LjkyODYgMTguODY3QzE0Ljg4MDkgMTkuNjIyMyAxMy40MzM1IDIwIDExLjU4NjIgMjBDOS45NDY3NCAyMCA4LjMyMzM1IDE5LjYxODUgNi43MTU5MiAxOC44NTU1VjE2LjYwMDlDOC4yMzUzOCAxNy40NzgzIDkuNzkwOCAxNy45MTcgMTEuMzgyMiAxNy45MTdDMTMuOTMzMyAxNy45MTcgMTUuMjEyOCAxNy4xODQ2IDE1LjIyMDggMTUuNzE5NkMxNS4yMjA4IDE1LjA5MzkgMTUuMDA0OSAxNC41NTk4IDE0LjU3MzEgMTQuMTE3M0MxNC41MzM5IDE0LjA3NzIgMTQuNDkzOSAxNC4wMzgxIDE0LjQ1MzEgMTRIM1YxMkgyMVYxNEgxNy4xNTM4Wk0xMy4wNzYgMTFINy42MjkwOEM3LjQ1NjYgMTAuODQzMyA3LjI5NjE2IDEwLjY2OTIgNy4xNDc3NiAxMC40Nzc4QzYuNzE1OTIgOS45MjA4NCA2LjUgOS4yNDU1OSA2LjUgOC40NTIwN0M2LjUgNy4yMTYwMiA2Ljk2NTgzIDYuMTY1IDcuODk3NDkgNS4yOTlDOC44MjkxNiA0LjQzMjk5IDEwLjI3MDYgNCAxMi4yMjE5IDRDMTMuNjkzNCA0IDE1LjEwMDkgNC4zMjgwOCAxNi40NDQ0IDQuOTg0MjZWNy4xMzU5MUMxNS4yNDQ4IDYuNDQ5MjEgMTMuOTI5MyA2LjEwNTg3IDEyLjQ5NzggNi4xMDU4N0MxMC4wMTg3IDYuMTA1ODcgOC43NzkxNyA2Ljg4NzkzIDguNzc5MTcgOC40NTIwN0M4Ljc3OTE3IDguODcxNzIgOC45OTcwOSA5LjIzNzk2IDkuNDMyOTMgOS41NTA3OUM5Ljg2ODc4IDkuODYzNjIgMTAuNDA2NiAxMC4xMTM1IDExLjA0NjMgMTAuMzAwNEMxMS42NjY1IDEwLjQ4MTYgMTIuMzQzMSAxMC43MTQ4IDEzLjA3NiAxMUgxMy4wNzZaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIExyKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xMyAxMFYxNEgxOVYxMEgxM1pNMTEgMTBINVYxNEgxMVYxMFpNMTMgMTlIMTlWMTZIMTNWMTlaTTExIDE5VjE2SDVWMTlIMTFaTTEzIDVWOEgxOVY1SDEzWk0xMSA1SDVWOEgxMVY1Wk00IDNIMjBDMjAuNTUyMyAzIDIxIDMuNDQ3NzIgMjEgNFYyMEMyMSAyMC41NTIzIDIwLjU1MjMgMjEgMjAgMjFINEMzLjQ0NzcyIDIxIDMgMjAuNTUyMyAzIDIwVjRDMyAzLjQ0NzcyIDMuNDQ3NzIgMyA0IDNaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIGNlKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xMyA2VjIxSDExVjZINVY0SDE5VjZIMTNaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIERyKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk04IDNWMTJDOCAxNC4yMDkxIDkuNzkwODYgMTYgMTIgMTZDMTQuMjA5MSAxNiAxNiAxNC4yMDkxIDE2IDEyVjNIMThWMTJDMTggMTUuMzEzNyAxNS4zMTM3IDE4IDEyIDE4QzguNjg2MjkgMTggNiAxNS4zMTM3IDYgMTJWM0g4Wk00IDIwSDIwVjIySDRWMjBaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIF9yKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk01IDExLjEwMDVMNyA5LjEwMDVMMTIuNSAxNC42MDA1TDE2IDExLjEwMDVMMTkgMTQuMTAwNVY1SDVWMTEuMTAwNVpNNCAzSDIwQzIwLjU1MjMgMyAyMSAzLjQ0NzcyIDIxIDRWMjBDMjEgMjAuNTUyMyAyMC41NTIzIDIxIDIwIDIxSDRDMy40NDc3MiAyMSAzIDIwLjU1MjMgMyAyMFY0QzMgMy40NDc3MiAzLjQ0NzcyIDMgNCAzWk0xNS41IDEwQzE0LjY3MTYgMTAgMTQgOS4zMjg0MyAxNCA4LjVDMTQgNy42NzE1NyAxNC42NzE2IDcgMTUuNSA3QzE2LjMyODQgNyAxNyA3LjY3MTU3IDE3IDguNUMxNyA5LjMyODQzIDE2LjMyODQgMTAgMTUuNSAxMFpcIiB9IH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gSXIoZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTIwIDNDMjAuNTUyMyAzIDIxIDMuNDQ3NzIgMjEgNFY1Ljc1N0wxOSA3Ljc1N1Y1SDVWMTMuMUw5IDkuMTAwNUwxMy4zMjggMTMuNDI5TDEyLjAwMTIgMTQuNzU2MkwxMS45OTUgMTguOTk1TDE2LjI0MTQgMTkuMDAxMkwxNy41NzEgMTcuNjcxTDE4Ljg5OTUgMTlIMTlWMTYuMjQyTDIxIDE0LjI0MlYyMEMyMSAyMC41NTIzIDIwLjU1MjMgMjEgMjAgMjFINEMzLjQ0NzcyIDIxIDMgMjAuNTUyMyAzIDIwVjRDMyAzLjQ0NzcyIDMuNDQ3NzIgMyA0IDNIMjBaTTIxLjc3ODIgNy44MDc2MUwyMy4xOTI0IDkuMjIxODNMMTUuNDE0MiAxN0wxMy45OTc5IDE2Ljk5NzlMMTQgMTUuNTg1OEwyMS43NzgyIDcuODA3NjFaTTE1LjUgN0MxNi4zMjg0IDcgMTcgNy42NzE1NyAxNyA4LjVDMTcgOS4zMjg0MyAxNi4zMjg0IDEwIDE1LjUgMTBDMTQuNjcxNiAxMCAxNCA5LjMyODQzIDE0IDguNUMxNCA3LjY3MTU3IDE0LjY3MTYgNyAxNS41IDdaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIE9yKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjQgMjRcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBkOiBcIk0xMCA2VjhINVYxOUgxNlYxNEgxOFYyMEMxOCAyMC41NTIzIDE3LjU1MjMgMjEgMTcgMjFINEMzLjQ0NzcyIDIxIDMgMjAuNTUyMyAzIDIwVjdDMyA2LjQ0NzcyIDMuNDQ3NzIgNiA0IDZIMTBaTTIxIDNWMTJMMTcuMjA2IDguMjA3TDExLjIwNzEgMTQuMjA3MUw5Ljc5Mjg5IDEyLjc5MjlMMTUuNzkyIDYuNzkzTDEyIDNIMjFaXCIgfSB9XSB9KShlKTtcbn1cbmZ1bmN0aW9uIEsoZSkge1xuICBjb25zdCB0ID0gZWUoKTtcbiAgaWYgKGUgfHwgKGUgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmVkaXRvciksICFlKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiJ2VkaXRvcicgaXMgcmVxdWlyZWQsIGVpdGhlciBmcm9tIEJsb2NrTm90ZUNvbnRleHQgb3IgYXMgYSBmdW5jdGlvbiBhcmd1bWVudFwiXG4gICAgKTtcbiAgY29uc3QgbiA9IGUsIFtyLCBpXSA9IHAoKCkgPT4ge1xuICAgIHZhciBsO1xuICAgIHJldHVybiAoKGwgPSBuLmdldFNlbGVjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogbC5ibG9ja3MpIHx8IFtuLmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrXTtcbiAgfSk7XG4gIHJldHVybiBVKFxuICAgICgpID0+IHtcbiAgICAgIHZhciBsO1xuICAgICAgcmV0dXJuIGkoXG4gICAgICAgICgobCA9IG4uZ2V0U2VsZWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBsLmJsb2NrcykgfHwgW24uZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkuYmxvY2tdXG4gICAgICApO1xuICAgIH0sXG4gICAgblxuICApLCByO1xufVxuY29uc3QgUHIgPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIG8uanN4cyhLZSwgeyBnYXA6IDAsIGNsYXNzTmFtZTogXCJibi10b29sdGlwXCIsIGNoaWxkcmVuOiBbXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChzZSwgeyBzaXplOiBcInNtXCIsIGNoaWxkcmVuOiBlLm1haW5Ub29sdGlwIH0pLFxuICBlLnNlY29uZGFyeVRvb2x0aXAgJiYgLyogQF9fUFVSRV9fICovIG8uanN4KHNlLCB7IHNpemU6IFwieHNcIiwgY2hpbGRyZW46IGUuc2Vjb25kYXJ5VG9vbHRpcCB9KVxuXSB9KSwgUCA9IHVlKFxuICAoZSwgdCkgPT4ge1xuICAgIGNvbnN0IG4gPSBlLmljb247XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICAgIHNyLFxuICAgICAge1xuICAgICAgICB3aXRoaW5Qb3J0YWw6ICExLFxuICAgICAgICBsYWJlbDogLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgICAgIFByLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1haW5Ub29sdGlwOiBlLm1haW5Ub29sdGlwLFxuICAgICAgICAgICAgc2Vjb25kYXJ5VG9vbHRpcDogZS5zZWNvbmRhcnlUb29sdGlwXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBjaGlsZHJlbjogZS5jaGlsZHJlbiA/IC8qIEBfX1BVUkVfXyAqLyBvLmpzeHMoXG4gICAgICAgICAgR2UsXG4gICAgICAgICAge1xuICAgICAgICAgICAgb25Nb3VzZURvd246IChyKSA9PiB7XG4gICAgICAgICAgICAgIE5lKCkgJiYgci5jdXJyZW50VGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbGljazogZS5vbkNsaWNrLFxuICAgICAgICAgICAgXCJkYXRhLXNlbGVjdGVkXCI6IGUuaXNTZWxlY3RlZCA/IFwidHJ1ZVwiIDogdm9pZCAwLFxuICAgICAgICAgICAgXCJkYXRhLXRlc3RcIjogZS5tYWluVG9vbHRpcC5zbGljZSgwLCAxKS50b0xvd2VyQ2FzZSgpICsgZS5tYWluVG9vbHRpcC5yZXBsYWNlKC9cXHMrL2csIFwiXCIpLnNsaWNlKDEpLFxuICAgICAgICAgICAgc2l6ZTogXCJ4c1wiLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGUuaXNEaXNhYmxlZCB8fCAhMSxcbiAgICAgICAgICAgIHJlZjogdCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIG4gJiYgLyogQF9fUFVSRV9fICovIG8uanN4KG4sIHt9KSxcbiAgICAgICAgICAgICAgZS5jaGlsZHJlblxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgKSA6IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICAgICAgICBadCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvbk1vdXNlRG93bjogKHIpID0+IHtcbiAgICAgICAgICAgICAgTmUoKSAmJiByLmN1cnJlbnRUYXJnZXQuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsaWNrOiBlLm9uQ2xpY2ssXG4gICAgICAgICAgICBcImRhdGEtc2VsZWN0ZWRcIjogZS5pc1NlbGVjdGVkID8gXCJ0cnVlXCIgOiB2b2lkIDAsXG4gICAgICAgICAgICBcImRhdGEtdGVzdFwiOiBlLm1haW5Ub29sdGlwLnNsaWNlKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBlLm1haW5Ub29sdGlwLnJlcGxhY2UoL1xccysvZywgXCJcIikuc2xpY2UoMSksXG4gICAgICAgICAgICBzaXplOiAzMCxcbiAgICAgICAgICAgIGRpc2FibGVkOiBlLmlzRGlzYWJsZWQgfHwgITEsXG4gICAgICAgICAgICByZWY6IHQsXG4gICAgICAgICAgICBjaGlsZHJlbjogbiAmJiAvKiBAX19QVVJFX18gKi8gby5qc3gobiwge30pXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgfVxuKSwgQXIgPSB7XG4gIGJvbGQ6IEhyLFxuICBpdGFsaWM6IFJyLFxuICB1bmRlcmxpbmU6IERyLFxuICBzdHJpa2U6IEJyLFxuICBjb2RlOiBDclxufSwgRnIgPSB7XG4gIGJvbGQ6IFwiTW9kK0JcIixcbiAgaXRhbGljOiBcIk1vZCtJXCIsXG4gIHVuZGVybGluZTogXCJNb2QrVVwiLFxuICBzdHJpa2U6IFwiTW9kK1NoaWZ0K1hcIixcbiAgY29kZTogXCJcIlxufTtcbmZ1bmN0aW9uIE5yKGUsIHQpIHtcbiAgcmV0dXJuIGUgaW4gdC5zY2hlbWEuc3R5bGVTY2hlbWEgJiYgdC5zY2hlbWEuc3R5bGVTY2hlbWFbZV0udHlwZSA9PT0gZSAmJiB0LnNjaGVtYS5zdHlsZVNjaGVtYVtlXS5wcm9wU2NoZW1hID09PSBcImJvb2xlYW5cIjtcbn1cbmNvbnN0IGtlID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IFYoKSwgbiA9IE5yKFxuICAgIGUuYmFzaWNUZXh0U3R5bGUsXG4gICAgdFxuICApLCByID0gSyh0KSwgW2ksIGxdID0gcChcbiAgICBlLmJhc2ljVGV4dFN0eWxlIGluIHQuZ2V0QWN0aXZlU3R5bGVzKClcbiAgKTtcbiAgVSgoKSA9PiB7XG4gICAgbiAmJiBsKGUuYmFzaWNUZXh0U3R5bGUgaW4gdC5nZXRBY3RpdmVTdHlsZXMoKSk7XG4gIH0sIHQpO1xuICBjb25zdCBjID0gKGQpID0+IHtcbiAgICBpZiAobikge1xuICAgICAgaWYgKHQuZm9jdXMoKSwgdC5zY2hlbWEuc3R5bGVTY2hlbWFbZF0ucHJvcFNjaGVtYSAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbiBvbmx5IHRvZ2dsZSBib29sZWFuIHN0eWxlc1wiKTtcbiAgICAgIHQudG9nZ2xlU3R5bGVzKHsgW2RdOiAhMCB9KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBCKCgpID0+IG4gPyAhIXIuZmluZCgoZCkgPT4gZC5jb250ZW50ICE9PSB2b2lkIDApIDogITEsIFtuLCByXSkgPyAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgUCxcbiAgICB7XG4gICAgICBvbkNsaWNrOiAoKSA9PiBjKGUuYmFzaWNUZXh0U3R5bGUpLFxuICAgICAgaXNTZWxlY3RlZDogaSxcbiAgICAgIG1haW5Ub29sdGlwOiBlLmJhc2ljVGV4dFN0eWxlLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBlLmJhc2ljVGV4dFN0eWxlLnNsaWNlKDEpLFxuICAgICAgc2Vjb25kYXJ5VG9vbHRpcDogamUoRnJbZS5iYXNpY1RleHRTdHlsZV0pLFxuICAgICAgaWNvbjogQXJbZS5iYXNpY1RleHRTdHlsZV1cbiAgICB9XG4gICkgOiBudWxsO1xufTtcbmZ1bmN0aW9uIFhlKCkge1xuICBjb25zdCBlID0gWShudWxsKTtcbiAgcmV0dXJuIHtcbiAgICByZWY6IGUsXG4gICAgdXBkYXRlTWF4SGVpZ2h0OiAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGUuY3VycmVudCAmJiBlLmN1cnJlbnQuY2hpbGRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgICAgZS5jdXJyZW50LmZpcnN0RWxlbWVudENoaWxkLnN0eWxlLm1heEhlaWdodCA9IFwibm9uZVwiO1xuICAgICAgICAgIGNvbnN0IHQgPSBlLmN1cnJlbnQuZmlyc3RFbGVtZW50Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgZS5jdXJyZW50LmZpcnN0RWxlbWVudENoaWxkLnN0eWxlLm1heEhlaWdodCA9IGAke01hdGgubWluKFxuICAgICAgICAgICAgdC50b3AgPj0gMCA/IHdpbmRvdy5pbm5lckhlaWdodCAtIHQudG9wIC0gMjAgOiB0LmJvdHRvbSAtIDIwXG4gICAgICAgICAgKX1weGA7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBVZSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBlLnRleHRDb2xvciB8fCBcImRlZmF1bHRcIiwgbiA9IGUuYmFja2dyb3VuZENvbG9yIHx8IFwiZGVmYXVsdFwiLCByID0gZS5zaXplIHx8IDE2LCBpID0gQihcbiAgICAoKSA9PiAoe1xuICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgICBmb250U2l6ZTogKHIgKiAwLjc1KS50b1N0cmluZygpICsgXCJweFwiLFxuICAgICAgaGVpZ2h0OiByLnRvU3RyaW5nKCkgKyBcInB4XCIsXG4gICAgICBsaW5lSGVpZ2h0OiByLnRvU3RyaW5nKCkgKyBcInB4XCIsXG4gICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICB3aWR0aDogci50b1N0cmluZygpICsgXCJweFwiXG4gICAgfSksXG4gICAgW3JdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgenQsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcImJuLWNvbG9yLWljb25cIixcbiAgICAgIFwiZGF0YS1iYWNrZ3JvdW5kLWNvbG9yXCI6IG4sXG4gICAgICBcImRhdGEtdGV4dC1jb2xvclwiOiB0LFxuICAgICAgc3R5bGU6IGksXG4gICAgICBjaGlsZHJlbjogXCJBXCJcbiAgICB9XG4gICk7XG59O1xuZnVuY3Rpb24gJGUoZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2ZXJzaW9uOiBcIjEuMlwiLCBiYXNlUHJvZmlsZTogXCJ0aW55XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIgfSwgY2hpbGQ6IFt7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTYuOTcyIDYuMjUxYy0uOTY3LS41MzgtMi4xODUtLjE4OC0yLjcyLjc3N2wtMy43MTMgNi42ODItMi4xMjUtMi4xMjVjLS43ODEtLjc4MS0yLjA0Ny0uNzgxLTIuODI4IDAtLjc4MS43ODEtLjc4MSAyLjA0NyAwIDIuODI4bDQgNGMuMzc4LjM3OS44ODguNTg3IDEuNDE0LjU4N2wuMjc3LS4wMmMuNjIxLS4wODcgMS4xNjYtLjQ2IDEuNDcxLTEuMDA5bDUtOWMuNTM3LS45NjYuMTg5LTIuMTgzLS43NzYtMi43MnpcIiB9IH1dIH0pKGUpO1xufVxuY29uc3Qgb24gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gKCkgPT4gZS50ZXh0ID8gLyogQF9fUFVSRV9fICovIG8uanN4cyhvLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIG8uanN4KHcuTGFiZWwsIHsgY2hpbGRyZW46IFwiVGV4dFwiIH0pLFxuICAgIFtcbiAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgXCJncmF5XCIsXG4gICAgICBcImJyb3duXCIsXG4gICAgICBcInJlZFwiLFxuICAgICAgXCJvcmFuZ2VcIixcbiAgICAgIFwieWVsbG93XCIsXG4gICAgICBcImdyZWVuXCIsXG4gICAgICBcImJsdWVcIixcbiAgICAgIFwicHVycGxlXCIsXG4gICAgICBcInBpbmtcIlxuICAgIF0ubWFwKChyKSA9PiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICB3Lkl0ZW0sXG4gICAgICB7XG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICBlLm9uQ2xpY2sgJiYgZS5vbkNsaWNrKCksIGUudGV4dC5zZXRDb2xvcihyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9uZW50OiBcImRpdlwiLFxuICAgICAgICBcImRhdGEtdGVzdFwiOiBcInRleHQtY29sb3ItXCIgKyByLFxuICAgICAgICBsZWZ0U2VjdGlvbjogLyogQF9fUFVSRV9fICovIG8uanN4KFVlLCB7IHRleHRDb2xvcjogciwgc2l6ZTogZS5pY29uU2l6ZSB9KSxcbiAgICAgICAgcmlnaHRTZWN0aW9uOiBlLnRleHQuY29sb3IgPT09IHIgPyAvKiBAX19QVVJFX18gKi8gby5qc3goJGUsIHsgc2l6ZTogMjAsIGNsYXNzTmFtZTogXCJibi10aWNrLWljb25cIiB9KSA6IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJibi10aWNrLXNwYWNlXCIgfSksXG4gICAgICAgIGNoaWxkcmVuOiByLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgci5zbGljZSgxKVxuICAgICAgfSxcbiAgICAgIFwidGV4dC1jb2xvci1cIiArIHJcbiAgICApKVxuICBdIH0pIDogbnVsbCwgbiA9ICgpID0+IGUuYmFja2dyb3VuZCA/IC8qIEBfX1BVUkVfXyAqLyBvLmpzeHMoby5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh3LkxhYmVsLCB7IGNoaWxkcmVuOiBcIkJhY2tncm91bmRcIiB9KSxcbiAgICBbXG4gICAgICBcImRlZmF1bHRcIixcbiAgICAgIFwiZ3JheVwiLFxuICAgICAgXCJicm93blwiLFxuICAgICAgXCJyZWRcIixcbiAgICAgIFwib3JhbmdlXCIsXG4gICAgICBcInllbGxvd1wiLFxuICAgICAgXCJncmVlblwiLFxuICAgICAgXCJibHVlXCIsXG4gICAgICBcInB1cnBsZVwiLFxuICAgICAgXCJwaW5rXCJcbiAgICBdLm1hcCgocikgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgdy5JdGVtLFxuICAgICAge1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgZS5vbkNsaWNrICYmIGUub25DbGljaygpLCBlLmJhY2tncm91bmQuc2V0Q29sb3Iocik7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvbmVudDogXCJkaXZcIixcbiAgICAgICAgXCJkYXRhLXRlc3RcIjogXCJiYWNrZ3JvdW5kLWNvbG9yLVwiICsgcixcbiAgICAgICAgbGVmdFNlY3Rpb246IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChVZSwgeyBiYWNrZ3JvdW5kQ29sb3I6IHIsIHNpemU6IGUuaWNvblNpemUgfSksXG4gICAgICAgIHJpZ2h0U2VjdGlvbjogZS5iYWNrZ3JvdW5kLmNvbG9yID09PSByID8gLyogQF9fUFVSRV9fICovIG8uanN4KCRlLCB7IHNpemU6IDIwLCBjbGFzc05hbWU6IFwiYm4tdGljay1pY29uXCIgfSkgOiAvKiBAX19QVVJFX18gKi8gby5qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYm4tdGljay1zcGFjZVwiIH0pLFxuICAgICAgICBjaGlsZHJlbjogci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHIuc2xpY2UoMSlcbiAgICAgIH0sXG4gICAgICBcImJhY2tncm91bmQtY29sb3ItXCIgKyByXG4gICAgKSlcbiAgXSB9KSA6IG51bGw7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3hzKG8uRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gby5qc3godCwge30pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChuLCB7fSlcbiAgXSB9KTtcbn07XG5mdW5jdGlvbiBIdChlLCB0KSB7XG4gIHJldHVybiBgJHtlfUNvbG9yYCBpbiB0LnNjaGVtYS5zdHlsZVNjaGVtYSAmJiB0LnNjaGVtYS5zdHlsZVNjaGVtYVtgJHtlfUNvbG9yYF0udHlwZSA9PT0gYCR7ZX1Db2xvcmAgJiYgdC5zY2hlbWEuc3R5bGVTY2hlbWFbYCR7ZX1Db2xvcmBdLnByb3BTY2hlbWEgPT09IFwic3RyaW5nXCI7XG59XG5jb25zdCBaciA9ICgpID0+IHtcbiAgY29uc3QgZSA9IFYoKSwgdCA9IEh0KFwidGV4dFwiLCBlKSwgbiA9IEh0KFwiYmFja2dyb3VuZFwiLCBlKSwgciA9IEsoZSksIFtpLCBsXSA9IHAoXG4gICAgdCAmJiBlLmdldEFjdGl2ZVN0eWxlcygpLnRleHRDb2xvciB8fCBcImRlZmF1bHRcIlxuICApLCBbYywgc10gPSBwKFxuICAgIG4gJiYgZS5nZXRBY3RpdmVTdHlsZXMoKS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJkZWZhdWx0XCJcbiAgKTtcbiAgVSgoKSA9PiB7XG4gICAgdCAmJiBsKGUuZ2V0QWN0aXZlU3R5bGVzKCkudGV4dENvbG9yIHx8IFwiZGVmYXVsdFwiKSwgbiAmJiBzKFxuICAgICAgZS5nZXRBY3RpdmVTdHlsZXMoKS5iYWNrZ3JvdW5kQ29sb3IgfHwgXCJkZWZhdWx0XCJcbiAgICApO1xuICB9LCBlKTtcbiAgY29uc3QgeyByZWY6IGQsIHVwZGF0ZU1heEhlaWdodDogZiB9ID0gWGUoKSwgaCA9IEgoXG4gICAgKEMpID0+IHtcbiAgICAgIGlmICghdClcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJUcmllZCB0byBzZXQgdGV4dCBjb2xvciwgYnV0IHN0eWxlIGRvZXMgbm90IGV4aXN0IGluIGVkaXRvciBzY2hlbWEuXCJcbiAgICAgICAgKTtcbiAgICAgIGUuZm9jdXMoKSwgQyA9PT0gXCJkZWZhdWx0XCIgPyBlLnJlbW92ZVN0eWxlcyh7IHRleHRDb2xvcjogQyB9KSA6IGUuYWRkU3R5bGVzKHsgdGV4dENvbG9yOiBDIH0pO1xuICAgIH0sXG4gICAgW2UsIHRdXG4gICksIGIgPSBIKFxuICAgIChDKSA9PiB7XG4gICAgICBpZiAoIW4pXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiVHJpZWQgdG8gc2V0IGJhY2tncm91bmQgY29sb3IsIGJ1dCBzdHlsZSBkb2VzIG5vdCBleGlzdCBpbiBlZGl0b3Igc2NoZW1hLlwiXG4gICAgICAgICk7XG4gICAgICBlLmZvY3VzKCksIEMgPT09IFwiZGVmYXVsdFwiID8gZS5yZW1vdmVTdHlsZXMoeyBiYWNrZ3JvdW5kQ29sb3I6IEMgfSkgOiBlLmFkZFN0eWxlcyh7IGJhY2tncm91bmRDb2xvcjogQyB9KTtcbiAgICB9LFxuICAgIFtuLCBlXVxuICApO1xuICByZXR1cm4gQigoKSA9PiB7XG4gICAgaWYgKCF0ICYmICFuKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAoY29uc3QgQyBvZiByKVxuICAgICAgaWYgKEMuY29udGVudCAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9LCBbbiwgciwgdF0pID8gLyogQF9fUFVSRV9fICovIG8uanN4cyh3LCB7IHdpdGhpblBvcnRhbDogITEsIG9uT3BlbjogZiwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gby5qc3gody5UYXJnZXQsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICAgIFAsXG4gICAgICB7XG4gICAgICAgIG1haW5Ub29sdGlwOiBcIkNvbG9yc1wiLFxuICAgICAgICBpY29uOiAoKSA9PiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgICAgVWUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dENvbG9yOiBpLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjLFxuICAgICAgICAgICAgc2l6ZTogMjBcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcImRpdlwiLCB7IHJlZjogZCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh3LkRyb3Bkb3duLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICBvbixcbiAgICAgIHtcbiAgICAgICAgdGV4dDogdCA/IHtcbiAgICAgICAgICBjb2xvcjogaSxcbiAgICAgICAgICBzZXRDb2xvcjogaFxuICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICBiYWNrZ3JvdW5kOiBuID8ge1xuICAgICAgICAgIGNvbG9yOiBjLFxuICAgICAgICAgIHNldENvbG9yOiBiXG4gICAgICAgIH0gOiB2b2lkIDBcbiAgICAgIH1cbiAgICApIH0pIH0pXG4gIF0gfSkgOiBudWxsO1xufSwgYW4gPSB1ZSgoeyBjbGFzc05hbWU6IGUsIC4uLnQgfSwgbikgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KFxuICBLZSxcbiAge1xuICAgIC4uLnQsXG4gICAgY2xhc3NOYW1lOiBkZShcImJuLXRvb2xiYXItaW5wdXQtZHJvcGRvd25cIiwgZSB8fCBcIlwiKSxcbiAgICByZWY6IG4sXG4gICAgY2hpbGRyZW46IHQuY2hpbGRyZW5cbiAgfVxuKSksIHpyID0ge1xuICB0ZXh0OiBVdCxcbiAgZmlsZTogJHRcbn0sIFdlID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IGUuaWNvbiwgbiA9IHpyW2UudHlwZV07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goWWUsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChuLCB7IHNpemU6IFwieHNcIiwgaWNvbjogLyogQF9fUFVSRV9fICovIG8uanN4KHQsIHt9KSwgLi4uZS5pbnB1dFByb3BzIH0pIH0pO1xufSwgbG4gPSB1ZSgoeyB1cmw6IGUsIHRleHQ6IHQsIHVwZGF0ZTogbiwgLi4uciB9LCBpKSA9PiB7XG4gIGNvbnN0IFtsLCBjXSA9IHAoZSksIFtzLCBkXSA9IHAodCk7XG4gIEwoKCkgPT4ge1xuICAgIGMoZSksIGQodCk7XG4gIH0sIFt0LCBlXSk7XG4gIGNvbnN0IGYgPSBIKFxuICAgIChDKSA9PiB7XG4gICAgICBDLmtleSA9PT0gXCJFbnRlclwiICYmIChDLnByZXZlbnREZWZhdWx0KCksIG4obCwgcykpO1xuICAgIH0sXG4gICAgW24sIGwsIHNdXG4gICksIGggPSBIKFxuICAgIChDKSA9PiBjKEMuY3VycmVudFRhcmdldC52YWx1ZSksXG4gICAgW11cbiAgKSwgYiA9IEgoXG4gICAgKEMpID0+IGQoQy5jdXJyZW50VGFyZ2V0LnZhbHVlKSxcbiAgICBbXVxuICApLCBUID0gSChcbiAgICAoKSA9PiBuKGwsIHMpLFxuICAgIFtuLCBsLCBzXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uanN4cyhhbiwgeyAuLi5yLCByZWY6IGksIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgV2UsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICBpY29uOiB0bixcbiAgICAgICAgaW5wdXRQcm9wczoge1xuICAgICAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IFwiRWRpdCBVUkxcIixcbiAgICAgICAgICB2YWx1ZTogbCxcbiAgICAgICAgICBvbktleURvd246IGYsXG4gICAgICAgICAgb25DaGFuZ2U6IGgsXG4gICAgICAgICAgb25TdWJtaXQ6IFRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksXG4gICAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgV2UsXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICBpY29uOiBjZSxcbiAgICAgICAgaW5wdXRQcm9wczoge1xuICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkVkaXQgVGl0bGVcIixcbiAgICAgICAgICB2YWx1ZTogcyxcbiAgICAgICAgICBvbktleURvd246IGYsXG4gICAgICAgICAgb25DaGFuZ2U6IGIsXG4gICAgICAgICAgb25TdWJtaXQ6IFRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgXSB9KTtcbn0pLCBzbiA9IChlKSA9PiB7XG4gIGNvbnN0IFt0LCBuXSA9IHAoITEpLCByID0gSCgoKSA9PiB7XG4gICAgbighMSk7XG4gIH0sIFtdKSwgaSA9IEgoKCkgPT4ge1xuICAgIG4oITApO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3hzKFxuICAgIFgsXG4gICAge1xuICAgICAgd2l0aGluUG9ydGFsOiAhMSxcbiAgICAgIG9uT3BlbjogKCkgPT4ge1xuICAgICAgICBpKCk7XG4gICAgICB9LFxuICAgICAgb25DbG9zZTogKCkgPT4ge1xuICAgICAgICByKCk7XG4gICAgICB9LFxuICAgICAgekluZGV4OiAxZTQsXG4gICAgICAuLi5lLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KFguVGFyZ2V0LCB7IGNoaWxkcmVuOiBlLnRhcmdldCB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KFguRHJvcGRvd24sIHsgY2hpbGRyZW46IHQgPyBlLmRyb3Bkb3duIDogbnVsbCB9KVxuICAgICAgXVxuICAgIH1cbiAgKTtcbn0sIFVyID0gKCkgPT4ge1xuICBjb25zdCBlID0gVigpLCB0ID0gSyhlKSwgW24sIHJdID0gcChlLmdldFNlbGVjdGVkTGlua1VybCgpIHx8IFwiXCIpLCBbaSwgbF0gPSBwKGUuZ2V0U2VsZWN0ZWRUZXh0KCkpO1xuICBVKCgpID0+IHtcbiAgICBsKGUuZ2V0U2VsZWN0ZWRUZXh0KCkgfHwgXCJcIiksIHIoZS5nZXRTZWxlY3RlZExpbmtVcmwoKSB8fCBcIlwiKTtcbiAgfSwgZSk7XG4gIGNvbnN0IGMgPSBIKFxuICAgIChkLCBmKSA9PiB7XG4gICAgICBlLmNyZWF0ZUxpbmsoZCwgZiksIGUuZm9jdXMoKTtcbiAgICB9LFxuICAgIFtlXVxuICApO1xuICByZXR1cm4gQigoKSA9PiB7XG4gICAgZm9yIChjb25zdCBkIG9mIHQpXG4gICAgICBpZiAoZC5jb250ZW50ID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG4gIH0sIFt0XSkgPyAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgc24sXG4gICAge1xuICAgICAgdGFyZ2V0OiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgIFAsXG4gICAgICAgIHtcbiAgICAgICAgICBtYWluVG9vbHRpcDogXCJDcmVhdGUgTGlua1wiLFxuICAgICAgICAgIHNlY29uZGFyeVRvb2x0aXA6IGplKFwiTW9kK0tcIiksXG4gICAgICAgICAgaWNvbjogdG5cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIGRyb3Bkb3duOiAvKiBAX19QVVJFX18gKi8gby5qc3gobG4sIHsgdXJsOiBuLCB0ZXh0OiBpLCB1cGRhdGU6IGMgfSlcbiAgICB9XG4gICkgOiBudWxsO1xufSwgJHIgPSAoKSA9PiB7XG4gIGNvbnN0IGUgPSBWKCksIFt0LCBuXSA9IHAoKSwgciA9IEsoZSksIGkgPSBCKCgpID0+IHtcbiAgICBpZiAoci5sZW5ndGggIT09IDEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IHJbMF07XG4gICAgaWYgKF90KFwiaW1hZ2VcIiwgcywgZSkpXG4gICAgICByZXR1cm4gcztcbiAgfSwgW2UsIHJdKSwgbCA9IEgoXG4gICAgKHMpID0+IHtcbiAgICAgIGkgJiYgV24oXCJpbWFnZVwiLCBlKSAmJiBzLmtleSA9PT0gXCJFbnRlclwiICYmIChzLnByZXZlbnREZWZhdWx0KCksIGUudXBkYXRlQmxvY2soaSwge1xuICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2FwdGlvbjogdFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSxcbiAgICBbdCwgZSwgaV1cbiAgKSwgYyA9IEgoXG4gICAgKHMpID0+IG4ocy5jdXJyZW50VGFyZ2V0LnZhbHVlKSxcbiAgICBbXVxuICApO1xuICByZXR1cm4gaSA/IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICBzbixcbiAgICB7XG4gICAgICB0YXJnZXQ6IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICAgICAgUCxcbiAgICAgICAge1xuICAgICAgICAgIG1haW5Ub29sdGlwOiBcIkVkaXQgQ2FwdGlvblwiLFxuICAgICAgICAgIGljb246IGNlLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IGkucHJvcHMuY2FwdGlvbiAhPT0gXCJcIlxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgZHJvcGRvd246IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChhbiwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgICBXZSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIGljb246IGNlLFxuICAgICAgICAgIGlucHV0UHJvcHM6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHdlaXJkIHBhdHRlcm4gb2YgcHJvcHMgcGFzc2luZz9cbiAgICAgICAgICAgIHZhbHVlOiB0LFxuICAgICAgICAgICAgYXV0b0ZvY3VzOiAhMCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkVkaXQgQ2FwdGlvblwiLFxuICAgICAgICAgICAgb25LZXlEb3duOiBsLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBpLnByb3BzLmNhcHRpb24sXG4gICAgICAgICAgICBvbkNoYW5nZTogY1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKSB9KVxuICAgIH1cbiAgKSA6IG51bGw7XG59LCBXciA9ICgpID0+IHtcbiAgY29uc3QgZSA9IFYoKSwgW3QsIG5dID0gcChcbiAgICAoKSA9PiBlLmNhbk5lc3RCbG9jaygpXG4gICk7XG4gIFUoKCkgPT4ge1xuICAgIGUuY2FuTmVzdEJsb2NrKCksIG4oZS5jYW5OZXN0QmxvY2soKSk7XG4gIH0sIGUpO1xuICBjb25zdCByID0gSCgoKSA9PiB7XG4gICAgZS5mb2N1cygpLCBlLm5lc3RCbG9jaygpO1xuICB9LCBbZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgIFAsXG4gICAge1xuICAgICAgb25DbGljazogcixcbiAgICAgIGlzRGlzYWJsZWQ6ICF0LFxuICAgICAgbWFpblRvb2x0aXA6IFwiTmVzdCBCbG9ja1wiLFxuICAgICAgc2Vjb25kYXJ5VG9vbHRpcDogamUoXCJUYWJcIiksXG4gICAgICBpY29uOiBNclxuICAgIH1cbiAgKTtcbn0sIHFyID0gKCkgPT4ge1xuICBjb25zdCBlID0gVigpLCBbdCwgbl0gPSBwKFxuICAgICgpID0+IGUuY2FuVW5uZXN0QmxvY2soKVxuICApO1xuICBVKCgpID0+IHtcbiAgICBuKGUuY2FuVW5uZXN0QmxvY2soKSk7XG4gIH0sIGUpO1xuICBjb25zdCByID0gSCgoKSA9PiB7XG4gICAgZS5mb2N1cygpLCBlLnVubmVzdEJsb2NrKCk7XG4gIH0sIFtlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgUCxcbiAgICB7XG4gICAgICBvbkNsaWNrOiByLFxuICAgICAgaXNEaXNhYmxlZDogIXQsXG4gICAgICBtYWluVG9vbHRpcDogXCJVbm5lc3QgQmxvY2tcIixcbiAgICAgIHNlY29uZGFyeVRvb2x0aXA6IGplKFwiU2hpZnQrVGFiXCIpLFxuICAgICAgaWNvbjogRXJcbiAgICB9XG4gICk7XG59LCBjbiA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBWKCksIFtuLCByXSA9IHAoXG4gICAgdC51cGxvYWRGaWxlICE9PSB2b2lkIDAgPyBcInVwbG9hZFwiIDogXCJlbWJlZFwiXG4gICksIFtpLCBsXSA9IHAoITEpLCBbYywgc10gPSBwKCExKTtcbiAgTCgoKSA9PiB7XG4gICAgYyAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHMoITEpO1xuICAgIH0sIDNlMyk7XG4gIH0sIFtjXSk7XG4gIGNvbnN0IGQgPSBIKFxuICAgIChEKSA9PiB7XG4gICAgICBpZiAoRCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgYXN5bmMgZnVuY3Rpb24gbmUoRikge1xuICAgICAgICBpZiAobCghMCksIHQudXBsb2FkRmlsZSAhPT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBPID0gYXdhaXQgdC51cGxvYWRGaWxlKEYpO1xuICAgICAgICAgICAgdC51cGRhdGVCbG9jayhlLmJsb2NrLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICB1cmw6IE9cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBzKCEwKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgbCghMSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmUoRCk7XG4gICAgfSxcbiAgICBbdCwgZS5ibG9ja11cbiAgKSwgW2YsIGhdID0gcChcIlwiKSwgYiA9IEgoXG4gICAgKEQpID0+IHtcbiAgICAgIGgoRC5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgICB9LFxuICAgIFtdXG4gICksIFQgPSBIKFxuICAgIChEKSA9PiB7XG4gICAgICBELmtleSA9PT0gXCJFbnRlclwiICYmIChELnByZXZlbnREZWZhdWx0KCksIHQudXBkYXRlQmxvY2soZS5ibG9jaywge1xuICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdXJsOiBmXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIFt0LCBlLmJsb2NrLCBmXVxuICApLCBDID0gSCgoKSA9PiB7XG4gICAgdC51cGRhdGVCbG9jayhlLmJsb2NrLCB7XG4gICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICB1cmw6IGZcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW3QsIGUuYmxvY2ssIGZdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChDZSwgeyBjbGFzc05hbWU6IFwiYm4taW1hZ2UtdG9vbGJhclwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4cyhRLCB7IHZhbHVlOiBuLCBvbkNoYW5nZTogciwgY2hpbGRyZW46IFtcbiAgICBpICYmIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChjciwgeyB2aXNpYmxlOiBpIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeHMoUS5MaXN0LCB7IGNoaWxkcmVuOiBbXG4gICAgICB0LnVwbG9hZEZpbGUgIT09IHZvaWQgMCAmJiAvKiBAX19QVVJFX18gKi8gby5qc3goUS5UYWIsIHsgdmFsdWU6IFwidXBsb2FkXCIsIFwiZGF0YS10ZXN0XCI6IFwidXBsb2FkLXRhYlwiLCBjaGlsZHJlbjogXCJVcGxvYWRcIiB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChRLlRhYiwgeyB2YWx1ZTogXCJlbWJlZFwiLCBcImRhdGEtdGVzdFwiOiBcImVtYmVkLXRhYlwiLCBjaGlsZHJlbjogXCJFbWJlZFwiIH0pXG4gICAgXSB9KSxcbiAgICB0LnVwbG9hZEZpbGUgIT09IHZvaWQgMCAmJiAvKiBAX19QVVJFX18gKi8gby5qc3goUS5QYW5lbCwgeyBjbGFzc05hbWU6IFwiYm4tdXBsb2FkLWltYWdlLXBhbmVsXCIsIHZhbHVlOiBcInVwbG9hZFwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4cyhcImRpdlwiLCB7IGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgICR0LFxuICAgICAgICB7XG4gICAgICAgICAgcGxhY2Vob2xkZXI6IFwiVXBsb2FkIEltYWdlXCIsXG4gICAgICAgICAgc2l6ZTogXCJ4c1wiLFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgIG9uQ2hhbmdlOiBkLFxuICAgICAgICAgIFwiZGF0YS10ZXN0XCI6IFwidXBsb2FkLWlucHV0XCJcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIGMgJiYgLyogQF9fUFVSRV9fICovIG8uanN4KHNlLCB7IGM6IFwicmVkXCIsIHNpemU6IFwiMTJweFwiLCBjaGlsZHJlbjogXCJFcnJvcjogVXBsb2FkIGZhaWxlZFwiIH0pXG4gICAgXSB9KSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gby5qc3goUS5QYW5lbCwgeyBjbGFzc05hbWU6IFwiYm4tZW1iZWQtaW1hZ2UtcGFuZWxcIiwgdmFsdWU6IFwiZW1iZWRcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeHMoXCJkaXZcIiwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgICBVdCxcbiAgICAgICAge1xuICAgICAgICAgIHNpemU6IFwieHNcIixcbiAgICAgICAgICBwbGFjZWhvbGRlcjogXCJFbnRlciBVUkxcIixcbiAgICAgICAgICB2YWx1ZTogZixcbiAgICAgICAgICBvbkNoYW5nZTogYixcbiAgICAgICAgICBvbktleURvd246IFQsXG4gICAgICAgICAgXCJkYXRhLXRlc3RcIjogXCJlbWJlZC1pbnB1dFwiXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgIEdlLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImJuLWVtYmVkLWltYWdlLWJ1dHRvblwiLFxuICAgICAgICAgIG9uQ2xpY2s6IEMsXG4gICAgICAgICAgc2l6ZTogXCJ4c1wiLFxuICAgICAgICAgIFwiZGF0YS10ZXN0XCI6IFwiZW1iZWQtaW5wdXQtYnV0dG9uXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFwiRW1iZWQgSW1hZ2VcIlxuICAgICAgICB9XG4gICAgICApXG4gICAgXSB9KSB9KVxuICBdIH0pIH0pO1xufSwgWXIgPSAoKSA9PiB7XG4gIGNvbnN0IGUgPSBWKCksIHQgPSBLKGUpLCBbbiwgcl0gPSBwKCExKTtcbiAgTCgoKSA9PiB7XG4gICAgcighMSk7XG4gIH0sIFt0XSk7XG4gIGNvbnN0IGkgPSB0Lmxlbmd0aCA9PT0gMSA/IHRbMF0gOiB2b2lkIDA7XG4gIHJldHVybiBpID09PSB2b2lkIDAgfHwgaS50eXBlICE9PSBcImltYWdlXCIgfHwgIV90KFwiaW1hZ2VcIiwgaSwgZSkgPyBudWxsIDogLyogQF9fUFVSRV9fICovIG8uanN4cyhYLCB7IHdpdGhpblBvcnRhbDogITEsIG9wZW5lZDogbiwgcG9zaXRpb246IFwiYm90dG9tXCIsIGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIG8uanN4KFguVGFyZ2V0LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICBQLFxuICAgICAge1xuICAgICAgICBvbkNsaWNrOiAoKSA9PiByKCFuKSxcbiAgICAgICAgaXNTZWxlY3RlZDogbixcbiAgICAgICAgbWFpblRvb2x0aXA6IFwiUmVwbGFjZSBJbWFnZVwiLFxuICAgICAgICBpY29uOiBJclxuICAgICAgfVxuICAgICkgfSksXG4gICAgLyogQF9fUFVSRV9fICovIG8uanN4KFguRHJvcGRvd24sIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChjbiwgeyBibG9jazogaSB9KSB9KVxuICBdIH0pO1xufSwgS3IgPSB7XG4gIGxlZnQ6IHdyLFxuICBjZW50ZXI6IFNyLFxuICByaWdodDogVHIsXG4gIGp1c3RpZnk6IGpyXG59LCBBZSA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBWKCksIG4gPSBLKHQpLCByID0gQigoKSA9PiB7XG4gICAgY29uc3QgYyA9IG5bMF07XG4gICAgaWYgKFplKFwidGV4dEFsaWdubWVudFwiLCBjLCB0KSlcbiAgICAgIHJldHVybiBjLnByb3BzLnRleHRBbGlnbm1lbnQ7XG4gIH0sIFt0LCBuXSksIGkgPSBIKFxuICAgIChjKSA9PiB7XG4gICAgICB0LmZvY3VzKCk7XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgbilcbiAgICAgICAgbGUoXCJ0ZXh0QWxpZ25tZW50XCIsIHMudHlwZSwgdCkgJiYgdC51cGRhdGVCbG9jayhzLCB7XG4gICAgICAgICAgcHJvcHM6IHsgdGV4dEFsaWdubWVudDogYyB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgW3QsIG5dXG4gICk7XG4gIHJldHVybiBCKCgpID0+ICEhbi5maW5kKChjKSA9PiBcInRleHRBbGlnbm1lbnRcIiBpbiBjLnByb3BzKSwgW25dKSA/IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICBQLFxuICAgIHtcbiAgICAgIG9uQ2xpY2s6ICgpID0+IGkoZS50ZXh0QWxpZ25tZW50KSxcbiAgICAgIGlzU2VsZWN0ZWQ6IHIgPT09IGUudGV4dEFsaWdubWVudCxcbiAgICAgIG1haW5Ub29sdGlwOiBlLnRleHRBbGlnbm1lbnQgPT09IFwianVzdGlmeVwiID8gXCJKdXN0aWZ5IFRleHRcIiA6IFwiQWxpZ24gVGV4dCBcIiArIGUudGV4dEFsaWdubWVudC5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgZS50ZXh0QWxpZ25tZW50LnNsaWNlKDEpLFxuICAgICAgaWNvbjogS3JbZS50ZXh0QWxpZ25tZW50XVxuICAgIH1cbiAgKSA6IG51bGw7XG59O1xuZnVuY3Rpb24gR3IoZSkge1xuICBjb25zdCB0ID0gZS5pY29uO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgIHcuSXRlbSxcbiAgICB7XG4gICAgICBvbkNsaWNrOiBlLm9uQ2xpY2ssXG4gICAgICBsZWZ0U2VjdGlvbjogdCAmJiAvKiBAX19QVVJFX18gKi8gby5qc3godCwgeyBzaXplOiAxNiB9KSxcbiAgICAgIHJpZ2h0U2VjdGlvbjogZS5pc1NlbGVjdGVkID8gLyogQF9fUFVSRV9fICovIG8uanN4KCRlLCB7IHNpemU6IDIwLCBjbGFzc05hbWU6IFwiYm4tdGljay1pY29uXCIgfSkgOiAoXG4gICAgICAgIC8vIEVuc3VyZXMgc3BhY2UgZm9yIHRpY2sgZXZlbiBpZiBpdGVtIGlzbid0IGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImJuLXRpY2stc3BhY2VcIiB9KVxuICAgICAgKSxcbiAgICAgIGRpc2FibGVkOiBlLmlzRGlzYWJsZWQsXG4gICAgICBjaGlsZHJlbjogZS50ZXh0XG4gICAgfSxcbiAgICBlLnRleHRcbiAgKTtcbn1cbmZ1bmN0aW9uIEpyKGUpIHtcbiAgcmV0dXJuIFMoeyB0YWc6IFwic3ZnXCIsIGF0dHI6IHsgdmlld0JveDogXCIwIDAgMjAgMjBcIiwgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9LCBjaGlsZDogW3sgdGFnOiBcInBhdGhcIiwgYXR0cjogeyBmaWxsUnVsZTogXCJldmVub2RkXCIsIGQ6IFwiTTUuMjkzIDcuMjkzYTEgMSAwIDAxMS40MTQgMEwxMCAxMC41ODZsMy4yOTMtMy4yOTNhMSAxIDAgMTExLjQxNCAxLjQxNGwtNCA0YTEgMSAwIDAxLTEuNDE0IDBsLTQtNGExIDEgMCAwMTAtMS40MTR6XCIsIGNsaXBSdWxlOiBcImV2ZW5vZGRcIiB9IH1dIH0pKGUpO1xufVxuZnVuY3Rpb24gUXIoZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyMCAyMFwiLCBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGxSdWxlOiBcImV2ZW5vZGRcIiwgZDogXCJNNy4yOTMgMTQuNzA3YTEgMSAwIDAxMC0xLjQxNEwxMC41ODYgMTAgNy4yOTMgNi43MDdhMSAxIDAgMDExLjQxNC0xLjQxNGw0IDRhMSAxIDAgMDEwIDEuNDE0bC00IDRhMSAxIDAgMDEtMS40MTQgMHpcIiwgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiIH0gfV0gfSkoZSk7XG59XG5jb25zdCBYciA9IHVlKChlLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBlLmljb247XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgR2UsXG4gICAge1xuICAgICAgb25Nb3VzZURvd246IChyKSA9PiB7XG4gICAgICAgIE5lKCkgJiYgci5jdXJyZW50VGFyZ2V0LmZvY3VzKCk7XG4gICAgICB9LFxuICAgICAgbGVmdFNlY3Rpb246IG4gJiYgLyogQF9fUFVSRV9fICovIG8uanN4KG4sIHsgc2l6ZTogMTYgfSksXG4gICAgICByaWdodFNlY3Rpb246IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChKciwge30pLFxuICAgICAgc2l6ZTogXCJ4c1wiLFxuICAgICAgdmFyaWFudDogXCJzdWJ0bGVcIixcbiAgICAgIGRpc2FibGVkOiBlLmlzRGlzYWJsZWQsXG4gICAgICBvbkNsaWNrOiBlLm9uQ2xpY2ssXG4gICAgICByZWY6IHQsXG4gICAgICBjaGlsZHJlbjogZS50ZXh0XG4gICAgfVxuICApO1xufSk7XG5mdW5jdGlvbiBlbyhlKSB7XG4gIGNvbnN0IHQgPSBlLml0ZW1zLmZpbHRlcigoaSkgPT4gaS5pc1NlbGVjdGVkKVswXSwgeyByZWY6IG4sIHVwZGF0ZU1heEhlaWdodDogciB9ID0gWGUoKTtcbiAgcmV0dXJuIHQgPyAvKiBAX19QVVJFX18gKi8gby5qc3hzKFxuICAgIHcsXG4gICAge1xuICAgICAgd2l0aGluUG9ydGFsOiAhMSxcbiAgICAgIHRyYW5zaXRpb25Qcm9wczoge1xuICAgICAgICBleGl0RHVyYXRpb246IDBcbiAgICAgIH0sXG4gICAgICBkaXNhYmxlZDogZS5pc0Rpc2FibGVkLFxuICAgICAgb25PcGVuOiByLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KHcuVGFyZ2V0LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgICAgWHIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGV4dDogdC50ZXh0LFxuICAgICAgICAgICAgaWNvbjogdC5pY29uLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogdC5pc0Rpc2FibGVkXG4gICAgICAgICAgfVxuICAgICAgICApIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gby5qc3goXCJkaXZcIiwgeyByZWY6IG4sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3gody5Ecm9wZG93biwgeyBjaGlsZHJlbjogZS5pdGVtcy5tYXAoKGkpID0+IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChHciwgeyAuLi5pIH0sIGkudGV4dCkpIH0pIH0pXG4gICAgICBdXG4gICAgfVxuICApIDogbnVsbDtcbn1cbmNvbnN0IHRvID0gW1xuICB7XG4gICAgbmFtZTogXCJQYXJhZ3JhcGhcIixcbiAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgIGljb246IGNlLFxuICAgIGlzU2VsZWN0ZWQ6IChlKSA9PiBlLnR5cGUgPT09IFwicGFyYWdyYXBoXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiSGVhZGluZyAxXCIsXG4gICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgcHJvcHM6IHsgbGV2ZWw6IDEgfSxcbiAgICBpY29uOiBRdCxcbiAgICBpc1NlbGVjdGVkOiAoZSkgPT4gZS50eXBlID09PSBcImhlYWRpbmdcIiAmJiBcImxldmVsXCIgaW4gZS5wcm9wcyAmJiBlLnByb3BzLmxldmVsID09PSAxXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkhlYWRpbmcgMlwiLFxuICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgIHByb3BzOiB7IGxldmVsOiAyIH0sXG4gICAgaWNvbjogWHQsXG4gICAgaXNTZWxlY3RlZDogKGUpID0+IGUudHlwZSA9PT0gXCJoZWFkaW5nXCIgJiYgXCJsZXZlbFwiIGluIGUucHJvcHMgJiYgZS5wcm9wcy5sZXZlbCA9PT0gMlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJIZWFkaW5nIDNcIixcbiAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICBwcm9wczogeyBsZXZlbDogMyB9LFxuICAgIGljb246IGVuLFxuICAgIGlzU2VsZWN0ZWQ6IChlKSA9PiBlLnR5cGUgPT09IFwiaGVhZGluZ1wiICYmIFwibGV2ZWxcIiBpbiBlLnByb3BzICYmIGUucHJvcHMubGV2ZWwgPT09IDNcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQnVsbGV0IExpc3RcIixcbiAgICB0eXBlOiBcImJ1bGxldExpc3RJdGVtXCIsXG4gICAgaWNvbjogcm4sXG4gICAgaXNTZWxlY3RlZDogKGUpID0+IGUudHlwZSA9PT0gXCJidWxsZXRMaXN0SXRlbVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIk51bWJlcmVkIExpc3RcIixcbiAgICB0eXBlOiBcIm51bWJlcmVkTGlzdEl0ZW1cIixcbiAgICBpY29uOiBubixcbiAgICBpc1NlbGVjdGVkOiAoZSkgPT4gZS50eXBlID09PSBcIm51bWJlcmVkTGlzdEl0ZW1cIlxuICB9XG5dLCBubyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBWKCksIG4gPSBLKHQpLCBbciwgaV0gPSBwKHQuZ2V0VGV4dEN1cnNvclBvc2l0aW9uKCkuYmxvY2spLCBsID0gQigoKSA9PiAoZS5pdGVtcyB8fCB0bykuZmlsdGVyKChkKSA9PiB7XG4gICAgaWYgKCEoZC50eXBlIGluIHQuc2NoZW1hLmJsb2NrU2NoZW1hKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGNvbnN0IFtmLCBoXSBvZiBPYmplY3QuZW50cmllcyhkLnByb3BzIHx8IHt9KSkge1xuICAgICAgY29uc3QgYiA9IHQuc2NoZW1hLmJsb2NrU2NoZW1hW2QudHlwZV0ucHJvcFNjaGVtYTtcbiAgICAgIGlmICghKGYgaW4gYikgfHwgYltmXS52YWx1ZXMgIT09IHZvaWQgMCAmJiAhYltmXS52YWx1ZXMuaW5jbHVkZXMoaCkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9KSwgW3QsIGUuaXRlbXNdKSwgYyA9IEIoXG4gICAgKCkgPT4gbC5maW5kKChkKSA9PiBkLnR5cGUgPT09IHIudHlwZSkgIT09IHZvaWQgMCxcbiAgICBbci50eXBlLCBsXVxuICApLCBzID0gQigoKSA9PiB7XG4gICAgY29uc3QgZCA9IChmKSA9PiB7XG4gICAgICB0LmZvY3VzKCk7XG4gICAgICBmb3IgKGNvbnN0IGggb2YgbilcbiAgICAgICAgdC51cGRhdGVCbG9jayhoLCB7XG4gICAgICAgICAgdHlwZTogZi50eXBlLFxuICAgICAgICAgIHByb3BzOiBmLnByb3BzXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGwubWFwKChmKSA9PiAoe1xuICAgICAgdGV4dDogZi5uYW1lLFxuICAgICAgaWNvbjogZi5pY29uLFxuICAgICAgb25DbGljazogKCkgPT4gZChmKSxcbiAgICAgIGlzU2VsZWN0ZWQ6IGYuaXNTZWxlY3RlZChyKVxuICAgIH0pKTtcbiAgfSwgW3IsIGwsIHQsIG5dKTtcbiAgcmV0dXJuIFUoKCkgPT4ge1xuICAgIGkodC5nZXRUZXh0Q3Vyc29yUG9zaXRpb24oKS5ibG9jayk7XG4gIH0sIHQpLCBjID8gLyogQF9fUFVSRV9fICovIG8uanN4KGVvLCB7IGl0ZW1zOiBzIH0pIDogbnVsbDtcbn0sIHJvID0gKGUpID0+IFtcbiAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgIG5vLFxuICAgIHtcbiAgICAgIGl0ZW1zOiBlXG4gICAgfSxcbiAgICBcImJsb2NrVHlwZURyb3Bkb3duXCJcbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIG8uanN4KCRyLCB7fSwgXCJpbWFnZUNhcHRpb25CdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChZciwge30sIFwicmVwbGFjZUltYWdlQnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gby5qc3goa2UsIHsgYmFzaWNUZXh0U3R5bGU6IFwiYm9sZFwiIH0sIFwiYm9sZFN0eWxlQnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gby5qc3goa2UsIHsgYmFzaWNUZXh0U3R5bGU6IFwiaXRhbGljXCIgfSwgXCJpdGFsaWNTdHlsZUJ1dHRvblwiKSxcbiAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgIGtlLFxuICAgIHtcbiAgICAgIGJhc2ljVGV4dFN0eWxlOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcInVuZGVybGluZVN0eWxlQnV0dG9uXCJcbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIG8uanN4KGtlLCB7IGJhc2ljVGV4dFN0eWxlOiBcInN0cmlrZVwiIH0sIFwic3RyaWtlU3R5bGVCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChBZSwgeyB0ZXh0QWxpZ25tZW50OiBcImxlZnRcIiB9LCBcInRleHRBbGlnbkxlZnRCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChBZSwgeyB0ZXh0QWxpZ25tZW50OiBcImNlbnRlclwiIH0sIFwidGV4dEFsaWduQ2VudGVyQnV0dG9uXCIpLFxuICAvKiBAX19QVVJFX18gKi8gby5qc3goQWUsIHsgdGV4dEFsaWdubWVudDogXCJyaWdodFwiIH0sIFwidGV4dEFsaWduUmlnaHRCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChaciwge30sIFwiY29sb3JTdHlsZUJ1dHRvblwiKSxcbiAgLyogQF9fUFVSRV9fICovIG8uanN4KFdyLCB7fSwgXCJuZXN0QmxvY2tCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChxciwge30sIFwidW5uZXN0QmxvY2tCdXR0b25cIiksXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChVciwge30sIFwiY3JlYXRlTGlua0J1dHRvblwiKVxuXSwgb28gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KENlLCB7IGNoaWxkcmVuOiBlLmNoaWxkcmVuIHx8IHJvKGUuYmxvY2tUeXBlRHJvcGRvd25JdGVtcykgfSksIEV0ID0gKGUpID0+IHtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIHJldHVybiBcInRvcC1zdGFydFwiO1xuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHJldHVybiBcInRvcFwiO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgcmV0dXJuIFwidG9wLWVuZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJ0b3Atc3RhcnRcIjtcbiAgfVxufSwgYW8gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gVigpLCBbbiwgcl0gPSBwKFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IGYgPSB0LmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrO1xuICAgICAgcmV0dXJuIFwidGV4dEFsaWdubWVudFwiIGluIGYucHJvcHMgPyBFdChcbiAgICAgICAgZi5wcm9wcy50ZXh0QWxpZ25tZW50XG4gICAgICApIDogXCJ0b3Atc3RhcnRcIjtcbiAgICB9XG4gICk7XG4gIFUoKCkgPT4ge1xuICAgIGNvbnN0IGYgPSB0LmdldFRleHRDdXJzb3JQb3NpdGlvbigpLmJsb2NrO1xuICAgIFwidGV4dEFsaWdubWVudFwiIGluIGYucHJvcHMgPyByKFxuICAgICAgRXQoXG4gICAgICAgIGYucHJvcHMudGV4dEFsaWdubWVudFxuICAgICAgKVxuICAgICkgOiByKFwidG9wLXN0YXJ0XCIpO1xuICB9LCB0KTtcbiAgY29uc3QgaSA9IHRlKFxuICAgIHQuZm9ybWF0dGluZ1Rvb2xiYXIub25VcGRhdGUuYmluZCh0LmZvcm1hdHRpbmdUb29sYmFyKVxuICApLCB7IGlzTW91bnRlZDogbCwgcmVmOiBjLCBzdHlsZTogcyB9ID0gZ2UoXG4gICAgKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuc2hvdykgfHwgITEsXG4gICAgKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucmVmZXJlbmNlUG9zKSB8fCBudWxsLFxuICAgIDNlMyxcbiAgICB7XG4gICAgICBwbGFjZW1lbnQ6IG4sXG4gICAgICBtaWRkbGV3YXJlOiBbZmUoMTApLCB3ZSgpXVxuICAgIH1cbiAgKTtcbiAgaWYgKCFsIHx8ICFpKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBkID0gZS5mb3JtYXR0aW5nVG9vbGJhciB8fCBvbztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcImRpdlwiLCB7IHJlZjogYywgc3R5bGU6IHMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goZCwge30pIH0pO1xufSwgaW8gPSAoZSkgPT4ge1xuICBjb25zdCBbdCwgbl0gPSBwKCExKSwgciA9IFkobnVsbCk7XG4gIGlmIChlLmNoaWxkcmVuKVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goQ2UsIHsgY2hpbGRyZW46IGUuY2hpbGRyZW4gfSk7XG4gIGNvbnN0IHtcbiAgICB0ZXh0OiBpLFxuICAgIHVybDogbCxcbiAgICBkZWxldGVIeXBlcmxpbms6IGMsXG4gICAgZWRpdEh5cGVybGluazogcyxcbiAgICBzdGFydEhpZGVUaW1lcjogZCxcbiAgICBzdG9wSGlkZVRpbWVyOiBmXG4gIH0gPSBlO1xuICByZXR1cm4gdCA/IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICBsbixcbiAgICB7XG4gICAgICB1cmw6IGwsXG4gICAgICB0ZXh0OiBpLFxuICAgICAgdXBkYXRlOiBzLFxuICAgICAgb25CbHVyOiAoaCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZhciBiO1xuICAgICAgICAoYiA9IHIuY3VycmVudCkgIT0gbnVsbCAmJiBiLmNvbnRhaW5zKGgucmVsYXRlZFRhcmdldCkgfHwgbighMSk7XG4gICAgICB9LCA1MDApLFxuICAgICAgcmVmOiByXG4gICAgfVxuICApIDogLyogQF9fUFVSRV9fICovIG8uanN4cyhDZSwgeyBvbk1vdXNlRW50ZXI6IGYsIG9uTW91c2VMZWF2ZTogZCwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICBQLFxuICAgICAge1xuICAgICAgICBtYWluVG9vbHRpcDogXCJFZGl0XCIsXG4gICAgICAgIGlzU2VsZWN0ZWQ6ICExLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiBuKCEwKSxcbiAgICAgICAgY2hpbGRyZW46IFwiRWRpdCBMaW5rXCJcbiAgICAgIH1cbiAgICApLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICAgIFAsXG4gICAgICB7XG4gICAgICAgIG1haW5Ub29sdGlwOiBcIk9wZW4gaW4gbmV3IHRhYlwiLFxuICAgICAgICBpc1NlbGVjdGVkOiAhMSxcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5vcGVuKGwsIFwiX2JsYW5rXCIpO1xuICAgICAgICB9LFxuICAgICAgICBpY29uOiBPclxuICAgICAgfVxuICAgICksXG4gICAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgUCxcbiAgICAgIHtcbiAgICAgICAgbWFpblRvb2x0aXA6IFwiUmVtb3ZlIGxpbmtcIixcbiAgICAgICAgaXNTZWxlY3RlZDogITEsXG4gICAgICAgIG9uQ2xpY2s6IGMsXG4gICAgICAgIGljb246IFZyXG4gICAgICB9XG4gICAgKVxuICBdIH0pO1xufSwgbG8gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gVigpLCBuID0ge1xuICAgIGRlbGV0ZUh5cGVybGluazogdC5oeXBlcmxpbmtUb29sYmFyLmRlbGV0ZUh5cGVybGluayxcbiAgICBlZGl0SHlwZXJsaW5rOiB0Lmh5cGVybGlua1Rvb2xiYXIuZWRpdEh5cGVybGluayxcbiAgICBzdGFydEhpZGVUaW1lcjogdC5oeXBlcmxpbmtUb29sYmFyLnN0YXJ0SGlkZVRpbWVyLFxuICAgIHN0b3BIaWRlVGltZXI6IHQuaHlwZXJsaW5rVG9vbGJhci5zdG9wSGlkZVRpbWVyXG4gIH0sIHIgPSB0ZShcbiAgICB0Lmh5cGVybGlua1Rvb2xiYXIub25VcGRhdGUuYmluZCh0Lmh5cGVybGlua1Rvb2xiYXIpXG4gICksIHsgaXNNb3VudGVkOiBpLCByZWY6IGwsIHN0eWxlOiBjIH0gPSBnZShcbiAgICAociA9PSBudWxsID8gdm9pZCAwIDogci5zaG93KSB8fCAhMSxcbiAgICAociA9PSBudWxsID8gdm9pZCAwIDogci5yZWZlcmVuY2VQb3MpIHx8IG51bGwsXG4gICAgNGUzLFxuICAgIHtcbiAgICAgIHBsYWNlbWVudDogXCJ0b3Atc3RhcnRcIixcbiAgICAgIG1pZGRsZXdhcmU6IFtmZSgxMCksIHdlKCldXG4gICAgfVxuICApO1xuICBpZiAoIWkgfHwgIXIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHsgc2hvdzogcywgcmVmZXJlbmNlUG9zOiBkLCAuLi5mIH0gPSByLCBoID0gZS5oeXBlcmxpbmtUb29sYmFyIHx8IGlvO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uanN4KFwiZGl2XCIsIHsgcmVmOiBsLCBzdHlsZTogYywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChoLCB7IC4uLmYsIC4uLm4gfSkgfSk7XG59LCBzbyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBWKCk7XG4gIGlmICghdC5pbWFnZVRvb2xiYXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbWFnZVRvb2xiYXJDb250cm9sbGVyIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBCbG9ja05vdGUgZWRpdG9yIHNjaGVtYSBjb250YWlucyBpbWFnZSBibG9ja1wiXG4gICAgKTtcbiAgY29uc3QgbiA9IHRlKFxuICAgIHQuaW1hZ2VUb29sYmFyLm9uVXBkYXRlLmJpbmQodC5pbWFnZVRvb2xiYXIpXG4gICksIHsgaXNNb3VudGVkOiByLCByZWY6IGksIHN0eWxlOiBsIH0gPSBnZShcbiAgICAobiA9PSBudWxsID8gdm9pZCAwIDogbi5zaG93KSB8fCAhMSxcbiAgICAobiA9PSBudWxsID8gdm9pZCAwIDogbi5yZWZlcmVuY2VQb3MpIHx8IG51bGwsXG4gICAgNWUzLFxuICAgIHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgICAgIG1pZGRsZXdhcmU6IFtmZSgxMCksIHdlKCldXG4gICAgfVxuICApO1xuICBpZiAoIXIgfHwgIW4pXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHsgc2hvdzogYywgcmVmZXJlbmNlUG9zOiBzLCAuLi5kIH0gPSBuLCBmID0gZS5pbWFnZVRvb2xiYXIgfHwgY247XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goXCJkaXZcIiwgeyByZWY6IGksIHN0eWxlOiBsLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4KGYsIHsgLi4uZCB9KSB9KTtcbn07XG5mdW5jdGlvbiBjbyhlKSB7XG4gIHJldHVybiBTKHsgdGFnOiBcInN2Z1wiLCBhdHRyOiB7IHZpZXdCb3g6IFwiMCAwIDEwMjQgMTAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTQ4MiAxNTJoNjBxOCAwIDggOHY3MDRxMCA4LTggOGgtNjBxLTggMC04LThWMTYwcTAtOCA4LThaXCIgfSB9LCB7IHRhZzogXCJwYXRoXCIsIGF0dHI6IHsgZDogXCJNMTkyIDQ3NGg2NzJxOCAwIDggOHY2MHEwIDgtOCA4SDE2MHEtOCAwLTgtOHYtNjBxMC04IDgtOFpcIiB9IH1dIH0pKGUpO1xufVxuY29uc3QgdW4gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KFp0LCB7IHNpemU6IDI0LCBjaGlsZHJlbjogZS5jaGlsZHJlbiB9KSwgdW8gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KHVuLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gIGNvLFxuICB7XG4gICAgc2l6ZTogMjQsXG4gICAgb25DbGljazogZS5hZGRCbG9jayxcbiAgICBcImRhdGEtdGVzdFwiOiBcImRyYWdIYW5kbGVBZGRcIlxuICB9XG4pIH0pO1xuZnVuY3Rpb24gZG4oZSkge1xuICByZXR1cm4gUyh7IHRhZzogXCJzdmdcIiwgYXR0cjogeyB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiIH0sIGNoaWxkOiBbeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGZpbGw6IFwibm9uZVwiLCBkOiBcIk0wIDBoMjR2MjRIMFYwelwiIH0gfSwgeyB0YWc6IFwicGF0aFwiLCBhdHRyOiB7IGQ6IFwiTTExIDE4YzAgMS4xLS45IDItMiAycy0yLS45LTItMiAuOS0yIDItMiAyIC45IDIgMnptLTItOGMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTAtNmMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTYgNGMxLjEgMCAyLS45IDItMnMtLjktMi0yLTItMiAuOS0yIDIgLjkgMiAyIDJ6bTAgMmMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTAgNmMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6XCIgfSB9XSB9KShlKTtcbn1cbmNvbnN0IGZuID0gKGUpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbjogdCwgLi4ubiB9ID0gZTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh3Lkl0ZW0sIHsgLi4ubiwgY2hpbGRyZW46IHQgfSk7XG59LCBmbyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBWKCksIFtuLCByXSA9IHAoITEpLCB7IHJlZjogaSwgdXBkYXRlTWF4SGVpZ2h0OiBsIH0gPSBYZSgpLCBjID0gWSgpLCBzID0gSCgoKSA9PiB7XG4gICAgYy5jdXJyZW50ICYmIGNsZWFyVGltZW91dChjLmN1cnJlbnQpLCBjLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHIoITEpO1xuICAgIH0sIDI1MCk7XG4gIH0sIFtdKSwgZCA9IEgoKCkgPT4ge1xuICAgIGMuY3VycmVudCAmJiBjbGVhclRpbWVvdXQoYy5jdXJyZW50KSwgbiB8fCBsKCksIHIoITApO1xuICB9LCBbbiwgbF0pO1xuICByZXR1cm4gIWxlKFwidGV4dENvbG9yXCIsIGUuYmxvY2sudHlwZSwgdCkgJiYgIWxlKFwiYmFja2dyb3VuZENvbG9yXCIsIGUuYmxvY2sudHlwZSwgdCkgPyBudWxsIDogLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgIGZuLFxuICAgIHtcbiAgICAgIG9uTW91c2VMZWF2ZTogcyxcbiAgICAgIG9uTW91c2VPdmVyOiBkLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeHModywgeyB3aXRoaW5Qb3J0YWw6ICExLCBvcGVuZWQ6IG4sIHBvc2l0aW9uOiBcInJpZ2h0XCIsIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh3LlRhcmdldCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4cyhcImRpdlwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiIH0sIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KFwiZGl2XCIsIHsgc3R5bGU6IHsgZmxleDogMSB9LCBjaGlsZHJlbjogZS5jaGlsZHJlbiB9KSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8gby5qc3goenQsIHsgc3R5bGU6IHsgZGlzcGxheTogXCJmbGV4XCIsIGFsaWduSXRlbXM6IFwiY2VudGVyXCIgfSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChRciwgeyBzaXplOiAxNSB9KSB9KVxuICAgICAgICBdIH0pIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gby5qc3goXCJkaXZcIiwgeyByZWY6IGksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgICAgdy5Ecm9wZG93bixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmU6IHMsXG4gICAgICAgICAgICBvbk1vdXNlT3ZlcjogZCxcbiAgICAgICAgICAgIHN0eWxlOiB7IG1hcmdpbkxlZnQ6IFwiNXB4XCIgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgICAgICAgIG9uLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWNvblNpemU6IDE4LFxuICAgICAgICAgICAgICAgIHRleHQ6IGxlKFxuICAgICAgICAgICAgICAgICAgXCJ0ZXh0Q29sb3JcIixcbiAgICAgICAgICAgICAgICAgIGUuYmxvY2sudHlwZSxcbiAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICApICYmIFplKFwidGV4dENvbG9yXCIsIGUuYmxvY2ssIHQpID8ge1xuICAgICAgICAgICAgICAgICAgY29sb3I6IGUuYmxvY2sucHJvcHMudGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgc2V0Q29sb3I6IChmKSA9PiB0LnVwZGF0ZUJsb2NrKGUuYmxvY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZS5ibG9jay50eXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogeyB0ZXh0Q29sb3I6IGYgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGxlKFxuICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgICAgICAgICAgIGUuYmxvY2sudHlwZSxcbiAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICApICYmIFplKFwiYmFja2dyb3VuZENvbG9yXCIsIGUuYmxvY2ssIHQpID8ge1xuICAgICAgICAgICAgICAgICAgY29sb3I6IGUuYmxvY2sucHJvcHMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc2V0Q29sb3I6IChmKSA9PiB0LnVwZGF0ZUJsb2NrKGUuYmxvY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHsgYmFja2dyb3VuZENvbG9yOiBmIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICApIH0pXG4gICAgICBdIH0pXG4gICAgfVxuICApO1xufSwgZ28gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gVigpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uanN4KGZuLCB7IG9uQ2xpY2s6ICgpID0+IHQucmVtb3ZlQmxvY2tzKFtlLmJsb2NrXSksIGNoaWxkcmVuOiBlLmNoaWxkcmVuIH0pO1xufSwgaG8gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KHcuRHJvcGRvd24sIHsgY2xhc3NOYW1lOiBcImJuLWRyYWctaGFuZGxlLW1lbnVcIiwgY2hpbGRyZW46IGUuY2hpbGRyZW4gfHwgLyogQF9fUFVSRV9fICovIG8uanN4cyhvLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChnbywgeyAuLi5lLCBjaGlsZHJlbjogXCJEZWxldGVcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIG8uanN4KGZvLCB7IC4uLmUsIGNoaWxkcmVuOiBcIkNvbG9yc1wiIH0pXG5dIH0pIH0pLCBtbyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBlLmRyYWdIYW5kbGVNZW51IHx8IGhvO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uanN4cyhcbiAgICB3LFxuICAgIHtcbiAgICAgIHdpdGhpblBvcnRhbDogITEsXG4gICAgICB0cmlnZ2VyOiBcImNsaWNrXCIsXG4gICAgICBvbk9wZW46IGUuZnJlZXplTWVudSxcbiAgICAgIG9uQ2xvc2U6IGUudW5mcmVlemVNZW51LFxuICAgICAgd2lkdGg6IDEwMCxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh3LlRhcmdldCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcImJuLWRyYWctaGFuZGxlXCIsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IGUuYmxvY2tEcmFnU3RhcnQsXG4gICAgICAgICAgICBvbkRyYWdFbmQ6IGUuYmxvY2tEcmFnRW5kLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh1biwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4KGRuLCB7IHNpemU6IDI0LCBcImRhdGEtdGVzdFwiOiBcImRyYWdIYW5kbGVcIiB9KSB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KHQsIHsgYmxvY2s6IGUuYmxvY2sgfSlcbiAgICAgIF1cbiAgICB9XG4gICk7XG59LCBibyA9IChlKSA9PiB7XG4gIGNvbnN0IHsgYWRkQmxvY2s6IHQsIC4uLm4gfSA9IGU7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goWWUsIHsgY2xhc3NOYW1lOiBcImJuLXNpZGUtbWVudVwiLCBnYXA6IDAsIGNoaWxkcmVuOiBlLmNoaWxkcmVuIHx8IC8qIEBfX1BVUkVfXyAqLyBvLmpzeHMoby5GcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh1bywgeyBhZGRCbG9jazogdCB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gby5qc3gobW8sIHsgLi4ubiB9KVxuICBdIH0pIH0pO1xufSwgeG8gPSAoZSkgPT4ge1xuICBjb25zdCB0ID0gVigpLCBuID0ge1xuICAgIGFkZEJsb2NrOiB0LnNpZGVNZW51LmFkZEJsb2NrLFxuICAgIGJsb2NrRHJhZ1N0YXJ0OiB0LnNpZGVNZW51LmJsb2NrRHJhZ1N0YXJ0LFxuICAgIGJsb2NrRHJhZ0VuZDogdC5zaWRlTWVudS5ibG9ja0RyYWdFbmQsXG4gICAgZnJlZXplTWVudTogdC5zaWRlTWVudS5mcmVlemVNZW51LFxuICAgIHVuZnJlZXplTWVudTogdC5zaWRlTWVudS51bmZyZWV6ZU1lbnVcbiAgfSwgciA9IHRlKFxuICAgIHQuc2lkZU1lbnUub25VcGRhdGUuYmluZCh0LnNpZGVNZW51KVxuICApLCB7IGlzTW91bnRlZDogaSwgcmVmOiBsLCBzdHlsZTogYyB9ID0gZ2UoXG4gICAgKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc2hvdykgfHwgITEsXG4gICAgKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIucmVmZXJlbmNlUG9zKSB8fCBudWxsLFxuICAgIDFlMyxcbiAgICB7XG4gICAgICBwbGFjZW1lbnQ6IFwibGVmdFwiXG4gICAgfVxuICApO1xuICBpZiAoIWkgfHwgIXIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHsgc2hvdzogcywgcmVmZXJlbmNlUG9zOiBkLCAuLi5mIH0gPSByLCBoID0gZS5zaWRlTWVudSB8fCBibztcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcImRpdlwiLCB7IHJlZjogbCwgc3R5bGU6IGMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goaCwgeyAuLi5mLCAuLi5uIH0pIH0pO1xufSwgdm8gPSB7XG4gIFwiSGVhZGluZyAxXCI6IFF0LFxuICBcIkhlYWRpbmcgMlwiOiBYdCxcbiAgXCJIZWFkaW5nIDNcIjogZW4sXG4gIFwiTnVtYmVyZWQgTGlzdFwiOiBubixcbiAgXCJCdWxsZXQgTGlzdFwiOiBybixcbiAgUGFyYWdyYXBoOiBjZSxcbiAgVGFibGU6IExyLFxuICBJbWFnZTogX3Jcbn07XG5mdW5jdGlvbiBnbihlKSB7XG4gIHJldHVybiBxbihlKS5tYXAoKHQpID0+IHtcbiAgICBjb25zdCBuID0gdm9bdC50aXRsZV07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnQsXG4gICAgICBpY29uOiAvKiBAX19QVVJFX18gKi8gby5qc3gobiwgeyBzaXplOiAxOCB9KVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcG8oZSwgdCwgbiwgciA9IDMpIHtcbiAgY29uc3QgaSA9IFkoMCk7XG4gIEwoKCkgPT4ge1xuICAgIHQgIT09IHZvaWQgMCAmJiAoZS5sZW5ndGggPiAwID8gaS5jdXJyZW50ID0gdC5sZW5ndGggOiB0Lmxlbmd0aCAtIGkuY3VycmVudCA+IHIgJiYgbigpKTtcbiAgfSwgW24sIHIsIGUubGVuZ3RoLCB0XSk7XG59XG5mdW5jdGlvbiBrbyhlLCB0KSB7XG4gIGNvbnN0IFtuLCByXSA9IHAoW10pLCBbaSwgbF0gPSBwKCExKSwgYyA9IFkoKSwgcyA9IFkoKTtcbiAgcmV0dXJuIEwoKCkgPT4ge1xuICAgIGNvbnN0IGQgPSBlO1xuICAgIGMuY3VycmVudCA9IGUsIGwoITApLCB0KGUpLnRoZW4oKGYpID0+IHtcbiAgICAgIGMuY3VycmVudCA9PT0gZCAmJiAocihmKSwgbCghMSksIHMuY3VycmVudCA9IGQpO1xuICAgIH0pO1xuICB9LCBbZSwgdF0pLCB7XG4gICAgaXRlbXM6IG4gfHwgW10sXG4gICAgLy8gVGhlIHF1ZXJ5IHRoYXQgd2FzIHVzZWQgdG8gcmV0cmlldmUgdGhlIGxhc3Qgc2V0IG9mIGl0ZW1zIG1heSBub3QgYmUgdGhlXG4gICAgLy8gc2FtZSBhcyB0aGUgY3VycmVudCBxdWVyeSBhcyB0aGUgaXRlbXMgZnJvbSB0aGUgY3VycmVudCBxdWVyeSBtYXkgbm90XG4gICAgLy8gaGF2ZSBiZWVuIHJldHJpZXZlZCB5ZXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgdGhlIHJldHVybnMgb2YgdGhpc1xuICAgIC8vIGhvb2sgaW4gb3RoZXIgaG9va3MuXG4gICAgdXNlZFF1ZXJ5OiBzLmN1cnJlbnQsXG4gICAgbG9hZGluZ1N0YXRlOiBzLmN1cnJlbnQgPT09IHZvaWQgMCA/IFwibG9hZGluZy1pbml0aWFsXCIgOiBpID8gXCJsb2FkaW5nXCIgOiBcImxvYWRlZFwiXG4gIH07XG59XG5mdW5jdGlvbiB5byhlLCB0LCBuLCByKSB7XG4gIGNvbnN0IFtpLCBsXSA9IHAoMCk7XG4gIHJldHVybiBMKCgpID0+IHtcbiAgICBjb25zdCBjID0gKHMpID0+IHMua2V5ID09PSBcIkFycm93VXBcIiA/IChzLnByZXZlbnREZWZhdWx0KCksIHQubGVuZ3RoICYmIGwoKGkgLSAxICsgdC5sZW5ndGgpICUgdC5sZW5ndGgpLCAhMCkgOiBzLmtleSA9PT0gXCJBcnJvd0Rvd25cIiA/IChzLnByZXZlbnREZWZhdWx0KCksIHQubGVuZ3RoICYmIGwoKGkgKyAxKSAlIHQubGVuZ3RoKSwgITApIDogcy5rZXkgPT09IFwiRW50ZXJcIiA/IChzLnByZXZlbnREZWZhdWx0KCksIHQubGVuZ3RoICYmIChyID09IG51bGwgfHwgcih0W2ldKSksICEwKSA6IHMua2V5ID09PSBcIkVzY2FwZVwiID8gKHMucHJldmVudERlZmF1bHQoKSwgbigpLCAhMCkgOiAhMTtcbiAgICByZXR1cm4gZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGMsXG4gICAgICAhMFxuICAgICksICgpID0+IHtcbiAgICAgIGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICBcImtleWRvd25cIixcbiAgICAgICAgYyxcbiAgICAgICAgITBcbiAgICAgICk7XG4gICAgfTtcbiAgfSwgW24sIGUuZG9tRWxlbWVudCwgdCwgaSwgcl0pLCBpO1xufVxuZnVuY3Rpb24gQ28oZSkge1xuICBjb25zdCB0ID0gVigpLCB7XG4gICAgZ2V0SXRlbXM6IG4sXG4gICAgc3VnZ2VzdGlvbk1lbnVDb21wb25lbnQ6IHIsXG4gICAgcXVlcnk6IGksXG4gICAgY2xlYXJRdWVyeTogbCxcbiAgICBjbG9zZU1lbnU6IGMsXG4gICAgb25JdGVtQ2xpY2s6IHNcbiAgfSA9IGUsIGQgPSBIKFxuICAgIChEKSA9PiB7XG4gICAgICBjKCksIGwoKSwgcyA9PSBudWxsIHx8IHMoRCk7XG4gICAgfSxcbiAgICBbcywgYywgbF1cbiAgKSwgeyBpdGVtczogZiwgdXNlZFF1ZXJ5OiBoLCBsb2FkaW5nU3RhdGU6IGIgfSA9IGtvKFxuICAgIGksXG4gICAgblxuICApO1xuICBwbyhmLCBoLCBjKTtcbiAgY29uc3QgVCA9IHlvKFxuICAgIHQsXG4gICAgZixcbiAgICBjLFxuICAgIGRcbiAgKSwgQyA9IHI7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgQyxcbiAgICB7XG4gICAgICBpdGVtczogZixcbiAgICAgIG9uSXRlbUNsaWNrOiBkLFxuICAgICAgbG9hZGluZ1N0YXRlOiBiLFxuICAgICAgc2VsZWN0ZWRJbmRleDogVFxuICAgIH1cbiAgKTtcbn1cbmNvbnN0IFNvID0gNTtcbmZ1bmN0aW9uIGpvKGUpIHtcbiAgY29uc3QgdCA9IFkobnVsbCk7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgdmFyIGM7XG4gICAgY29uc3QgaSA9IGUuaXNTZWxlY3RlZCwgbCA9IChjID0gdC5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogYy5tYXRjaGVzKFwiOmhvdmVyXCIpO1xuICAgIHJldHVybiBpIHx8IGw7XG4gIH1cbiAgZnVuY3Rpb24gcigpIHtcbiAgICB2YXIgaSwgbDtcbiAgICBuKCkgPyAoaSA9IHQuY3VycmVudCkgPT0gbnVsbCB8fCBpLnNldEF0dHJpYnV0ZShcImRhdGEtaG92ZXJlZFwiLCBcInRydWVcIikgOiAobCA9IHQuY3VycmVudCkgPT0gbnVsbCB8fCBsLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtaG92ZXJlZFwiKTtcbiAgfVxuICByZXR1cm4gTCgoKSA9PiB7XG4gICAgcigpLCBuKCkgJiYgdC5jdXJyZW50ICYmIHQuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gU28gJiYgdC5jdXJyZW50LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH0pLCAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgdy5JdGVtLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXCJibi1zbGFzaC1tZW51LWl0ZW1cIixcbiAgICAgIG9uQ2xpY2s6IGUub25DbGljayxcbiAgICAgIGNsb3NlTWVudU9uQ2xpY2s6ICExLFxuICAgICAgb25Nb3VzZUxlYXZlOiAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHIoKTtcbiAgICAgICAgfSwgMSk7XG4gICAgICB9LFxuICAgICAgbGVmdFNlY3Rpb246IGUuaWNvbixcbiAgICAgIHJpZ2h0U2VjdGlvbjogZS5iYWRnZSAmJiAvKiBAX19QVVJFX18gKi8gby5qc3godXIsIHsgc2l6ZTogXCJ4c1wiLCBjaGlsZHJlbjogZS5iYWRnZSB9KSxcbiAgICAgIHJlZjogdCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3hzKEtlLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChzZSwgeyBsaDogXCIyMHB4XCIsIHNpemU6IFwiMTRweFwiLCBmdzogNTAwLCBjaGlsZHJlbjogZS50aXRsZSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KHNlLCB7IGxoOiBcIjE2cHhcIiwgc2l6ZTogXCIxMHB4XCIsIGNoaWxkcmVuOiBlLnN1YnRleHQgfSlcbiAgICAgIF0gfSlcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB3byhlKSB7XG4gIGNvbnN0IHsgaXRlbXM6IHQsIGxvYWRpbmdTdGF0ZTogbiwgc2VsZWN0ZWRJbmRleDogciwgb25JdGVtQ2xpY2s6IGkgfSA9IGUsIGwgPSBuID09PSBcImxvYWRpbmctaW5pdGlhbFwiIHx8IG4gPT09IFwibG9hZGluZ1wiID8gLyogQF9fUFVSRV9fICovIG8uanN4KGRyLCB7IGNsYXNzTmFtZTogXCJibi1zbGFzaC1tZW51LWxvYWRlclwiLCB0eXBlOiBcImRvdHNcIiB9KSA6IG51bGwsIGMgPSBCKCgpID0+IHtcbiAgICBsZXQgcztcbiAgICBjb25zdCBkID0gW107XG4gICAgZm9yIChsZXQgZiA9IDA7IGYgPCB0Lmxlbmd0aDsgZisrKSB7XG4gICAgICBjb25zdCBoID0gdFtmXTtcbiAgICAgIGguZ3JvdXAgIT09IHMgJiYgKHMgPSBoLmdyb3VwLCBkLnB1c2goXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh3LkxhYmVsLCB7IGNoaWxkcmVuOiBzIH0sIHMpXG4gICAgICApKSwgZC5wdXNoKFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gVW4oXG4gICAgICAgICAgam8sXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uaCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IGYgPT09IHIsXG4gICAgICAgICAgICBrZXk6IGgudGl0bGUsXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBpID09IG51bGwgPyB2b2lkIDAgOiBpKGgpXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZDtcbiAgfSwgW3QsIHIsIGldKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICB3LFxuICAgIHtcbiAgICAgIHdpdGhpblBvcnRhbDogITEsXG4gICAgICB0cmFwRm9jdXM6ICExLFxuICAgICAgZGVmYXVsdE9wZW5lZDogITAsXG4gICAgICB0cmlnZ2VyOiBcImhvdmVyXCIsXG4gICAgICBjbG9zZURlbGF5OiAxZTcsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4cyhcbiAgICAgICAgdy5Ecm9wZG93bixcbiAgICAgICAge1xuICAgICAgICAgIG9uTW91c2VEb3duOiAocykgPT4gcy5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJibi1zbGFzaC1tZW51XCIsXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICAkbi5jb3VudChjKSA9PT0gMCAmJiAoZS5sb2FkaW5nU3RhdGUgPT09IFwibG9hZGluZ1wiIHx8IGUubG9hZGluZ1N0YXRlID09PSBcImxvYWRlZFwiKSAmJiAvKiBAX19QVVJFX18gKi8gby5qc3gody5JdGVtLCB7IGNoaWxkcmVuOiBcIk5vIG1hdGNoIGZvdW5kXCIgfSksXG4gICAgICAgICAgICBsXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gVG8oZSkge1xuICBjb25zdCB0ID0gVigpLCB7IHRyaWdnZXJDaGFyYWN0ZXI6IG4sIHN1Z2dlc3Rpb25NZW51Q29tcG9uZW50OiByIH0gPSBlO1xuICBsZXQgeyBvbkl0ZW1DbGljazogaSwgZ2V0SXRlbXM6IGwgfSA9IGU7XG4gIGkgfHwgKGkgPSAoYikgPT4ge1xuICAgIGIub25JdGVtQ2xpY2sodCk7XG4gIH0pO1xuICBjb25zdCBjID0ge1xuICAgIGNsb3NlTWVudTogdC5zdWdnZXN0aW9uTWVudXMuY2xvc2VNZW51LFxuICAgIGNsZWFyUXVlcnk6IHQuc3VnZ2VzdGlvbk1lbnVzLmNsZWFyUXVlcnlcbiAgfSwgcyA9IHRlKFxuICAgIChiKSA9PiB0LnN1Z2dlc3Rpb25NZW51cy5vblVwZGF0ZS5iaW5kKHQuc3VnZ2VzdGlvbk1lbnVzKShcbiAgICAgIG4sXG4gICAgICBiXG4gICAgKVxuICApLCB7IGlzTW91bnRlZDogZCwgcmVmOiBmLCBzdHlsZTogaCB9ID0gZ2UoXG4gICAgKHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuc2hvdykgfHwgITEsXG4gICAgKHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMucmVmZXJlbmNlUG9zKSB8fCBudWxsLFxuICAgIDJlMyxcbiAgICB7XG4gICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCIsXG4gICAgICBtaWRkbGV3YXJlOiBbXG4gICAgICAgIGZlKDEwKSxcbiAgICAgICAgLy8gRmxpcHMgdGhlIG1lbnUgcGxhY2VtZW50IHRvIG1heGltaXplIHRoZSBzcGFjZSBhdmFpbGFibGUsIGFuZCBwcmV2ZW50c1xuICAgICAgICAvLyB0aGUgbWVudSBmcm9tIGJlaW5nIGN1dCBvZmYgYnkgdGhlIGNvbmZpbmVzIG9mIHRoZSBzY3JlZW4uXG4gICAgICAgIHdlKCksXG4gICAgICAgIGxyKHtcbiAgICAgICAgICBhcHBseSh7IGF2YWlsYWJsZUhlaWdodDogYiwgZWxlbWVudHM6IFQgfSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihULmZsb2F0aW5nLnN0eWxlLCB7XG4gICAgICAgICAgICAgIG1heEhlaWdodDogYCR7YiAtIDEwfXB4YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuICFkIHx8ICFzID8gbnVsbCA6IChsIHx8IChsID0gYXN5bmMgKGIpID0+IEl0KFxuICAgIGduKHQpLFxuICAgIGJcbiAgKSksIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcImRpdlwiLCB7IHJlZjogZiwgc3R5bGU6IGgsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgQ28sXG4gICAge1xuICAgICAgcXVlcnk6IHMucXVlcnksXG4gICAgICBjbG9zZU1lbnU6IGMuY2xvc2VNZW51LFxuICAgICAgY2xlYXJRdWVyeTogYy5jbGVhclF1ZXJ5LFxuICAgICAgZ2V0SXRlbXM6IGwsXG4gICAgICBzdWdnZXN0aW9uTWVudUNvbXBvbmVudDogciB8fCB3byxcbiAgICAgIG9uSXRlbUNsaWNrOiBpXG4gICAgfVxuICApIH0pKTtcbn1cbmZ1bmN0aW9uIEhvKGUsIHQsIG4pIHtcbiAgcmV0dXJuIG4gJiYgbi5kcmFnZ2VkQ2VsbE9yaWVudGF0aW9uID09PSBcInJvd1wiID8gbmV3IERPTVJlY3QoXG4gICAgdC54LFxuICAgIG4ubW91c2VQb3MsXG4gICAgdC53aWR0aCxcbiAgICAwXG4gICkgOiBuZXcgRE9NUmVjdChcbiAgICB0LngsXG4gICAgZS55LFxuICAgIHQud2lkdGgsXG4gICAgZS5oZWlnaHRcbiAgKTtcbn1cbmZ1bmN0aW9uIEVvKGUsIHQsIG4pIHtcbiAgcmV0dXJuIG4gJiYgbi5kcmFnZ2VkQ2VsbE9yaWVudGF0aW9uID09PSBcImNvbFwiID8gbmV3IERPTVJlY3QoXG4gICAgbi5tb3VzZVBvcyxcbiAgICB0LnksXG4gICAgMCxcbiAgICB0LmhlaWdodFxuICApIDogbmV3IERPTVJlY3QoXG4gICAgZS54LFxuICAgIHQueSxcbiAgICBlLndpZHRoLFxuICAgIHQuaGVpZ2h0XG4gICk7XG59XG5mdW5jdGlvbiBNdChlLCB0LCBuLCByLCBpKSB7XG4gIGNvbnN0IHsgcmVmczogbCwgdXBkYXRlOiBjLCBjb250ZXh0OiBzLCBmbG9hdGluZ1N0eWxlczogZCB9ID0gRnQoe1xuICAgIG9wZW46IHQsXG4gICAgcGxhY2VtZW50OiBlID09PSBcInJvd1wiID8gXCJsZWZ0XCIgOiBcInRvcFwiLFxuICAgIG1pZGRsZXdhcmU6IFtmZShlID09PSBcInJvd1wiID8gLTEwIDogLTEyKV1cbiAgfSksIHsgaXNNb3VudGVkOiBmLCBzdHlsZXM6IGggfSA9IE50KHMpO1xuICByZXR1cm4gTCgoKSA9PiB7XG4gICAgYygpO1xuICB9LCBbbiwgciwgY10pLCBMKCgpID0+IHtcbiAgICBuID09PSBudWxsIHx8IHIgPT09IG51bGwgfHwgbC5zZXRSZWZlcmVuY2Uoe1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiAoZSA9PT0gXCJyb3dcIiA/IEhvIDogRW8pKG4sIHIsIGkpXG4gICAgfSk7XG4gIH0sIFtpLCBlLCBuLCByLCBsXSksIEIoXG4gICAgKCkgPT4gKHtcbiAgICAgIGlzTW91bnRlZDogZixcbiAgICAgIHJlZjogbC5zZXRGbG9hdGluZyxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAuLi5oLFxuICAgICAgICAuLi5kLFxuICAgICAgICB6SW5kZXg6IDFlNFxuICAgICAgfVxuICAgIH0pLFxuICAgIFtkLCBmLCBsLnNldEZsb2F0aW5nLCBoXVxuICApO1xufVxuZnVuY3Rpb24gTW8oZSwgdCwgbiwgcikge1xuICBjb25zdCBpID0gTXQoXG4gICAgXCJyb3dcIixcbiAgICBlLFxuICAgIHQsXG4gICAgbixcbiAgICByXG4gICksIGwgPSBNdChcbiAgICBcImNvbFwiLFxuICAgIGUsXG4gICAgdCxcbiAgICBuLFxuICAgIHJcbiAgKTtcbiAgcmV0dXJuIEIoXG4gICAgKCkgPT4gKHtcbiAgICAgIHJvd0hhbmRsZTogaSxcbiAgICAgIGNvbEhhbmRsZTogbFxuICAgIH0pLFxuICAgIFtsLCBpXVxuICApO1xufVxuY29uc3QgUm8gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KHcuRHJvcGRvd24sIHsgY2xhc3NOYW1lOiBcImJuLXRhYmxlLWhhbmRsZS1tZW51XCIsIGNoaWxkcmVuOiBlLmNoaWxkcmVuIH0pLCBUZSA9IChlKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW46IHQsIC4uLm4gfSA9IGU7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3gody5JdGVtLCB7IC4uLm4sIGNoaWxkcmVuOiB0IH0pO1xufSwgVm8gPSAoZSkgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KFxuICBUZSxcbiAge1xuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBlLmJsb2NrLmNvbnRlbnQucm93c1tlLmluZGV4XS5jZWxscy5tYXAoXG4gICAgICAgICgpID0+IFtdXG4gICAgICApLCBuID0gWy4uLmUuYmxvY2suY29udGVudC5yb3dzXTtcbiAgICAgIG4uc3BsaWNlKGUuaW5kZXggKyAoZS5zaWRlID09PSBcImJlbG93XCIgPyAxIDogMCksIDAsIHtcbiAgICAgICAgY2VsbHM6IHRcbiAgICAgIH0pLCBlLmVkaXRvci51cGRhdGVCbG9jayhlLmJsb2NrLCB7XG4gICAgICAgIHR5cGU6IFwidGFibGVcIixcbiAgICAgICAgY29udGVudDoge1xuICAgICAgICAgIHR5cGU6IFwidGFibGVDb250ZW50XCIsXG4gICAgICAgICAgcm93czogblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBgQWRkIHJvdyAke2Uuc2lkZX1gXG4gIH1cbiksIEJvID0gKGUpID0+IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgVGUsXG4gIHtcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0ge1xuICAgICAgICB0eXBlOiBcInRhYmxlQ29udGVudFwiLFxuICAgICAgICByb3dzOiBlLmJsb2NrLmNvbnRlbnQucm93cy5tYXAoKG4pID0+IHtcbiAgICAgICAgICBjb25zdCByID0gWy4uLm4uY2VsbHNdO1xuICAgICAgICAgIHJldHVybiByLnNwbGljZShlLmluZGV4ICsgKGUuc2lkZSA9PT0gXCJyaWdodFwiID8gMSA6IDApLCAwLCBbXSksIHsgY2VsbHM6IHIgfTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgICBlLmVkaXRvci51cGRhdGVCbG9jayhlLmJsb2NrLCB7XG4gICAgICAgIHR5cGU6IFwidGFibGVcIixcbiAgICAgICAgY29udGVudDogdFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBjaGlsZHJlbjogYEFkZCBjb2x1bW4gJHtlLnNpZGV9YFxuICB9XG4pLCBSdCA9IChlKSA9PiBlLm9yaWVudGF0aW9uID09PSBcInJvd1wiID8gLyogQF9fUFVSRV9fICovIG8uanN4KFZvLCB7IC4uLmUsIHNpZGU6IGUuc2lkZSB9KSA6IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChCbywgeyAuLi5lLCBzaWRlOiBlLnNpZGUgfSksIExvID0gKGUpID0+IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgVGUsXG4gIHtcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0ge1xuICAgICAgICB0eXBlOiBcInRhYmxlQ29udGVudFwiLFxuICAgICAgICByb3dzOiBlLmJsb2NrLmNvbnRlbnQucm93cy5maWx0ZXIoXG4gICAgICAgICAgKG4sIHIpID0+IHIgIT09IGUuaW5kZXhcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICAgIGUuZWRpdG9yLnVwZGF0ZUJsb2NrKGUuYmxvY2ssIHtcbiAgICAgICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgICAgICBjb250ZW50OiB0XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBcIkRlbGV0ZSByb3dcIlxuICB9XG4pLCBEbyA9IChlKSA9PiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gIFRlLFxuICB7XG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHtcbiAgICAgICAgdHlwZTogXCJ0YWJsZUNvbnRlbnRcIixcbiAgICAgICAgcm93czogZS5ibG9jay5jb250ZW50LnJvd3MubWFwKChuKSA9PiAoe1xuICAgICAgICAgIGNlbGxzOiBuLmNlbGxzLmZpbHRlcigociwgaSkgPT4gaSAhPT0gZS5pbmRleClcbiAgICAgICAgfSkpXG4gICAgICB9O1xuICAgICAgZS5lZGl0b3IudXBkYXRlQmxvY2soZS5ibG9jaywge1xuICAgICAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgICAgIGNvbnRlbnQ6IHRcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2hpbGRyZW46IFwiRGVsZXRlIGNvbHVtblwiXG4gIH1cbiksIF9vID0gKGUpID0+IGUub3JpZW50YXRpb24gPT09IFwicm93XCIgPyAvKiBAX19QVVJFX18gKi8gby5qc3goTG8sIHsgLi4uZSB9KSA6IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChEbywgeyAuLi5lIH0pLCBJbyA9IChlKSA9PiAvKiBAX19QVVJFX18gKi8gby5qc3hzKFJvLCB7IGNoaWxkcmVuOiBbXG4gIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICBfbyxcbiAgICB7XG4gICAgICBvcmllbnRhdGlvbjogZS5vcmllbnRhdGlvbixcbiAgICAgIGVkaXRvcjogZS5lZGl0b3IsXG4gICAgICBibG9jazogZS5ibG9jayxcbiAgICAgIGluZGV4OiBlLmluZGV4XG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgUnQsXG4gICAge1xuICAgICAgb3JpZW50YXRpb246IGUub3JpZW50YXRpb24sXG4gICAgICBlZGl0b3I6IGUuZWRpdG9yLFxuICAgICAgYmxvY2s6IGUuYmxvY2ssXG4gICAgICBpbmRleDogZS5pbmRleCxcbiAgICAgIHNpZGU6IGUub3JpZW50YXRpb24gPT09IFwicm93XCIgPyBcImFib3ZlXCIgOiBcImxlZnRcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgIFJ0LFxuICAgIHtcbiAgICAgIG9yaWVudGF0aW9uOiBlLm9yaWVudGF0aW9uLFxuICAgICAgZWRpdG9yOiBlLmVkaXRvcixcbiAgICAgIGJsb2NrOiBlLmJsb2NrLFxuICAgICAgaW5kZXg6IGUuaW5kZXgsXG4gICAgICBzaWRlOiBlLm9yaWVudGF0aW9uID09PSBcInJvd1wiID8gXCJiZWxvd1wiIDogXCJyaWdodFwiXG4gICAgfVxuICApXG5dIH0pLCBPbyA9IChlKSA9PiB7XG4gIGNvbnN0IHQgPSBlLnRhYmxlSGFuZGxlTWVudSB8fCBJbywgW24sIHJdID0gcCghMSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3hzKFxuICAgIHcsXG4gICAge1xuICAgICAgd2l0aGluUG9ydGFsOiAhMSxcbiAgICAgIHRyaWdnZXI6IFwiY2xpY2tcIixcbiAgICAgIG9uT3BlbjogKCkgPT4ge1xuICAgICAgICBlLmZyZWV6ZUhhbmRsZXMoKSwgZS5oaWRlT3RoZXJTaWRlKCk7XG4gICAgICB9LFxuICAgICAgb25DbG9zZTogKCkgPT4ge1xuICAgICAgICBlLnVuZnJlZXplSGFuZGxlcygpLCBlLnNob3dPdGhlclNpZGUoKTtcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbjogXCJyaWdodFwiLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KHcuVGFyZ2V0LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGRlKFxuICAgICAgICAgICAgICBcImJuLXRhYmxlLWhhbmRsZVwiLFxuICAgICAgICAgICAgICBuID8gXCJibi10YWJsZS1oYW5kbGUtZHJhZ2dpbmdcIiA6IFwiXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBkcmFnZ2FibGU6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgb25EcmFnU3RhcnQ6IChpKSA9PiB7XG4gICAgICAgICAgICAgIHIoITApLCBlLmRyYWdTdGFydChpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdFbmQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgZS5kcmFnRW5kKCksIHIoITEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiBlLm9yaWVudGF0aW9uID09PSBcImNvbHVtblwiID8geyB0cmFuc2Zvcm06IFwicm90YXRlKDAuMjV0dXJuKVwiIH0gOiB2b2lkIDAsXG4gICAgICAgICAgICBjaGlsZHJlbjogZS5jaGlsZHJlblxuICAgICAgICAgIH1cbiAgICAgICAgKSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgICAgIHQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgb3JpZW50YXRpb246IGUub3JpZW50YXRpb24sXG4gICAgICAgICAgICBlZGl0b3I6IGUuZWRpdG9yLFxuICAgICAgICAgICAgYmxvY2s6IGUuYmxvY2ssXG4gICAgICAgICAgICBpbmRleDogZS5pbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXVxuICAgIH1cbiAgKTtcbn0sIFBvID0gKGUpID0+IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChPbywgeyAuLi5lLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4KGRuLCB7IHNpemU6IDI0LCBcImRhdGEtdGVzdFwiOiBcInRhYmxlSGFuZGxlXCIgfSkgfSksIEFvID0gKGUpID0+IHtcbiAgdmFyIGIsIFQ7XG4gIGNvbnN0IHQgPSBWKCk7XG4gIGlmICghdC50YWJsZUhhbmRsZXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUYWJsZUhhbmRsZXNDb250cm9sbGVyIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBCbG9ja05vdGUgZWRpdG9yIHNjaGVtYSBjb250YWlucyB0YWJsZSBibG9ja1wiXG4gICAgKTtcbiAgY29uc3QgbiA9IHtcbiAgICByb3dEcmFnU3RhcnQ6IHQudGFibGVIYW5kbGVzLnJvd0RyYWdTdGFydCxcbiAgICBjb2xEcmFnU3RhcnQ6IHQudGFibGVIYW5kbGVzLmNvbERyYWdTdGFydCxcbiAgICBkcmFnRW5kOiB0LnRhYmxlSGFuZGxlcy5kcmFnRW5kLFxuICAgIGZyZWV6ZUhhbmRsZXM6IHQudGFibGVIYW5kbGVzLmZyZWV6ZUhhbmRsZXMsXG4gICAgdW5mcmVlemVIYW5kbGVzOiB0LnRhYmxlSGFuZGxlcy51bmZyZWV6ZUhhbmRsZXNcbiAgfSwgciA9IHRlKFxuICAgIHQudGFibGVIYW5kbGVzLm9uVXBkYXRlLmJpbmQodC50YWJsZUhhbmRsZXMpXG4gICksIHsgcm93SGFuZGxlOiBpLCBjb2xIYW5kbGU6IGwgfSA9IE1vKFxuICAgIChyID09IG51bGwgPyB2b2lkIDAgOiByLnNob3cpIHx8ICExLFxuICAgIChyID09IG51bGwgPyB2b2lkIDAgOiByLnJlZmVyZW5jZVBvc0NlbGwpIHx8IG51bGwsXG4gICAgKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIucmVmZXJlbmNlUG9zVGFibGUpIHx8IG51bGwsXG4gICAgciAhPSBudWxsICYmIHIuZHJhZ2dpbmdTdGF0ZSA/IHtcbiAgICAgIGRyYWdnZWRDZWxsT3JpZW50YXRpb246IChiID0gciA9PSBudWxsID8gdm9pZCAwIDogci5kcmFnZ2luZ1N0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogYi5kcmFnZ2VkQ2VsbE9yaWVudGF0aW9uLFxuICAgICAgbW91c2VQb3M6IChUID0gciA9PSBudWxsID8gdm9pZCAwIDogci5kcmFnZ2luZ1N0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogVC5tb3VzZVBvc1xuICAgIH0gOiB2b2lkIDBcbiAgKSwgW2MsIHNdID0gcCghMSksIFtkLCBmXSA9IHAoITEpO1xuICBpZiAoIWkuaXNNb3VudGVkIHx8ICFsLmlzTW91bnRlZCB8fCAhcilcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgaCA9IGUudGFibGVIYW5kbGUgfHwgUG87XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3hzKG8uRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAhYyAmJiAvKiBAX19QVVJFX18gKi8gby5qc3goXCJkaXZcIiwgeyByZWY6IGkucmVmLCBzdHlsZTogaS5zdHlsZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICAgIGgsXG4gICAgICB7XG4gICAgICAgIGVkaXRvcjogdCxcbiAgICAgICAgb3JpZW50YXRpb246IFwicm93XCIsXG4gICAgICAgIHNob3dPdGhlclNpZGU6ICgpID0+IGYoITEpLFxuICAgICAgICBoaWRlT3RoZXJTaWRlOiAoKSA9PiBmKCEwKSxcbiAgICAgICAgaW5kZXg6IHIucm93SW5kZXgsXG4gICAgICAgIGJsb2NrOiByLmJsb2NrLFxuICAgICAgICBkcmFnU3RhcnQ6IG4ucm93RHJhZ1N0YXJ0LFxuICAgICAgICBkcmFnRW5kOiBuLmRyYWdFbmQsXG4gICAgICAgIGZyZWV6ZUhhbmRsZXM6IG4uZnJlZXplSGFuZGxlcyxcbiAgICAgICAgdW5mcmVlemVIYW5kbGVzOiBuLnVuZnJlZXplSGFuZGxlc1xuICAgICAgfVxuICAgICkgfSksXG4gICAgIWQgJiYgLyogQF9fUFVSRV9fICovIG8uanN4KFwiZGl2XCIsIHsgcmVmOiBsLnJlZiwgc3R5bGU6IGwuc3R5bGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICBoLFxuICAgICAge1xuICAgICAgICBlZGl0b3I6IHQsXG4gICAgICAgIG9yaWVudGF0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBzaG93T3RoZXJTaWRlOiAoKSA9PiBzKCExKSxcbiAgICAgICAgaGlkZU90aGVyU2lkZTogKCkgPT4gcyghMCksXG4gICAgICAgIGluZGV4OiByLmNvbEluZGV4LFxuICAgICAgICBibG9jazogci5ibG9jayxcbiAgICAgICAgZHJhZ1N0YXJ0OiBuLmNvbERyYWdTdGFydCxcbiAgICAgICAgZHJhZ0VuZDogbi5kcmFnRW5kLFxuICAgICAgICBmcmVlemVIYW5kbGVzOiBuLmZyZWV6ZUhhbmRsZXMsXG4gICAgICAgIHVuZnJlZXplSGFuZGxlczogbi51bmZyZWV6ZUhhbmRsZXNcbiAgICAgIH1cbiAgICApIH0pXG4gIF0gfSk7XG59O1xuZnVuY3Rpb24gRm8oZSkge1xuICBjb25zdCB0ID0gVigpO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJCbG9ja05vdGVEZWZhdWx0VUkgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEJsb2NrTm90ZUNvbnRleHQuUHJvdmlkZXJcIlxuICAgICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gby5qc3hzKG8uRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICBlLmZvcm1hdHRpbmdUb29sYmFyICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gby5qc3goYW8sIHt9KSxcbiAgICBlLmh5cGVybGlua1Rvb2xiYXIgIT09ICExICYmIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChsbywge30pLFxuICAgIGUuc2xhc2hNZW51ICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICBUbyxcbiAgICAgIHtcbiAgICAgICAgZ2V0SXRlbXM6IGFzeW5jIChuKSA9PiBJdChnbih0KSwgbiksXG4gICAgICAgIG9uSXRlbUNsaWNrOiAobikgPT4ge1xuICAgICAgICAgIG4ub25JdGVtQ2xpY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlckNoYXJhY3RlcjogXCIvXCJcbiAgICAgIH1cbiAgICApLFxuICAgIGUuc2lkZU1lbnUgIT09ICExICYmIC8qIEBfX1BVUkVfXyAqLyBvLmpzeCh4bywge30pLFxuICAgIHQuaW1hZ2VUb29sYmFyICYmIGUuaW1hZ2VUb29sYmFyICE9PSAhMSAmJiAvKiBAX19QVVJFX18gKi8gby5qc3goc28sIHt9KSxcbiAgICB0LnRhYmxlSGFuZGxlcyAmJiBlLnRhYmxlSGFuZGxlcyAhPT0gITEgJiYgLyogQF9fUFVSRV9fICovIG8uanN4KEFvLCB7fSlcbiAgXSB9KTtcbn1cbmNvbnN0IGhuID0gKGUsIHQsIG4gPSAhMSkgPT4ge1xuICBjb25zdCByID0gW107XG4gIGZ1bmN0aW9uIGkobCwgYyA9IFwiLS1iblwiKSB7XG4gICAgZm9yIChjb25zdCBzIGluIGwpIHtcbiAgICAgIGNvbnN0IGQgPSBzLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKSwgZiA9IGAke2N9LSR7ZH1gO1xuICAgICAgdHlwZW9mIGxbc10gIT0gXCJvYmplY3RcIiA/ICh0eXBlb2YgbFtzXSA9PSBcIm51bWJlclwiICYmIChsW3NdID0gYCR7bFtzXX1weGApLCBuID8gdC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShmKSA6IHQuc3R5bGUuc2V0UHJvcGVydHkoZiwgbFtzXS50b1N0cmluZygpKSkgOiBpKGxbc10sIGYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaShlKSwgcjtcbn0sIFZ0ID0gKGUsIHQpID0+IGhuKGUsIHQpLCBObyA9IHtcbiAgY29sb3JzOiB7XG4gICAgZWRpdG9yOiB7XG4gICAgICB0ZXh0OiB2b2lkIDAsXG4gICAgICBiYWNrZ3JvdW5kOiB2b2lkIDBcbiAgICB9LFxuICAgIG1lbnU6IHtcbiAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgIGJhY2tncm91bmQ6IHZvaWQgMFxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgdGV4dDogdm9pZCAwLFxuICAgICAgYmFja2dyb3VuZDogdm9pZCAwXG4gICAgfSxcbiAgICBob3ZlcmVkOiB7XG4gICAgICB0ZXh0OiB2b2lkIDAsXG4gICAgICBiYWNrZ3JvdW5kOiB2b2lkIDBcbiAgICB9LFxuICAgIHNlbGVjdGVkOiB7XG4gICAgICB0ZXh0OiB2b2lkIDAsXG4gICAgICBiYWNrZ3JvdW5kOiB2b2lkIDBcbiAgICB9LFxuICAgIGRpc2FibGVkOiB7XG4gICAgICB0ZXh0OiB2b2lkIDAsXG4gICAgICBiYWNrZ3JvdW5kOiB2b2lkIDBcbiAgICB9LFxuICAgIHNoYWRvdzogdm9pZCAwLFxuICAgIGJvcmRlcjogdm9pZCAwLFxuICAgIHNpZGVNZW51OiB2b2lkIDAsXG4gICAgaGlnaGxpZ2h0czoge1xuICAgICAgZ3JheToge1xuICAgICAgICB0ZXh0OiB2b2lkIDAsXG4gICAgICAgIGJhY2tncm91bmQ6IHZvaWQgMFxuICAgICAgfSxcbiAgICAgIGJyb3duOiB7XG4gICAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgICAgYmFja2dyb3VuZDogdm9pZCAwXG4gICAgICB9LFxuICAgICAgcmVkOiB7XG4gICAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgICAgYmFja2dyb3VuZDogdm9pZCAwXG4gICAgICB9LFxuICAgICAgb3JhbmdlOiB7XG4gICAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgICAgYmFja2dyb3VuZDogdm9pZCAwXG4gICAgICB9LFxuICAgICAgeWVsbG93OiB7XG4gICAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgICAgYmFja2dyb3VuZDogdm9pZCAwXG4gICAgICB9LFxuICAgICAgZ3JlZW46IHtcbiAgICAgICAgdGV4dDogdm9pZCAwLFxuICAgICAgICBiYWNrZ3JvdW5kOiB2b2lkIDBcbiAgICAgIH0sXG4gICAgICBibHVlOiB7XG4gICAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgICAgYmFja2dyb3VuZDogdm9pZCAwXG4gICAgICB9LFxuICAgICAgcHVycGxlOiB7XG4gICAgICAgIHRleHQ6IHZvaWQgMCxcbiAgICAgICAgYmFja2dyb3VuZDogdm9pZCAwXG4gICAgICB9LFxuICAgICAgcGluazoge1xuICAgICAgICB0ZXh0OiB2b2lkIDAsXG4gICAgICAgIGJhY2tncm91bmQ6IHZvaWQgMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYm9yZGVyUmFkaXVzOiB2b2lkIDAsXG4gIGZvbnRGYW1pbHk6IHZvaWQgMFxufSwgWm8gPSAoZSkgPT4gaG4oTm8sIGUsICEwKTtcbmZ1bmN0aW9uIHpvKGUpIHtcbiAgcmV0dXJuICh0KSA9PiB7XG4gICAgZS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgPyBuKHQpIDogbiAhPSBudWxsICYmIChuLmN1cnJlbnQgPSB0KTtcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IFVvID0gKHtcbiAgcmVuZGVyZXJzOiBlXG59KSA9PiAvKiBAX19QVVJFX18gKi8gby5qc3goby5GcmFnbWVudCwgeyBjaGlsZHJlbjogT2JqZWN0LmVudHJpZXMoZSkubWFwKChbdCwgbl0pID0+IG1yKG4ucmVhY3RFbGVtZW50LCBuLmVsZW1lbnQsIHQpKSB9KTtcbmZ1bmN0aW9uICRvKGUpIHtcbiAgY29uc3QgW3QsIG5dID0gcCh7fSk7XG4gIHJldHVybiBMKCgpID0+IChlLmVkaXRvci5fdGlwdGFwRWRpdG9yLmNvbnRlbnRDb21wb25lbnQgPSB7XG4gICAgc2V0UmVuZGVyZXIociwgaSkge1xuICAgICAgbigobCkgPT4gKHsgLi4ubCwgW3JdOiBpIH0pKTtcbiAgICB9LFxuICAgIHJlbW92ZVJlbmRlcmVyKHIpIHtcbiAgICAgIG4oKGkpID0+IHtcbiAgICAgICAgY29uc3QgbCA9IHsgLi4uaSB9O1xuICAgICAgICByZXR1cm4gZGVsZXRlIGxbcl0sIGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICBlLmVkaXRvci5fdGlwdGFwRWRpdG9yLmNyZWF0ZU5vZGVWaWV3cygpO1xuICB9KSwgKCkgPT4ge1xuICAgIGUuZWRpdG9yLl90aXB0YXBFZGl0b3IuY29udGVudENvbXBvbmVudCA9IG51bGw7XG4gIH0pLCBbZS5lZGl0b3IuX3RpcHRhcEVkaXRvcl0pLCAvKiBAX19QVVJFX18gKi8gby5qc3hzKG8uRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8gby5qc3goVW8sIHsgcmVuZGVyZXJzOiB0IH0pLFxuICAgIGUuY2hpbGRyZW5cbiAgXSB9KTtcbn1cbmNvbnN0IFdvID0ge1xuICAvLyBSZW1vdmVzIGJ1dHRvbiBwcmVzcyBlZmZlY3RcbiAgYWN0aXZlQ2xhc3NOYW1lOiBcIlwiXG59LCBCdCA9ICgpID0+IHtcbn07XG5mdW5jdGlvbiBxbyhlLCB0KSB7XG4gIGNvbnN0IHtcbiAgICBlZGl0b3I6IG4sXG4gICAgY2xhc3NOYW1lOiByLFxuICAgIHRoZW1lOiBpLFxuICAgIGNoaWxkcmVuOiBsLFxuICAgIGVkaXRhYmxlOiBjLFxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlOiBzLFxuICAgIG9uQ2hhbmdlOiBkLFxuICAgIGZvcm1hdHRpbmdUb29sYmFyOiBmLFxuICAgIGh5cGVybGlua1Rvb2xiYXI6IGgsXG4gICAgc2xhc2hNZW51OiBiLFxuICAgIHNpZGVNZW51OiBULFxuICAgIGltYWdlVG9vbGJhcjogQyxcbiAgICB0YWJsZUhhbmRsZXM6IEQsXG4gICAgLi4ubmVcbiAgfSA9IGUsIEYgPSBlZSgpLCBPID0gZ3IoKSwgTSA9IChGID09IG51bGwgPyB2b2lkIDAgOiBGLmNvbG9yU2NoZW1lUHJlZmVyZW5jZSkgfHwgTywgW0hlLCAkXSA9IHAodm9pZCAwKSwgaGUgPSBIKFxuICAgIChXKSA9PiB7XG4gICAgICBpZiAoVykge1xuICAgICAgICBpZiAoWm8oVyksIGkgPT09IFwibGlnaHRcIikge1xuICAgICAgICAgICQoXCJsaWdodFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IFwiZGFya1wiKSB7XG4gICAgICAgICAgJChcImRhcmtcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKFwibGlnaHRcIiBpbiBpICYmIFwiZGFya1wiIGluIGkpIHtcbiAgICAgICAgICAgIFZ0KFxuICAgICAgICAgICAgICBpW00gPT09IFwiZGFya1wiID8gXCJkYXJrXCIgOiBcImxpZ2h0XCJdLFxuICAgICAgICAgICAgICBXXG4gICAgICAgICAgICApLCAkKFxuICAgICAgICAgICAgICBNID09PSBcImRhcmtcIiA/IFwiZGFya1wiIDogXCJsaWdodFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBWdChpLCBXKSwgJCh2b2lkIDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAkKE0gPT09IFwiZGFya1wiID8gXCJkYXJrXCIgOiBcImxpZ2h0XCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW00sIGldXG4gICk7XG4gIEplKGQgfHwgQnQsIG4pLCBRZShzIHx8IEJ0LCBuKSwgTCgoKSA9PiB7XG4gICAgbi5pc0VkaXRhYmxlID0gYyAhPT0gITE7XG4gIH0sIFtjLCBuXSk7XG4gIGNvbnN0IEVlID0gQigoKSA9PiAvKiBAX19QVVJFX18gKi8gby5qc3hzKG8uRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICBsLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICAgIEZvLFxuICAgICAge1xuICAgICAgICBmb3JtYXR0aW5nVG9vbGJhcjogZixcbiAgICAgICAgaHlwZXJsaW5rVG9vbGJhcjogaCxcbiAgICAgICAgc2xhc2hNZW51OiBiLFxuICAgICAgICBzaWRlTWVudTogVCxcbiAgICAgICAgaW1hZ2VUb29sYmFyOiBDLFxuICAgICAgICB0YWJsZUhhbmRsZXM6IERcbiAgICAgIH1cbiAgICApXG4gIF0gfSksIFtcbiAgICBsLFxuICAgIGYsXG4gICAgaCxcbiAgICBDLFxuICAgIFQsXG4gICAgYixcbiAgICBEXG4gIF0pLCBNZSA9IEIoKCkgPT4gKHtcbiAgICAuLi5GLFxuICAgIGVkaXRvcjogblxuICB9KSwgW0YsIG5dKSwgUmUgPSBCKCgpID0+IHpvKFtoZSwgbi5fdGlwdGFwRWRpdG9yLm1vdW50LCB0XSksIFtoZSwgbi5fdGlwdGFwRWRpdG9yLm1vdW50LCB0XSk7XG4gIHJldHVybiAoXG4gICAgLy8gYGNzc1ZhcmlhYmxlc1NlbGVjdG9yYCBzY29wZXMgTWFudGluZSBDU1MgdmFyaWFibGVzIHRvIG9ubHkgdGhlIGVkaXRvcixcbiAgICAvLyBhcyBwcm9wb3NlZCBoZXJlOiAgaHR0cHM6Ly9naXRodWIuY29tL29yZ3MvbWFudGluZWRldi9kaXNjdXNzaW9ucy81Njg1XG4gICAgLyogQF9fUFVSRV9fICovIG8uanN4KGZyLCB7IHRoZW1lOiBXbywgY3NzVmFyaWFibGVzU2VsZWN0b3I6IFwiLmJuLWNvbnRhaW5lclwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4KEt0LlByb3ZpZGVyLCB7IHZhbHVlOiBNZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeCgkbywgeyBlZGl0b3I6IG4sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6IGRlKFwiYm4tY29udGFpbmVyXCIsIHIgfHwgXCJcIiksXG4gICAgICAgIFwiZGF0YS1jb2xvci1zY2hlbWVcIjogSGUsXG4gICAgICAgIC4uLm5lLFxuICAgICAgICByZWY6IFJlLFxuICAgICAgICBjaGlsZHJlbjogRWVcbiAgICAgIH1cbiAgICApIH0pIH0pIH0pXG4gICk7XG59XG5jb25zdCBvYSA9IEEuZm9yd2FyZFJlZihcbiAgcW9cbiksIHkgPSBbXG4gIFwiI0ZGRkZGRlwiLFxuICBcIiNFRkVGRUZcIixcbiAgXCIjQ0ZDRkNGXCIsXG4gIFwiI0FGQUZBRlwiLFxuICBcIiM3RjdGN0ZcIixcbiAgXCIjM0YzRjNGXCIsXG4gIFwiIzFGMUYxRlwiLFxuICBcIiMxNjE2MTZcIixcbiAgXCIjMEYwRjBGXCIsXG4gIFwiIzAwMDAwMFwiXG5dLCBMdCA9IHtcbiAgY29sb3JzOiB7XG4gICAgZWRpdG9yOiB7XG4gICAgICB0ZXh0OiB5WzVdLFxuICAgICAgYmFja2dyb3VuZDogeVswXVxuICAgIH0sXG4gICAgbWVudToge1xuICAgICAgdGV4dDogeVs1XSxcbiAgICAgIGJhY2tncm91bmQ6IHlbMF1cbiAgICB9LFxuICAgIHRvb2x0aXA6IHtcbiAgICAgIHRleHQ6IHlbNV0sXG4gICAgICBiYWNrZ3JvdW5kOiB5WzFdXG4gICAgfSxcbiAgICBob3ZlcmVkOiB7XG4gICAgICB0ZXh0OiB5WzVdLFxuICAgICAgYmFja2dyb3VuZDogeVsxXVxuICAgIH0sXG4gICAgc2VsZWN0ZWQ6IHtcbiAgICAgIHRleHQ6IHlbMF0sXG4gICAgICBiYWNrZ3JvdW5kOiB5WzVdXG4gICAgfSxcbiAgICBkaXNhYmxlZDoge1xuICAgICAgdGV4dDogeVszXSxcbiAgICAgIGJhY2tncm91bmQ6IHlbMV1cbiAgICB9LFxuICAgIHNoYWRvdzogeVsyXSxcbiAgICBib3JkZXI6IHlbMV0sXG4gICAgc2lkZU1lbnU6IHlbMl0sXG4gICAgaGlnaGxpZ2h0czoge1xuICAgICAgZ3JheToge1xuICAgICAgICB0ZXh0OiBcIiM5YjlhOTdcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZWJlY2VkXCJcbiAgICAgIH0sXG4gICAgICBicm93bjoge1xuICAgICAgICB0ZXh0OiBcIiM2NDQ3M2FcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZTllNWUzXCJcbiAgICAgIH0sXG4gICAgICByZWQ6IHtcbiAgICAgICAgdGV4dDogXCIjZTAzZTNlXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2ZiZTRlNFwiXG4gICAgICB9LFxuICAgICAgb3JhbmdlOiB7XG4gICAgICAgIHRleHQ6IFwiI2Q5NzMwZFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmNmU5ZDlcIlxuICAgICAgfSxcbiAgICAgIHllbGxvdzoge1xuICAgICAgICB0ZXh0OiBcIiNkZmFiMDFcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZmJmM2RiXCJcbiAgICAgIH0sXG4gICAgICBncmVlbjoge1xuICAgICAgICB0ZXh0OiBcIiM0ZDY0NjFcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZGRlZGVhXCJcbiAgICAgIH0sXG4gICAgICBibHVlOiB7XG4gICAgICAgIHRleHQ6IFwiIzBiNmU5OVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkZGViZjFcIlxuICAgICAgfSxcbiAgICAgIHB1cnBsZToge1xuICAgICAgICB0ZXh0OiBcIiM2OTQwYTVcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZWFlNGYyXCJcbiAgICAgIH0sXG4gICAgICBwaW5rOiB7XG4gICAgICAgIHRleHQ6IFwiI2FkMWE3MlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmNGRmZWJcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYm9yZGVyUmFkaXVzOiA2LFxuICBmb250RmFtaWx5OiAnXCJJbnRlclwiLCBcIlNGIFBybyBEaXNwbGF5XCIsIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJPcGVuIFNhbnNcIiwgXCJTZWdvZSBVSVwiLCBcIlJvYm90b1wiLCBcIk94eWdlblwiLCBcIlVidW50dVwiLCBcIkNhbnRhcmVsbFwiLCBcIkZpcmEgU2Fuc1wiLCBcIkRyb2lkIFNhbnNcIiwgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBzYW5zLXNlcmlmJ1xufSwgYWEgPSB7XG4gIGNvbG9yczoge1xuICAgIGVkaXRvcjoge1xuICAgICAgdGV4dDogeVsyXSxcbiAgICAgIGJhY2tncm91bmQ6IHlbNl1cbiAgICB9LFxuICAgIG1lbnU6IHtcbiAgICAgIHRleHQ6IHlbMl0sXG4gICAgICBiYWNrZ3JvdW5kOiB5WzZdXG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICB0ZXh0OiB5WzJdLFxuICAgICAgYmFja2dyb3VuZDogeVs3XVxuICAgIH0sXG4gICAgaG92ZXJlZDoge1xuICAgICAgdGV4dDogeVsyXSxcbiAgICAgIGJhY2tncm91bmQ6IHlbN11cbiAgICB9LFxuICAgIHNlbGVjdGVkOiB7XG4gICAgICB0ZXh0OiB5WzJdLFxuICAgICAgYmFja2dyb3VuZDogeVs4XVxuICAgIH0sXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHRleHQ6IHlbNV0sXG4gICAgICBiYWNrZ3JvdW5kOiB5WzddXG4gICAgfSxcbiAgICBzaGFkb3c6IHlbOF0sXG4gICAgYm9yZGVyOiB5WzddLFxuICAgIHNpZGVNZW51OiB5WzRdLFxuICAgIGhpZ2hsaWdodHM6IHtcbiAgICAgIGdyYXk6IHtcbiAgICAgICAgdGV4dDogXCIjYmViZGI4XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzliOWE5N1wiXG4gICAgICB9LFxuICAgICAgYnJvd246IHtcbiAgICAgICAgdGV4dDogXCIjOGU2NTUyXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzY0NDczYVwiXG4gICAgICB9LFxuICAgICAgcmVkOiB7XG4gICAgICAgIHRleHQ6IFwiI2VjNDA0MFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNiZTM0MzRcIlxuICAgICAgfSxcbiAgICAgIG9yYW5nZToge1xuICAgICAgICB0ZXh0OiBcIiNlMzc5MGRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjYjc2MDBhXCJcbiAgICAgIH0sXG4gICAgICB5ZWxsb3c6IHtcbiAgICAgICAgdGV4dDogXCIjZGZhYjAxXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2I1OGIwMFwiXG4gICAgICB9LFxuICAgICAgZ3JlZW46IHtcbiAgICAgICAgdGV4dDogXCIjNmI4Yjg3XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzRkNjQ2MVwiXG4gICAgICB9LFxuICAgICAgYmx1ZToge1xuICAgICAgICB0ZXh0OiBcIiMwZTg3YmNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMGI2ZTk5XCJcbiAgICAgIH0sXG4gICAgICBwdXJwbGU6IHtcbiAgICAgICAgdGV4dDogXCIjODU1MmQ3XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzY5NDBhNVwiXG4gICAgICB9LFxuICAgICAgcGluazoge1xuICAgICAgICB0ZXh0OiBcIiNkYTIwOGZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjYWQxYTcyXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJvcmRlclJhZGl1czogTHQuYm9yZGVyUmFkaXVzLFxuICBmb250RmFtaWx5OiBMdC5mb250RmFtaWx5XG59O1xuZnVuY3Rpb24gaWEoZSkge1xuICBjb25zdCB0ID0gZWUoKTtcbiAgaWYgKGUgfHwgKGUgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmVkaXRvciksICFlKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiJ2VkaXRvcicgaXMgcmVxdWlyZWQsIGVpdGhlciBmcm9tIEJsb2NrTm90ZUNvbnRleHQgb3IgYXMgYSBmdW5jdGlvbiBhcmd1bWVudFwiXG4gICAgKTtcbiAgY29uc3QgbiA9IGUsIFtyLCBpXSA9IHAoKCkgPT4gbi5nZXRBY3RpdmVTdHlsZXMoKSk7XG4gIHJldHVybiBKZSgoKSA9PiB7XG4gICAgaShuLmdldEFjdGl2ZVN0eWxlcygpKTtcbiAgfSwgbiksIFFlKCgpID0+IHtcbiAgICBpKG4uZ2V0QWN0aXZlU3R5bGVzKCkpO1xuICB9LCBuKSwgcjtcbn1cbmNvbnN0IFlvID0gKGUgPSB7fSwgdCA9IFtdKSA9PiBCKCgpID0+IHtcbiAgY29uc3QgbiA9IFluLmNyZWF0ZShlKTtcbiAgcmV0dXJuIHdpbmRvdyAmJiAod2luZG93LlByb3NlTWlycm9yID0gbi5fdGlwdGFwRWRpdG9yKSwgbjtcbn0sIHQpLCBsYSA9IFlvO1xuZnVuY3Rpb24gS28oKSB7XG4gIGNvbnN0IFssIGVdID0gcCgwKTtcbiAgcmV0dXJuICgpID0+IGUoKHQpID0+IHQgKyAxKTtcbn1cbmNvbnN0IHNhID0gKGUpID0+IHtcbiAgY29uc3QgdCA9IEtvKCk7XG4gIEwoKCkgPT4ge1xuICAgIGNvbnN0IG4gPSAoKSA9PiB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBlLm9uKFwidHJhbnNhY3Rpb25cIiwgbiksICgpID0+IHtcbiAgICAgIGUub2ZmKFwidHJhbnNhY3Rpb25cIiwgbik7XG4gICAgfTtcbiAgfSwgW2VdKTtcbn07XG52YXIgcWUsIHllID0gaHI7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKVxuICBxZSA9IHllLmNyZWF0ZVJvb3QsIHllLmh5ZHJhdGVSb290O1xuZWxzZSB7XG4gIHZhciBEdCA9IHllLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICBxZSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBEdC51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSAhMDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHllLmNyZWF0ZVJvb3QoZSwgdCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIER0LnVzaW5nQ2xpZW50RW50cnlQb2ludCA9ICExO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFNlKGUpIHtcbiAgbGV0IHQ7XG4gIGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCByID0gcWUobik7XG4gIGlmIChicigoKSA9PiB7XG4gICAgci5yZW5kZXIoZSgocykgPT4gdCA9IHMgfHwgdm9pZCAwKSk7XG4gIH0pLCAhbi5jaGlsZEVsZW1lbnRDb3VudClcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUmVhY3RJbmxpbmVDb250ZW50U3BlYzogcmVuZGVySFRNTCgpIGZhaWxlZFwiKSwge1xuICAgICAgZG9tOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKVxuICAgIH07XG4gIHQgPT0gbnVsbCB8fCB0LnNldEF0dHJpYnV0ZShcImRhdGEtdG1wLWZpbmRcIiwgXCJ0cnVlXCIpO1xuICBjb25zdCBpID0gbi5jbG9uZU5vZGUoITApLCBsID0gaS5maXJzdEVsZW1lbnRDaGlsZCwgYyA9IGkucXVlcnlTZWxlY3RvcihcbiAgICBcIltkYXRhLXRtcC1maW5kXVwiXG4gICk7XG4gIHJldHVybiBjID09IG51bGwgfHwgYy5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRtcC1maW5kXCIpLCByLnVubW91bnQoKSwge1xuICAgIGRvbTogbCxcbiAgICBjb250ZW50RE9NOiBjIHx8IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gRmUoZSkge1xuICB2YXIgdDtcbiAgcmV0dXJuIChcbiAgICAvLyBDcmVhdGVzIGBibG9ja0NvbnRlbnRgIGVsZW1lbnRcbiAgICAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICBXdCxcbiAgICAgIHtcbiAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGUuZG9tQXR0cmlidXRlcyB8fCB7fSkuZmlsdGVyKFxuICAgICAgICAgICAgKFtuXSkgPT4gbiAhPT0gXCJjbGFzc1wiXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICBjbGFzc05hbWU6IGRlKFxuICAgICAgICAgIFwiYm4tYmxvY2stY29udGVudFwiLFxuICAgICAgICAgICgodCA9IGUuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IHQuY2xhc3MpIHx8IFwiXCJcbiAgICAgICAgKSxcbiAgICAgICAgXCJkYXRhLWNvbnRlbnQtdHlwZVwiOiBlLmJsb2NrVHlwZSxcbiAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGUuYmxvY2tQcm9wcykuZmlsdGVyKFxuICAgICAgICAgICAgKFtuLCByXSkgPT4gIUtuLmluY2x1ZGVzKG4pICYmIHIgIT09IGUucHJvcFNjaGVtYVtuXS5kZWZhdWx0XG4gICAgICAgICAgKS5tYXAoKFtuLCByXSkgPT4gW090KG4pLCByXSlcbiAgICAgICAgKSxcbiAgICAgICAgY2hpbGRyZW46IGUuY2hpbGRyZW5cbiAgICAgIH1cbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBjYShlLCB0KSB7XG4gIGNvbnN0IG4gPSBQdCh7XG4gICAgbmFtZTogZS50eXBlLFxuICAgIGNvbnRlbnQ6IGUuY29udGVudCA9PT0gXCJpbmxpbmVcIiA/IFwiaW5saW5lKlwiIDogXCJcIixcbiAgICBncm91cDogXCJibG9ja0NvbnRlbnRcIixcbiAgICBzZWxlY3RhYmxlOiAhMCxcbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgcmV0dXJuIEF0KGUucHJvcFNjaGVtYSk7XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICByZXR1cm4gR24oZSwgdC5wYXJzZSk7XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKCkge1xuICAgICAgY29uc3QgciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByZXR1cm4gci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRtcC1wbGFjZWhvbGRlclwiLCBcInRydWVcIiksIHtcbiAgICAgICAgZG9tOiByXG4gICAgICB9O1xuICAgIH0sXG4gICAgYWRkTm9kZVZpZXcoKSB7XG4gICAgICByZXR1cm4gKHIpID0+IHF0KFxuICAgICAgICAoaSkgPT4ge1xuICAgICAgICAgIHZhciBoO1xuICAgICAgICAgIGNvbnN0IGwgPSB0aGlzLm9wdGlvbnMuZWRpdG9yLCBjID0gSm4oXG4gICAgICAgICAgICBpLmdldFBvcyxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIGUudHlwZVxuICAgICAgICAgICksIHMgPSAoKGggPSB0aGlzLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGguYmxvY2tDb250ZW50KSB8fCB7fSwgZCA9IFl0KHt9KS5yZWYsIGYgPSB0LnJlbmRlcjtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgICAgICAgRmUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJsb2NrVHlwZTogYy50eXBlLFxuICAgICAgICAgICAgICBibG9ja1Byb3BzOiBjLnByb3BzLFxuICAgICAgICAgICAgICBwcm9wU2NoZW1hOiBlLnByb3BTY2hlbWEsXG4gICAgICAgICAgICAgIGRvbUF0dHJpYnV0ZXM6IHMsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBibG9jazogYyxcbiAgICAgICAgICAgICAgICAgIGVkaXRvcjogbCxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnRSZWY6IGRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImJuLXJlYWN0LW5vZGUtdmlldy1yZW5kZXJlclwiXG4gICAgICAgIH1cbiAgICAgICkocik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFFuKGUsIHtcbiAgICBub2RlOiBuLFxuICAgIHRvSW50ZXJuYWxIVE1MOiAociwgaSkgPT4ge1xuICAgICAgdmFyIGQsIGY7XG4gICAgICBjb25zdCBsID0gKChkID0gbi5vcHRpb25zLmRvbUF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBkLmJsb2NrQ29udGVudCkgfHwge30sIGMgPSB0LnJlbmRlciwgcyA9IFNlKChoKSA9PiAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgIEZlLFxuICAgICAgICB7XG4gICAgICAgICAgYmxvY2tUeXBlOiByLnR5cGUsXG4gICAgICAgICAgYmxvY2tQcm9wczogci5wcm9wcyxcbiAgICAgICAgICBwcm9wU2NoZW1hOiBlLnByb3BTY2hlbWEsXG4gICAgICAgICAgZG9tQXR0cmlidXRlczogbCxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmxvY2s6IHIsXG4gICAgICAgICAgICAgIGVkaXRvcjogaSxcbiAgICAgICAgICAgICAgY29udGVudFJlZjogaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgICByZXR1cm4gKGYgPSBzLmNvbnRlbnRET00pID09IG51bGwgfHwgZi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRhYmxlXCIsIFwiXCIpLCBzO1xuICAgIH0sXG4gICAgdG9FeHRlcm5hbEhUTUw6IChyLCBpKSA9PiB7XG4gICAgICB2YXIgZCwgZjtcbiAgICAgIGNvbnN0IGwgPSAoKGQgPSBuLm9wdGlvbnMuZG9tQXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGQuYmxvY2tDb250ZW50KSB8fCB7fSwgYyA9IHQudG9FeHRlcm5hbEhUTUwgfHwgdC5yZW5kZXIsIHMgPSBTZSgoaCkgPT4gLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgICBGZSxcbiAgICAgICAge1xuICAgICAgICAgIGJsb2NrVHlwZTogci50eXBlLFxuICAgICAgICAgIGJsb2NrUHJvcHM6IHIucHJvcHMsXG4gICAgICAgICAgcHJvcFNjaGVtYTogZS5wcm9wU2NoZW1hLFxuICAgICAgICAgIGRvbUF0dHJpYnV0ZXM6IGwsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJsb2NrOiByLFxuICAgICAgICAgICAgICBlZGl0b3I6IGksXG4gICAgICAgICAgICAgIGNvbnRlbnRSZWY6IGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICkpO1xuICAgICAgcmV0dXJuIChmID0gcy5jb250ZW50RE9NKSA9PSBudWxsIHx8IGYuc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0YWJsZVwiLCBcIlwiKSwgcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gR28oZSwgdCwgbiwgcikge1xuICByZXR1cm4gKCkgPT4gKFxuICAgIC8vIENyZWF0ZXMgaW5saW5lIGNvbnRlbnQgc2VjdGlvbiBlbGVtZW50XG4gICAgLyogQF9fUFVSRV9fICovIG8uanN4KFxuICAgICAgV3QsXG4gICAgICB7XG4gICAgICAgIGFzOiBcInNwYW5cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcImJuLWlubGluZS1jb250ZW50LXNlY3Rpb25cIixcbiAgICAgICAgXCJkYXRhLWlubGluZS1jb250ZW50LXR5cGVcIjogdCxcbiAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG4pLmZpbHRlcigoW2ksIGxdKSA9PiBsICE9PSByW2ldLmRlZmF1bHQpLm1hcCgoW2ksIGxdKSA9PiBbT3QoaSksIGxdKVxuICAgICAgICApLFxuICAgICAgICBjaGlsZHJlbjogZVxuICAgICAgfVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIHVhKGUsIHQpIHtcbiAgY29uc3QgbiA9IFB0KHtcbiAgICBuYW1lOiBlLnR5cGUsXG4gICAgaW5saW5lOiAhMCxcbiAgICBncm91cDogXCJpbmxpbmVcIixcbiAgICBzZWxlY3RhYmxlOiBlLmNvbnRlbnQgPT09IFwic3R5bGVkXCIsXG4gICAgYXRvbTogZS5jb250ZW50ID09PSBcIm5vbmVcIixcbiAgICBjb250ZW50OiBlLmNvbnRlbnQgPT09IFwic3R5bGVkXCIgPyBcImlubGluZSpcIiA6IFwiXCIsXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBBdChlLnByb3BTY2hlbWEpO1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICByZXR1cm4gWG4oZSk7XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICByZXR1cm4gZXIoZSk7XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgbm9kZTogciB9KSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5vcHRpb25zLmVkaXRvciwgbCA9IFN0KFxuICAgICAgICByLFxuICAgICAgICBpLnNjaGVtYS5pbmxpbmVDb250ZW50U2NoZW1hLFxuICAgICAgICBpLnNjaGVtYS5zdHlsZVNjaGVtYVxuICAgICAgKSwgYyA9IHQucmVuZGVyLCBzID0gU2UoKGQpID0+IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChjLCB7IGlubGluZUNvbnRlbnQ6IGwsIGNvbnRlbnRSZWY6IGQgfSkpO1xuICAgICAgcmV0dXJuIHRyKFxuICAgICAgICBzLFxuICAgICAgICBlLnR5cGUsXG4gICAgICAgIHIuYXR0cnMsXG4gICAgICAgIGUucHJvcFNjaGVtYVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIFRPRE86IG5lZWRlZD9cbiAgICBhZGROb2RlVmlldygpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMuZWRpdG9yO1xuICAgICAgcmV0dXJuIChpKSA9PiBxdChcbiAgICAgICAgKGwpID0+IHtcbiAgICAgICAgICBjb25zdCBjID0gWXQoe30pLnJlZiwgcyA9IHQucmVuZGVyLCBkID0gR28oXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gby5qc3goXG4gICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50UmVmOiBjLFxuICAgICAgICAgICAgICAgIGlubGluZUNvbnRlbnQ6IFN0KFxuICAgICAgICAgICAgICAgICAgbC5ub2RlLFxuICAgICAgICAgICAgICAgICAgci5zY2hlbWEuaW5saW5lQ29udGVudFNjaGVtYSxcbiAgICAgICAgICAgICAgICAgIHIuc2NoZW1hLnN0eWxlU2NoZW1hXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZS50eXBlLFxuICAgICAgICAgICAgbC5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgZS5wcm9wU2NoZW1hXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG8uanN4KGQsIHt9KTtcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogXCJibi1pYy1yZWFjdC1ub2RlLXZpZXctcmVuZGVyZXJcIixcbiAgICAgICAgICBhczogXCJzcGFuXCJcbiAgICAgICAgICAvLyBjb250ZW50RE9NRWxlbWVudFRhZzogXCJzcGFuXCIsIChyZXF1aXJlcyB0dCB1cGdyYWRlKVxuICAgICAgICB9XG4gICAgICApKGkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBucihlLCB7XG4gICAgbm9kZTogblxuICB9KTtcbn1cbmZ1bmN0aW9uIGRhKGUsIHQpIHtcbiAgY29uc3QgbiA9IHhyLmNyZWF0ZSh7XG4gICAgbmFtZTogZS50eXBlLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICByZXR1cm4gcnIoZS5wcm9wU2NoZW1hKTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgIHJldHVybiBvcihlKTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBtYXJrOiByIH0pIHtcbiAgICAgIGNvbnN0IGkgPSB7fTtcbiAgICAgIGUucHJvcFNjaGVtYSA9PT0gXCJzdHJpbmdcIiAmJiAoaS52YWx1ZSA9IHIuYXR0cnMuc3RyaW5nVmFsdWUpO1xuICAgICAgY29uc3QgbCA9IHQucmVuZGVyLCBjID0gU2UoKHMpID0+IC8qIEBfX1BVUkVfXyAqLyBvLmpzeChsLCB7IC4uLmksIGNvbnRlbnRSZWY6IHMgfSkpO1xuICAgICAgcmV0dXJuIGFyKFxuICAgICAgICBjLFxuICAgICAgICBlLnR5cGUsXG4gICAgICAgIHIuYXR0cnMuc3RyaW5nVmFsdWUsXG4gICAgICAgIGUucHJvcFNjaGVtYVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaXIoZSwge1xuICAgIG1hcms6IG5cbiAgfSk7XG59XG5leHBvcnQge1xuICB1byBhcyBBZGRCbG9ja0J1dHRvbixcbiAga2UgYXMgQmFzaWNUZXh0U3R5bGVCdXR0b24sXG4gIGZvIGFzIEJsb2NrQ29sb3JzSXRlbSxcbiAgRmUgYXMgQmxvY2tDb250ZW50V3JhcHBlcixcbiAgS3QgYXMgQmxvY2tOb3RlQ29udGV4dCxcbiAgRm8gYXMgQmxvY2tOb3RlRGVmYXVsdFVJLFxuICBvYSBhcyBCbG9ja05vdGVWaWV3LFxuICBubyBhcyBCbG9ja1R5cGVEcm9wZG93bixcbiAgWnIgYXMgQ29sb3JTdHlsZUJ1dHRvbixcbiAgVXIgYXMgQ3JlYXRlTGlua0J1dHRvbixcbiAgbW8gYXMgRHJhZ0hhbmRsZUJ1dHRvbixcbiAgaG8gYXMgRHJhZ0hhbmRsZU1lbnUsXG4gIGZuIGFzIERyYWdIYW5kbGVNZW51SXRlbSxcbiAgbG4gYXMgRWRpdEh5cGVybGlua01lbnUsXG4gIG9vIGFzIEZvcm1hdHRpbmdUb29sYmFyLFxuICBhbyBhcyBGb3JtYXR0aW5nVG9vbGJhckNvbnRyb2xsZXIsXG4gIGlvIGFzIEh5cGVybGlua1Rvb2xiYXIsXG4gIGxvIGFzIEh5cGVybGlua1Rvb2xiYXJDb250cm9sbGVyLFxuICAkciBhcyBJbWFnZUNhcHRpb25CdXR0b24sXG4gIGNuIGFzIEltYWdlVG9vbGJhcixcbiAgc28gYXMgSW1hZ2VUb29sYmFyQ29udHJvbGxlcixcbiAgV3IgYXMgTmVzdEJsb2NrQnV0dG9uLFxuICBnbyBhcyBSZW1vdmVCbG9ja0l0ZW0sXG4gIFlyIGFzIFJlcGxhY2VJbWFnZUJ1dHRvbixcbiAgYm8gYXMgU2lkZU1lbnUsXG4gIHVuIGFzIFNpZGVNZW51QnV0dG9uLFxuICB4byBhcyBTaWRlTWVudUNvbnRyb2xsZXIsXG4gIHdvIGFzIFN1Z2dlc3Rpb25NZW51LFxuICBUbyBhcyBTdWdnZXN0aW9uTWVudUNvbnRyb2xsZXIsXG4gIGpvIGFzIFN1Z2dlc3Rpb25NZW51SXRlbSxcbiAgQ28gYXMgU3VnZ2VzdGlvbk1lbnVXcmFwcGVyLFxuICBQbyBhcyBUYWJsZUhhbmRsZSxcbiAgQW8gYXMgVGFibGVIYW5kbGVzQ29udHJvbGxlcixcbiAgQWUgYXMgVGV4dEFsaWduQnV0dG9uLFxuICBQIGFzIFRvb2xiYXJCdXR0b24sXG4gIGVvIGFzIFRvb2xiYXJEcm9wZG93bixcbiAgcXIgYXMgVW5uZXN0QmxvY2tCdXR0b24sXG4gIFZ0IGFzIGFwcGx5QmxvY2tOb3RlQ1NTVmFyaWFibGVzRnJvbVRoZW1lLFxuICB0byBhcyBibG9ja1R5cGVEcm9wZG93bkl0ZW1zLFxuICBjYSBhcyBjcmVhdGVSZWFjdEJsb2NrU3BlYyxcbiAgdWEgYXMgY3JlYXRlUmVhY3RJbmxpbmVDb250ZW50U3BlYyxcbiAgZGEgYXMgY3JlYXRlUmVhY3RTdHlsZVNwZWMsXG4gIGFhIGFzIGRhcmtEZWZhdWx0VGhlbWUsXG4gIHkgYXMgZGVmYXVsdENvbG9yU2NoZW1lLFxuICBnbiBhcyBnZXREZWZhdWx0UmVhY3RTbGFzaE1lbnVJdGVtcyxcbiAgcm8gYXMgZ2V0Rm9ybWF0dGluZ1Rvb2xiYXJJdGVtcyxcbiAgTHQgYXMgbGlnaHREZWZhdWx0VGhlbWUsXG4gIEdvIGFzIHJlYWN0V3JhcEluSW5saW5lQ29udGVudFN0cnVjdHVyZSxcbiAgWm8gYXMgcmVtb3ZlQmxvY2tOb3RlQ1NTVmFyaWFibGVzLFxuICBpYSBhcyB1c2VBY3RpdmVTdHlsZXMsXG4gIGxhIGFzIHVzZUJsb2NrTm90ZSxcbiAgZWUgYXMgdXNlQmxvY2tOb3RlQ29udGV4dCxcbiAgViBhcyB1c2VCbG9ja05vdGVFZGl0b3IsXG4gIHBvIGFzIHVzZUNsb3NlU3VnZ2VzdGlvbk1lbnVOb0l0ZW1zLFxuICBZbyBhcyB1c2VDcmVhdGVCbG9ja05vdGUsXG4gIEplIGFzIHVzZUVkaXRvckNoYW5nZSxcbiAgVSBhcyB1c2VFZGl0b3JDb250ZW50T3JTZWxlY3Rpb25DaGFuZ2UsXG4gIHNhIGFzIHVzZUVkaXRvckZvcmNlVXBkYXRlLFxuICBRZSBhcyB1c2VFZGl0b3JTZWxlY3Rpb25DaGFuZ2UsXG4gIGtvIGFzIHVzZUxvYWRTdWdnZXN0aW9uTWVudUl0ZW1zLFxuICBLIGFzIHVzZVNlbGVjdGVkQmxvY2tzLFxuICB5byBhcyB1c2VTdWdnZXN0aW9uTWVudUtleWJvYXJkTmF2aWdhdGlvbixcbiAgTW8gYXMgdXNlVGFibGVIYW5kbGVzUG9zaXRpb25pbmdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9ja25vdGUtcmVhY3QuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@blocknote/react/dist/blocknote-react.js\n");

/***/ })

};
;